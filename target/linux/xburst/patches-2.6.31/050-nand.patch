--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -420,4 +420,10 @@ config MTD_NAND_SH_FLCTL
 	  Several Renesas SuperH CPU has FLCTL. This option enables support
 	  for NAND Flash using FLCTL. This driver support SH7723.
 
+config MTD_NAND_JZ4740
+	tristate "Support NAND Flash device on Jz4740 board"
+	depends on SOC_JZ4740
+	help
+	Support NAND Flash device on Jz4740 board
+
 endif # MTD_NAND
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -40,5 +40,6 @@ obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_
 obj-$(CONFIG_MTD_NAND_MXC)		+= mxc_nand.o
 obj-$(CONFIG_MTD_NAND_SOCRATES)		+= socrates_nand.o
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
+obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740_nand.o
 
 nand-objs := nand_base.o nand_bbt.o

diff --git a/arch/mips/jz4740/platform.c b/arch/mips/jz4740/platform.c
index 4ce8e3a..ee5c90d 100644
--- a/arch/mips/jz4740/platform.c
+++ b/arch/mips/jz4740/platform.c
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/resource.h>
+#include <linux/mtd/jz4740_nand.h>
 
 #include <asm/jzsoc.h>
 
@@ -152,12 +153,70 @@ static struct platform_device jz_i2c_device = {
 	.resource       = jz_i2c_resources,
 };
 
+static struct resource jz_nand_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(EMC_BASE),
+		.end            = CPHYSADDR(EMC_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+};
+
+static struct nand_ecclayout qi_lb60_ecclayout = {
+	.eccbytes = 36,
+	.eccpos = {
+		6,  7,  8,  9,  10, 11, 12, 13,
+		14, 15, 16, 17, 18, 19, 20, 21,
+		22, 23, 24, 25, 26, 27, 28, 29,
+		30, 31, 32, 33, 34, 35, 36, 37,
+		38, 39, 40, 41},
+	.oobfree = {
+		{.offset = 0,
+		 .length = 6},
+		{.offset = 42,
+		 .length = 22}}
+};
+
+static struct mtd_partition qi_lb60_partitions[] = {
+	{ .name =	"NAND BOOT partition",
+	  .offset =	0 * 0x100000,
+	  .size =	4 * 0x100000,
+	},
+	{ .name =	"NAND KERNEL partition",
+	  .offset =	4 * 0x100000,
+	  .size =	4 * 0x100000,
+	},
+	{ .name =	"NAND ROOTFS partition",
+	  .offset =	8 * 0x100000,
+	  .size =	20 * 0x100000,
+	},
+	{ .name =	"NAND DATA partition",
+	  .offset =	100 * 0x100000,
+	  .size =	20 * 0x100000,
+	},
+};
+
+static struct jz_nand_platform_data jz_nand_platform_data = {
+	.num_partitions = ARRAY_SIZE(qi_lb60_partitions),
+	.partitions = qi_lb60_partitions,
+	.ecc_layout = &qi_lb60_ecclayout,
+};
+
+static struct platform_device jz_nand_device = {
+	.name = "jz4740-nand",
+	.num_resources = ARRAY_SIZE(jz_nand_resources),
+	.resource = jz_nand_resources,
+	.dev = {
+		.platform_data = &jz_nand_platform_data,
+	}
+};
+
 /* All */
 static struct platform_device *jz_platform_devices[] __initdata = {
 	&jz_usb_ohci_device,
 	&jz_lcd_device,
 	&jz_usb_gdt_device,
 	&jz_mmc_device,
+	&jz_nand_device,
 	&jz_i2c_device,
 };
 
diff --git a/drivers/mtd/nand/jz4740_nand.c b/drivers/mtd/nand/jz4740_nand.c
index 92f0afe..08a7b37 100644
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 0a9c9cd..3870dcc 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -896,29 +896,22 @@ static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
 	uint8_t *ecc_calc = chip->buffers->ecccalc;
 	uint8_t *ecc_code = chip->buffers->ecccode;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
-
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->ecc.hwctl(mtd, NAND_ECC_READ);
-		chip->read_buf(mtd, p, eccsize);
-		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
-	}
-	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	int stat;
 
 	for (i = 0; i < chip->ecc.total; i++)
 		ecc_code[i] = chip->oob_poi[eccpos[i]];
 
-	eccsteps = chip->ecc.steps;
-	p = buf;
-
-	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		int stat;
 
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
 		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
 		if (stat < 0)
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
 	}
+
 	return 0;
 }
 
@@ -1068,6 +1061,8 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 			bufpoi = aligned ? buf : chip->buffers->databuf;
 
 			if (likely(sndcmd)) {
+				chip->cmdfunc(mtd, NAND_CMD_READOOB, 0x00, page);
+				chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 				chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
 				sndcmd = 0;
 			}
