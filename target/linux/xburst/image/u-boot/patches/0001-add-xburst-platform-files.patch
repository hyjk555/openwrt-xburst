From 5c38420f8091019aac00b5c0c2846f0c35b297c4 Mon Sep 17 00:00:00 2001
From: Xiangfu Liu <xiangfu@qi-hardware.com>
Date: Mon, 12 Oct 2009 11:22:48 +0800
Subject: [PATCH] add xburst platform files

---
 board/qi_lb60/Makefile            |   38 +
 board/qi_lb60/config.mk           |   33 +
 board/qi_lb60/config.tmp          |    1 +
 board/qi_lb60/flash.c             |   50 +
 board/qi_lb60/qi_lb60.c           |  103 +
 board/qi_lb60/u-boot-nand.lds     |   63 +
 board/qi_lb60/u-boot.lds          |   63 +
 cpu/mips/jz4740.c                 |  574 +++++
 cpu/mips/jz4740_cpm_test.c        |   98 +
 cpu/mips/jz4740_nand.c            |  198 ++
 cpu/mips/jz_cs8900.c              |  397 +++
 cpu/mips/jz_cs8900.h              |  258 ++
 cpu/mips/jz_eth.c                 |  376 +++
 cpu/mips/jz_eth.h                 |  267 ++
 cpu/mips/jz_i2c.c                 |  234 ++
 cpu/mips/jz_lcd.c                 |  643 +++++
 cpu/mips/jz_lcd.h                 | 1020 ++++++++
 cpu/mips/jz_mmc.c                 | 1404 +++++++++++
 cpu/mips/jz_mmc.h                 |  113 +
 cpu/mips/jz_serial.c              |  167 ++
 cpu/mips/mmc_protocol.h           |  273 +++
 cpu/mips/usb_boot.S               |  821 +++++++
 include/asm-mips/jz4740.h         | 4880 +++++++++++++++++++++++++++++++++++++
 include/configs/qi_lb60.h         |  210 ++
 nand_spl/board/qi_lb60/Makefile   |  104 +
 nand_spl/board/qi_lb60/config.mk  |   34 +
 nand_spl/board/qi_lb60/u-boot.lds |   63 +
 nand_spl/nand_boot_jz4740.c       |  456 ++++
 28 files changed, 12941 insertions(+), 0 deletions(-)
 create mode 100644 board/qi_lb60/Makefile
 create mode 100644 board/qi_lb60/config.mk
 create mode 100644 board/qi_lb60/config.tmp
 create mode 100644 board/qi_lb60/flash.c
 create mode 100644 board/qi_lb60/qi_lb60.c
 create mode 100644 board/qi_lb60/u-boot-nand.lds
 create mode 100644 board/qi_lb60/u-boot.lds
 create mode 100644 cpu/mips/jz4740.c
 create mode 100644 cpu/mips/jz4740_cpm_test.c
 create mode 100644 cpu/mips/jz4740_nand.c
 create mode 100644 cpu/mips/jz_cs8900.c
 create mode 100644 cpu/mips/jz_cs8900.h
 create mode 100644 cpu/mips/jz_eth.c
 create mode 100644 cpu/mips/jz_eth.h
 create mode 100644 cpu/mips/jz_i2c.c
 create mode 100644 cpu/mips/jz_lcd.c
 create mode 100644 cpu/mips/jz_lcd.h
 create mode 100644 cpu/mips/jz_mmc.c
 create mode 100644 cpu/mips/jz_mmc.h
 create mode 100644 cpu/mips/jz_serial.c
 create mode 100644 cpu/mips/mmc_protocol.h
 create mode 100644 cpu/mips/usb_boot.S
 create mode 100644 include/asm-mips/jz4740.h
 create mode 100644 include/configs/qi_lb60.h
 create mode 100644 nand_spl/board/qi_lb60/Makefile
 create mode 100644 nand_spl/board/qi_lb60/config.mk
 create mode 100644 nand_spl/board/qi_lb60/u-boot.lds
 create mode 100644 nand_spl/nand_boot_jz4740.c

diff --git a/board/qi_lb60/Makefile b/board/qi_lb60/Makefile
new file mode 100644
index 0000000..470447d
--- /dev/null
+++ b/board/qi_lb60/Makefile
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o 
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/qi_lb60/config.mk b/board/qi_lb60/config.mk
new file mode 100644
index 0000000..56b77d3
--- /dev/null
+++ b/board/qi_lb60/config.mk
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's PI board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff --git a/board/qi_lb60/config.tmp b/board/qi_lb60/config.tmp
new file mode 100644
index 0000000..3ea6c8c
--- /dev/null
+++ b/board/qi_lb60/config.tmp
@@ -0,0 +1 @@
+TEXT_BASE = 0x80100000
diff --git a/board/qi_lb60/flash.c b/board/qi_lb60/flash.c
new file mode 100644
index 0000000..891c604
--- /dev/null
+++ b/board/qi_lb60/flash.c
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2009 PI
+ * xiangfu liu, <xiangfu@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	return (0);
+}
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	printf ("flash_erase not implemented\n");
+	return 0;
+}
+
+void flash_print_info (flash_info_t * info)
+{
+	printf ("flash_print_info not implemented\n");
+}
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	printf ("write_buff not implemented\n");
+	return (-1);
+}
diff --git a/board/qi_lb60/qi_lb60.c b/board/qi_lb60/qi_lb60.c
new file mode 100644
index 0000000..572d22b
--- /dev/null
+++ b/board/qi_lb60/qi_lb60.c
@@ -0,0 +1,103 @@
+/*
+ * Authors: Xiangfu Liu <xiangfu.z@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 3 of the License, or (at your option) any later version.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4740.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize NAND Flash Pins
+	 */
+	__gpio_as_nand();
+
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_32bit();
+
+	/*
+	 * Initialize UART0 pins
+	 */
+	__gpio_as_uart0();
+
+	/*
+	 * Initialize LCD pins
+	 */
+	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+	__gpio_as_i2c();
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize Other pins
+	 */
+	unsigned int i;
+	for (i = 0; i < 8; i++) {
+		__gpio_as_output(GPIO_KEYOUT_BASE + i);
+		__gpio_set_pin(GPIO_KEYOUT_BASE + i);
+	}
+
+	for (i = 0; i < 7; i++){
+		__gpio_as_input(GPIO_KEYIN_BASE + i);
+		__gpio_enable_pull(GPIO_KEYIN_BASE + i);
+	}
+	/* __gpio_as_input( GPIO_KEYIN_8 ); */
+	/* __gpio_enable_pull( GPIO_KEYIN_8 ); */
+
+	__gpio_as_output(GPIO_AUDIO_POP);
+	__gpio_set_pin(GPIO_AUDIO_POP);
+
+	__gpio_as_output(GPIO_LCD_CS);
+	__gpio_clear_pin(GPIO_LCD_CS);
+
+	__gpio_as_output(GPIO_AMP_EN);
+	__gpio_clear_pin(GPIO_AMP_EN);
+
+	__gpio_as_output(GPIO_SDPW_EN);
+	__gpio_disable_pull(GPIO_SDPW_EN);
+	__gpio_clear_pin(GPIO_SDPW_EN);
+
+	__gpio_as_input(GPIO_SD_DETECT);
+	__gpio_disable_pull(GPIO_SD_DETECT);
+
+	__gpio_as_input(GPIO_USB_DETECT);
+	__gpio_enable_pull(GPIO_USB_DETECT);
+}
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+/* U-Boot common routines */
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Qi LB60 (Ingenic XBurst Jz4740 SoC, Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff --git a/board/qi_lb60/u-boot-nand.lds b/board/qi_lb60/u-boot-nand.lds
new file mode 100644
index 0000000..a15a96e
--- /dev/null
+++ b/board/qi_lb60/u-boot-nand.lds
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/qi_lb60/u-boot.lds b/board/qi_lb60/u-boot.lds
new file mode 100644
index 0000000..a15a96e
--- /dev/null
+++ b/board/qi_lb60/u-boot.lds
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/cpu/mips/jz4740.c b/cpu/mips/jz4740.c
new file mode 100644
index 0000000..87e0ccf
--- /dev/null
+++ b/cpu/mips/jz4740.c
@@ -0,0 +1,574 @@
+/*
+ * Jz4740 common routines
+ *
+ *  Copyright (c) 2006
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_JZ4740
+#include <common.h>
+#include <command.h>
+#include <asm/jz4740.h>
+
+extern void board_early_init(void);
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 3, 3, 3, 3}; /* divisors of I:S:P:L:M */
+	int nf, pllout2;
+
+	cfcr = CPM_CPCCR_CLKOEN |
+		CPM_CPCCR_PCS |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? CONFIG_CPU_SPEED : (CONFIG_CPU_SPEED / 2);
+
+	/* Init USB Host clock, pllout2 must be n*48MHz */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+
+	nf = CONFIG_CPU_SPEED * 2 / CONFIG_EXTAL;
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(0 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void pll_add_test(int new_freq)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 4, 4, 4, 4}; /* divisors of I:S:P:M:L */
+	int nf, pllout2;
+
+	cfcr = CPM_CPCCR_CLKOEN |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? new_freq : (new_freq / 2);
+
+	/* Init UHC clock */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+	
+	/* nf = new_freq * 2 / CONFIG_EXTAL; */
+	nf = new_freq / 1000000; /* step length is 1M */
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(10 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void calc_clocks_add_test(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CONFIG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CONFIG_EXTAL;
+#endif
+}
+
+void sdram_add_test(int new_freq)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = new_freq;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / mem_clk;
+
+#if 0
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+#else
+	dmcr |= 0xfffc;
+#endif
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* everything is ok now */
+}
+
+void sdram_init(void)
+{
+	register unsigned int dmcr0, dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = CONFIG_CPU_SPEED;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	REG_EMC_BCR = 0;	/* Disable bus release */
+	REG_EMC_RTCSR = 0;	/* Disable clock for counting */
+
+	/* Fault DMCR value for mode register setting*/
+#define SDRAM_ROW0    11
+#define SDRAM_COL0     8
+#define SDRAM_BANK40   0
+
+	dmcr0 = ((SDRAM_ROW0-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL0-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK40<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Basic DMCR value */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg */
+	ns = 1000000000 / mem_clk;
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode value */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Stage 1. Precharge all banks by writing SDMR with DMCR.MRSET=0 */
+	REG_EMC_DMCR = dmcr;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* Wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 2. Enable auto-refresh */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH;
+
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCNT = 0;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* Wait for number of auto-refresh cycles */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+ 	/* Stage 3. Mode Register Set */
+	REG_EMC_DMCR = dmcr0 | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+        /* Set back to basic DMCR value */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* everything is ok now */
+}
+
+#ifndef CONFIG_NAND_SPL
+
+static void calc_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CONFIG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CONFIG_EXTAL;
+#endif
+}
+
+static void rtc_init(void)
+{
+	unsigned long rtcsta;
+
+	while ( !__rtc_write_ready()) ;
+	__rtc_enable_alarm();	/* enable alarm */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_RGR   = 0x00007fff; /* type value */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HWFCR = 0x0000ffe0; /* Power on delay 2s */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HRCR  = 0x00000fe0; /* reset delay 125ms */
+#if 0
+	while ( !__rtc_write_ready()) 
+		;
+	rtcsta = REG_RTC_HWRSR;
+	while ( !__rtc_write_ready()) 
+		;
+	if (rtcsta & 0x33) {
+		if (rtcsta & 0x10) {
+			while ( !__rtc_write_ready()) 
+				;
+			REG_RTC_RSR = 0x0;
+		}
+		while ( !__rtc_write_ready()) 
+			;
+		REG_RTC_HWRSR = 0x0;
+	}
+#endif
+}
+
+
+/*
+ * jz4740 board init routine 
+ */
+int jz_board_init(void)
+{
+	board_early_init();  /* init gpio, pll etc. */
+#ifndef CONFIG_NAND_U_BOOT
+#ifndef CONFIG_FPGA
+	pll_init();          /* init PLL */
+#endif
+	sdram_init();        /* init sdram memory */
+#endif
+	calc_clocks();       /* calc the clocks */
+#ifndef CONFIG_FPGA
+	rtc_init();		/* init rtc on any reset: */
+#endif
+	return 0;
+}
+
+/* U-Boot common routines */
+phys_size_t initdram(int board_type)
+{
+	u32 dmcr;
+	u32 rows, cols, dw, banks;
+	ulong size;
+
+	dmcr = REG_EMC_DMCR;
+	rows = 11 + ((dmcr & EMC_DMCR_RA_MASK) >> EMC_DMCR_RA_BIT);
+	cols = 8 + ((dmcr & EMC_DMCR_CA_MASK) >> EMC_DMCR_CA_BIT);
+	dw = (dmcr & EMC_DMCR_BW) ? 2 : 4;
+	banks = (dmcr & EMC_DMCR_BA) ? 4 : 2;
+
+	size = (1 << (rows + cols)) * dw * banks;
+
+	return size;
+}
+
+/*
+ * Timer routines 
+ */
+
+#define TIMER_CHAN  0
+#define TIMER_FDATA 0xffff  /* Timer full data value */
+#define TIMER_HZ    CONFIG_SYS_HZ
+
+#define READ_TIMER  REG_TCU_TCNT(TIMER_CHAN)  /* macro to read the 16 bit timer */
+
+static ulong timestamp;
+static ulong lastdec;
+
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	REG_TCU_TCSR(TIMER_CHAN) = TCU_TCSR_PRESCALE256 | TCU_TCSR_EXT_EN;
+	REG_TCU_TCNT(TIMER_CHAN) = 0;
+	REG_TCU_TDHR(TIMER_CHAN) = 0;
+	REG_TCU_TDFR(TIMER_CHAN) = TIMER_FDATA;
+
+	REG_TCU_TMSR = (1 << TIMER_CHAN) | (1 << (TIMER_CHAN + 16)); /* mask irqs */
+	REG_TCU_TSCR = (1 << TIMER_CHAN); /* enable timer clock */
+	REG_TCU_TESR = (1 << TIMER_CHAN); /* start counting up */
+
+	lastdec = 0;
+	timestamp = 0;
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo,tmp;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	}
+	else {
+		if (usec >= 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		}
+		else
+			tmo = 1;
+	}
+
+	/* check for rollover during this delay */
+	tmp = get_timer (0);
+	if ((tmp + tmo) < tmp )
+		reset_timer_masked();  /* timer would roll over */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked () < tmo);
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;
+	timestamp = 0;
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;
+
+	if (lastdec <= now) {
+		/* normal mode */
+		timestamp += (now - lastdec);
+	} else {
+		/* we have an overflow ... */
+		timestamp += TIMER_FDATA + now - lastdec;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	} else {
+		if (usec > 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		} else {
+			tmo = 1;
+		}
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return TIMER_HZ;
+}
+
+#endif /* CONFIG_NAND_SPL */
+
+/* End of timer routine. */
+
+#endif /* CONFIG_JZ4740 */
diff --git a/cpu/mips/jz4740_cpm_test.c b/cpu/mips/jz4740_cpm_test.c
new file mode 100644
index 0000000..70ebbf0
--- /dev/null
+++ b/cpu/mips/jz4740_cpm_test.c
@@ -0,0 +1,98 @@
+#include <config.h>
+
+#ifdef CONFIG_JZ4740
+#include <common.h>
+#include <command.h>
+#include <asm/jz4740.h>
+#include <asm/io.h>               /* virt_to_phys() */
+#define JZ4740_CPM_TEST
+
+
+
+int cpm_value;
+void mdelay(int dly)
+{
+	udelay(dly * 1000);
+}
+
+int myatoi(char *string)
+{
+    int res = 0;
+    while (*string>='0' && *string <='9')
+    {
+	res *= 10;
+	res += *string-'0';
+	string++;
+    }
+
+    return res;
+}
+
+int myhatoi(char *string)
+{
+    int res = 0;
+    
+    if ( *string != '0' || *(string+1) != 'x' ) {
+	    return 0;
+    }
+
+    string += 2;
+
+    while ( *string )
+    {
+	res *= 16;
+	if (*string>='0' && *string <='9')
+		res += *string-'0';
+	else if (*string>='a' && *string <='f')
+		res += *string-'a' + 10;
+	else 
+		return res;
+
+	string++;
+    }
+
+    return res;
+}
+
+int atoi( char * string )
+{
+    if ( *string == '0' && *(string+1) == 'x' ) {
+	    return myhatoi(string);
+    }
+    else 
+	    return myatoi(string);
+}
+
+void cpm_add_test(void)
+{
+	pll_add_test(cpm_value);
+	/* sdram_add_test(cpm_value); */
+	calc_clocks_add_test();
+}
+
+int do_jz_cpmtest_function(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+
+	if ( !strncmp(argv[1], "add", 3 ) ) {
+		if ( argc == 3 ) {
+			cpm_value = atoi( argv[2] );
+			printf("cpm value:%d\n",cpm_value);
+			if((cpm_value >= 999) || (cpm_value <= 100)) {
+				printf("param is wrong!\n");
+			}
+			cpm_value *= 1000000;
+			cpm_add_test();
+		}
+	} else {
+		printf("command is wrong!\n");
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	cpm,	4,	1,	do_jz_cpmtest_function,
+	"cpm:\t - Usage: cpmtest [add][cpm_value]\n",
+	NULL
+	);
+
+#endif /* CONFIG_JZ4740 */
diff --git a/cpu/mips/jz4740_nand.c b/cpu/mips/jz4740_nand.c
new file mode 100644
index 0000000..7b1cdf3
--- /dev/null
+++ b/cpu/mips/jz4740_nand.c
@@ -0,0 +1,198 @@
+/*
+ * Platform independend driver for JZ4740.
+ *
+ * Copyright (c) 2007 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <common.h>
+
+#if defined(CONFIG_CMD_NAND) && defined(CONFIG_JZ4740)
+
+#include <nand.h>
+#include <asm/jz4740.h>
+#include <asm/io.h>
+
+#define PAR_SIZE 9
+#define __nand_ecc_enable()    (REG_EMC_NFECR = EMC_NFECR_ECCE | EMC_NFECR_ERST )
+#define __nand_ecc_disable()   (REG_EMC_NFECR &= ~EMC_NFECR_ECCE)
+
+#define __nand_select_rs_ecc() (REG_EMC_NFECR |= EMC_NFECR_RS)
+
+#define __nand_rs_ecc_encoding()	(REG_EMC_NFECR |= EMC_NFECR_RS_ENCODING)
+#define __nand_rs_ecc_decoding()	(REG_EMC_NFECR |= EMC_NFECR_RS_DECODING)
+#define __nand_ecc_encode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_ENCF))
+#define __nand_ecc_decode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_DECF))
+
+static void jz_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned long nandaddr = (unsigned long)this->IO_ADDR_W;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		/* Change this to use I/O accessors. */
+		if (ctrl & NAND_NCE)
+			REG_EMC_NFCSR |= EMC_NFCSR_NFCE1; 
+		else
+			REG_EMC_NFCSR &= ~EMC_NFCSR_NFCE1;
+	}
+
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	if (ctrl & NAND_CLE)
+		nandaddr |= 0x00008000;
+	else /* must be ALE */
+		nandaddr |= 0x00010000;
+
+	writeb(cmd, (uint8_t *)nandaddr);
+}
+
+static int jz_device_ready(struct mtd_info *mtd)
+{
+	int ready;
+	udelay(20);	/* FIXME: add 20us delay */
+	ready = (REG_GPIO_PXPIN(2) & 0x40000000) ? 1 : 0;
+	return ready;
+}
+
+/*
+ * EMC setup
+ */
+static void jz_device_setup(void)
+{
+	/* Set NFE bit */
+	REG_EMC_NFCSR |= EMC_NFCSR_NFE1;
+	REG_EMC_SMCR1 = 0x094c4400;
+	/* REG_EMC_SMCR3 = 0x04444400; */
+}
+
+void board_nand_select_device(struct nand_chip *nand, int chip)
+{
+	/*
+	 * Don't use "chip" to address the NAND device,
+	 * generate the cs from the address where it is encoded.
+	 */
+}
+
+static int jzsoc_nand_calculate_rs_ecc(struct mtd_info* mtd, const u_char* dat,
+				u_char* ecc_code)
+{
+	volatile u8 *paraddr = (volatile u8 *)EMC_NFPAR0;
+	short i;
+
+	__nand_ecc_encode_sync() 
+	__nand_ecc_disable();
+	
+	for(i = 0; i < PAR_SIZE; i++) 
+		ecc_code[i] = *paraddr++;			
+	
+	return 0;
+}
+
+static void jzsoc_nand_enable_rs_hwecc(struct mtd_info* mtd, int mode)
+{
+ 	__nand_ecc_enable();
+	__nand_select_rs_ecc();
+
+	REG_EMC_NFINTS = 0x0;
+	if (NAND_ECC_READ == mode){
+		__nand_rs_ecc_decoding();
+	}
+	if (NAND_ECC_WRITE == mode){
+		__nand_rs_ecc_encoding();
+	}
+}	
+
+/* Correct 1~9-bit errors in 512-bytes data */
+static void jzsoc_rs_correct(unsigned char *dat, int idx, int mask)
+{
+	int i;
+
+	idx--;
+
+	i = idx + (idx >> 3);
+	if (i >= 512)
+		return;
+
+	mask <<= (idx & 0x7);
+
+	dat[i] ^= mask & 0xff;
+	if (i < 511)
+		dat[i+1] ^= (mask >> 8) & 0xff;
+}
+
+static int jzsoc_nand_rs_correct_data(struct mtd_info *mtd, u_char *dat,
+				 u_char *read_ecc, u_char *calc_ecc)					
+{
+	volatile u8 *paraddr = (volatile u8 *)EMC_NFPAR0;
+	short k;
+	u32 stat;
+	/* Set PAR values */
+	
+	for (k = 0; k < PAR_SIZE; k++) {
+		*paraddr++ = read_ecc[k];
+	}
+
+	/* Set PRDY */
+	REG_EMC_NFECR |= EMC_NFECR_PRDY;
+
+	/* Wait for completion */
+	__nand_ecc_decode_sync();
+	__nand_ecc_disable();
+
+	/* Check decoding */
+	stat = REG_EMC_NFINTS;
+	if (stat & EMC_NFINTS_ERR) {
+		if (stat & EMC_NFINTS_UNCOR) {
+			printk("Uncorrectable error occurred\n");
+			return -1;
+		}
+		else {
+			u32 errcnt = (stat & EMC_NFINTS_ERRCNT_MASK) >> EMC_NFINTS_ERRCNT_BIT;
+			switch (errcnt) {
+			case 4:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR3 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR3 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+			case 3:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR2 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR2 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+			case 2:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR1 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR1 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+			case 1:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR0 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR0 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+				return 0;
+			default:
+				break;
+	   		}
+		}
+	}
+	/* no error need to be correct */
+	return 0;
+}
+
+/*
+ * Main initialization routine
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	jz_device_setup();
+
+	nand->cmd_ctrl =  jz_hwcontrol;
+        nand->dev_ready = jz_device_ready;
+
+	/* FIXME: should use NAND_ECC_SOFT */
+        nand->ecc.hwctl = jzsoc_nand_enable_rs_hwecc;
+	nand->ecc.correct = jzsoc_nand_rs_correct_data;
+	nand->ecc.calculate = jzsoc_nand_calculate_rs_ecc;
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.size = 512;
+
+        /* 20 us command delay time */
+        nand->chip_delay = 20;
+
+	return 0;
+}
+#endif /* (CONFIG_SYS_CMD_NAND) */
diff --git a/cpu/mips/jz_cs8900.c b/cpu/mips/jz_cs8900.c
new file mode 100644
index 0000000..0ddd5ff
--- /dev/null
+++ b/cpu/mips/jz_cs8900.c
@@ -0,0 +1,397 @@
+/*
+ * Cirrus Logic CS8900A Ethernet
+ *
+ * (C) 2003 Wolfgang Denk, wd@denx.de
+ *     Extension to synchronize ethaddr environment variable
+ *     against value in EEPROM
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * Copyright (C) 1999 Ben Williamson <benw@pobox.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is loaded into SRAM in bootstrap mode, where it waits
+ * for commands on UART1 to read and write memory, jump to code etc.
+ * A design goal for this program is to be entirely independent of the
+ * target board.  Anything with a CL-PS7111 or EP7211 should be able to run
+ * this code in bootstrap mode.  All the board specifics can be handled on
+ * the host.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <config.h>
+#ifndef CONFIG_FPGA
+#if defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750)
+#include <common.h>
+#include <malloc.h>
+#if defined(CONFIG_JZ4740) 
+#include <asm/jz4740.h>
+#elif defined(CONFIG_JZ4750) 
+#include <asm/jz4750.h>
+#endif
+#include <net.h>
+struct eth_device *dev;
+#define CS8900_BASE ((u32)(dev->iobase))
+#define CONFIG_DRIVER_CS8900
+#define CS8900_BUS16
+#include <command.h>
+#include <asm/io.h>
+
+#include "jz_cs8900.h"
+
+#ifdef CONFIG_DRIVER_CS8900
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+
+#undef DEBUG
+
+/* packet page register access functions */
+
+#ifdef CS8900_BUS32
+/* we don't need 16 bit initialisation on 32 bit bus */
+#define get_reg_init_bus(x) get_reg((x))
+#else
+static unsigned short get_reg_init_bus (int regno)
+{
+	/* force 16 bit busmode */
+	volatile unsigned char c;
+	/* c = CS8900_BUS16_0; */
+	/* c = CS8900_BUS16_1; */
+	/* c = CS8900_BUS16_0; */
+	/* c = CS8900_BUS16_1; */
+	/* c = CS8900_BUS16_0; */
+
+	CS8900_PPTR = regno;
+	/* udelay(100); */
+	
+	return (unsigned short) CS8900_PDATA;
+}
+#endif
+
+static unsigned short get_reg (int regno)
+{
+	CS8900_PPTR = regno;
+	return (unsigned short) CS8900_PDATA;
+}
+
+
+static void put_reg (int regno, unsigned short val)
+{
+	CS8900_PPTR = regno;
+	CS8900_PDATA = val;
+}
+
+static void eth_reset (void)
+{
+	int tmo;
+	unsigned short us;
+
+	/* reset NIC */
+	put_reg (PP_SelfCTL, get_reg (PP_SelfCTL) | PP_SelfCTL_Reset);
+
+	/* wait for 200ms */
+	udelay (200000);
+	/* Wait until the chip is reset */
+
+	tmo = get_timer (0) + 1 * CONFIG_SYS_HZ;
+	while ((((us = get_reg_init_bus (PP_SelfSTAT)) & PP_SelfSTAT_InitD) == 0)
+		   && tmo < get_timer (0))
+		/*NOP*/;
+}
+
+static void eth_reginit (void)
+{
+	/* receive only error free packets addressed to this card */
+	put_reg (PP_RxCTL, PP_RxCTL_IA | PP_RxCTL_Broadcast | PP_RxCTL_RxOK);
+	/* do not generate any interrupts on receive operations */
+	put_reg (PP_RxCFG, 0);
+	/* do not generate any interrupts on transmit operations */
+	put_reg (PP_TxCFG, 0);
+	/* do not generate any interrupts on buffer operations */
+	put_reg (PP_BufCFG, 0);
+	/* enable transmitter/receiver mode */
+	put_reg (PP_LineCTL, PP_LineCTL_Rx | PP_LineCTL_Tx);
+}
+
+static void cs8900_get_enetaddr (uchar * addr)
+{
+	int i;
+	unsigned char env_enetaddr[6];
+	char *tmp = getenv ("ethaddr");
+	char *end;
+
+	for (i=0; i<6; i++) {
+		env_enetaddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
+		if (tmp)
+			tmp = (*end) ? end+1 : end;
+	}
+
+	/* verify chip id */
+	if (get_reg_init_bus (PP_ChipID) != 0x630e)
+		return;
+	eth_reset ();
+	if ((get_reg (PP_SelfST) & (PP_SelfSTAT_EEPROM | PP_SelfSTAT_EEPROM_OK)) ==
+			(PP_SelfSTAT_EEPROM | PP_SelfSTAT_EEPROM_OK)) {
+
+		/* Load the MAC from EEPROM */
+		for (i = 0; i < 6 / 2; i++) {
+			unsigned int Addr;
+
+			Addr = get_reg (PP_IA + i * 2);
+			addr[i * 2] = Addr & 0xFF;
+			addr[i * 2 + 1] = Addr >> 8;
+		}
+
+		if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6) != 0 &&
+		    memcmp(env_enetaddr, addr, 6) != 0) {
+			printf ("\nWarning: MAC addresses don't match:\n");
+			printf ("\tHW MAC address:  "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				addr[0], addr[1],
+				addr[2], addr[3],
+				addr[4], addr[5] );
+			printf ("\t\"ethaddr\" value: "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				env_enetaddr[0], env_enetaddr[1],
+				env_enetaddr[2], env_enetaddr[3],
+				env_enetaddr[4], env_enetaddr[5]) ;
+			debug ("### Set MAC addr from environment\n");
+			memcpy (addr, env_enetaddr, 6);
+		}
+		if (!tmp) {
+			char ethaddr[20];
+			sprintf (ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+				 addr[0], addr[1],
+				 addr[2], addr[3],
+				 addr[4], addr[5]) ;
+			debug ("### Set environment from HW MAC addr = \"%s\"\n",				ethaddr);
+			setenv ("ethaddr", ethaddr);
+		}
+
+	}
+}
+
+static void jz_eth_halt (struct eth_device *dev)
+{
+	/* disable transmitter/receiver mode */
+	put_reg (PP_LineCTL, 0);
+
+	/* "shutdown" to show ChipID or kernel wouldn't find he cs8900 ... */
+	get_reg_init_bus (PP_ChipID);
+}
+
+static int jz_eth_init (struct eth_device* dev, bd_t * bd)
+{
+    u16 id;
+	
+    dev = dev;
+   
+	
+    /* verify chip id */
+	id = get_reg_init_bus (PP_ChipID);
+	if (id != 0x630e) {
+		printf ("CS8900 jz_eth_init error!\n");
+		return 0;
+	}
+
+	eth_reset ();
+	/* set the ethernet address */
+	/* printf("MAC = %02x:%02x:%02x:%02x:%02x:%02x\r\n", */
+	/* 	   bd->bi_enetaddr[5],bd->bi_enetaddr[4], */
+	/* 	   bd->bi_enetaddr[3],bd->bi_enetaddr[2], */
+	/* 	   bd->bi_enetaddr[1],bd->bi_enetaddr[0]); */
+	
+	put_reg (PP_IA + 0, bd->bi_enetaddr[0] | (bd->bi_enetaddr[1] << 8));
+	put_reg (PP_IA + 2, bd->bi_enetaddr[2] | (bd->bi_enetaddr[3] << 8));
+	put_reg (PP_IA + 4, bd->bi_enetaddr[4] | (bd->bi_enetaddr[5] << 8));
+
+	eth_reginit ();
+	return 0;
+}
+
+/* Get a data block via Ethernet */
+static int jz_eth_rx (struct eth_device* dev)
+{
+	int i;
+	unsigned short rxlen;
+	unsigned short *addr;
+	unsigned short status;
+    dev = dev;
+	status = get_reg (PP_RER);
+
+	if ((status & PP_RER_RxOK) == 0)
+		return 0;
+
+	status = CS8900_RTDATA;		/* stat */
+	rxlen = CS8900_RTDATA;		/* len */
+
+#ifdef DEBUG
+	if (rxlen > PKTSIZE_ALIGN + PKTALIGN)
+		printf ("packet too big!\n");
+#endif
+	for (addr = (unsigned short *) NetRxPackets[0], i = rxlen >> 1; i > 0;
+		 i--)
+		*addr++ = CS8900_RTDATA;
+	if (rxlen & 1)
+		*addr++ = CS8900_RTDATA;
+
+	/* Pass the packet up to the protocol layers. */
+	NetReceive (NetRxPackets[0], rxlen);
+
+	return rxlen;
+}
+
+/* Send a data block via Ethernet. */
+static int jz_eth_send (struct eth_device* dev,volatile void *packet, int length)
+{
+	volatile unsigned short *addr;
+	int tmo;
+	unsigned short s;
+    dev = dev;
+	
+retry:
+	/* initiate a transmit sequence */
+	CS8900_TxCMD = PP_TxCmd_TxStart_Full;
+	CS8900_TxLEN = length;
+
+	/* Test to see if the chip has allocated memory for the packet */
+	if ((get_reg (PP_BusSTAT) & PP_BusSTAT_TxRDY) == 0) {
+		/* Oops... this should not happen! */
+#ifdef DEBUG
+		printf ("cs: unable to send packet; retrying...\n");
+#endif
+		for (tmo = get_timer (0) + 5 * CONFIG_SYS_HZ; get_timer (0) < tmo;)
+			/*NOP*/;
+		eth_reset ();
+		eth_reginit ();
+		goto retry;
+	}
+
+	/* Write the contents of the packet */
+	/* assume even number of bytes */
+	for (addr = packet; length > 0; length -= 2)
+		CS8900_RTDATA = *addr++;
+
+	/* wait for transfer to succeed */
+	tmo = get_timer (0) + 5 * CONFIG_SYS_HZ;
+	while ((s = get_reg (PP_TER) & ~0x1F) == 0) {
+		if (get_timer (0) >= tmo)
+			break;
+	}
+
+	/* nothing */ ;
+	if ((s & (PP_TER_CRS | PP_TER_TxOK)) != PP_TER_TxOK) {
+#ifdef DEBUG
+		printf ("\ntransmission error %#x\n", s);
+#endif
+	}
+
+	return 0;
+}
+
+static void cs8900_e2prom_ready(void)
+{
+	while(get_reg(PP_SelfST) & SI_BUSY);
+}
+
+/***********************************************************/
+/* read a 16-bit word out of the EEPROM                    */
+/***********************************************************/
+
+static int cs8900_e2prom_read(unsigned char addr, unsigned short *value)
+{
+	cs8900_e2prom_ready();
+	put_reg(PP_EECMD, EEPROM_READ_CMD | addr);
+	cs8900_e2prom_ready();
+	*value = get_reg(PP_EEData);
+
+	return 0;
+}
+
+
+/***********************************************************/
+/* write a 16-bit word into the EEPROM                     */
+/***********************************************************/
+
+static int cs8900_e2prom_write(unsigned char addr, unsigned short value)
+{
+	cs8900_e2prom_ready();
+	put_reg(PP_EECMD, EEPROM_WRITE_EN);
+	cs8900_e2prom_ready();
+	put_reg(PP_EEData, value);
+	put_reg(PP_EECMD, EEPROM_WRITE_CMD | addr);
+	cs8900_e2prom_ready();
+	put_reg(PP_EECMD, EEPROM_WRITE_DIS);
+	cs8900_e2prom_ready();
+
+	return 0;
+}
+int jz_enet_initialize(bd_t *bis)
+{
+	
+    u32 reg;
+	
+	dev = (struct eth_device *) malloc(sizeof *dev);
+	memset(dev, 0, sizeof *dev);
+
+#if defined(CONFIG_JZ4740)
+#define RD_N_PIN (32 + 29)
+#define WE_N_PIN (32 + 30)
+#define CS4_PIN (32 + 28)
+	__gpio_as_func0(CS4_PIN);
+	__gpio_as_func0(RD_N_PIN);
+	__gpio_as_func0(WE_N_PIN);
+
+	reg = REG_EMC_SMCR4;
+	reg = (reg & (~EMC_SMCR_BW_MASK)) | EMC_SMCR_BW_16BIT;
+	REG_EMC_SMCR4 = reg;
+	dev->iobase = 0xa8000000;
+
+#elif defined(CONFIG_JZ4750)
+#define RD_N_PIN (32*2 +25)
+#define WE_N_PIN (32*2 +26)
+#define CS3_PIN (32*2 +23)
+	__gpio_as_func0(CS3_PIN);
+	__gpio_as_func0(RD_N_PIN);
+	__gpio_as_func0(WE_N_PIN);
+
+	reg = REG_EMC_SMCR3;
+	reg = (reg & (~EMC_SMCR_BW_MASK)) | EMC_SMCR_BW_16BIT;
+	REG_EMC_SMCR3 = reg;
+	dev->iobase = 0xac000000;
+#endif
+
+	sprintf(dev->name, "JZ ETHERNET");
+	dev->priv   = 0;
+	dev->init   = jz_eth_init;
+	dev->halt   = jz_eth_halt;
+	dev->send   = jz_eth_send;
+	dev->recv   = jz_eth_rx;
+
+	eth_register(dev);
+	
+	return 1;
+}
+
+
+#endif	/* COMMANDS & CFG_NET */
+
+#endif	/* CONFIG_DRIVER_CS8900 */
+#endif  /* defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750) */
+#endif  /* !CONFIG_FPGA */
diff --git a/cpu/mips/jz_cs8900.h b/cpu/mips/jz_cs8900.h
new file mode 100644
index 0000000..5f6fdec
--- /dev/null
+++ b/cpu/mips/jz_cs8900.h
@@ -0,0 +1,258 @@
+/*
+ * Cirrus Logic CS8900A Ethernet
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * Copyright (C) 1999 Ben Williamson <benw@pobox.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is loaded into SRAM in bootstrap mode, where it waits
+ * for commands on UART1 to read and write memory, jump to code etc.
+ * A design goal for this program is to be entirely independent of the
+ * target board.  Anything with a CL-PS7111 or EP7211 should be able to run
+ * this code in bootstrap mode.  All the board specifics can be handled on
+ * the host.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <asm/types.h>
+#include <config.h>
+
+#ifdef CONFIG_DRIVER_CS8900
+
+/* although the registers are 16 bit, they are 32-bit aligned on the
+   EDB7111. so we have to read them as 32-bit registers and ignore the
+   upper 16-bits. i'm not sure if this holds for the EDB7211. */
+
+#ifdef CS8900_BUS16
+  /* 16 bit aligned registers, 16 bit wide */
+  #define CS8900_REG u16
+  #define CS8900_OFF 0x02
+  #define CS8900_BUS16_0  *(volatile u8 *)(CS8900_BASE+0x00)
+  #define CS8900_BUS16_1  *(volatile u8 *)(CS8900_BASE+0x01)
+#elif  defined(CS8900_BUS32)
+  /* 32 bit aligned registers, 16 bit wide (we ignore upper 16 bits) */
+  #define CS8900_REG u32
+  #define CS8900_OFF 0x04
+#else
+  #error unknown bussize ...
+#endif
+
+#define CS8900_RTDATA *(volatile CS8900_REG *)(CS8900_BASE+0x00*CS8900_OFF)
+#define CS8900_TxCMD  *(volatile CS8900_REG *)(CS8900_BASE+0x02*CS8900_OFF)
+#define CS8900_TxLEN  *(volatile CS8900_REG *)(CS8900_BASE+0x03*CS8900_OFF)
+#define CS8900_ISQ    *(volatile CS8900_REG *)(CS8900_BASE+0x04*CS8900_OFF)
+#define CS8900_PPTR   *(volatile CS8900_REG *)(CS8900_BASE+0x05*CS8900_OFF)
+#define CS8900_PDATA  *(volatile CS8900_REG *)(CS8900_BASE+0x06*CS8900_OFF)
+
+
+#define ISQ_RxEvent     0x04
+#define ISQ_TxEvent     0x08
+#define ISQ_BufEvent    0x0C
+#define ISQ_RxMissEvent 0x10
+#define ISQ_TxColEvent  0x12
+#define ISQ_EventMask   0x3F
+
+/* packet page register offsets */
+
+/* bus interface registers */
+#define PP_ChipID    0x0000  /* Chip identifier - must be 0x630E */
+#define PP_ChipRev   0x0002  /* Chip revision, model codes */
+
+#define PP_IntReg    0x0022  /* Interrupt configuration */
+#define PP_IntReg_IRQ0         0x0000  /* Use INTR0 pin */
+#define PP_IntReg_IRQ1         0x0001  /* Use INTR1 pin */
+#define PP_IntReg_IRQ2         0x0002  /* Use INTR2 pin */
+#define PP_IntReg_IRQ3         0x0003  /* Use INTR3 pin */
+
+/* status and control registers */
+
+#define PP_RxCFG     0x0102  /* Receiver configuration */
+#define PP_RxCFG_Skip1         0x0040  /* Skip (i.e. discard) current frame */
+#define PP_RxCFG_Stream        0x0080  /* Enable streaming mode */
+#define PP_RxCFG_RxOK          0x0100  /* RxOK interrupt enable */
+#define PP_RxCFG_RxDMAonly     0x0200  /* Use RxDMA for all frames */
+#define PP_RxCFG_AutoRxDMA     0x0400  /* Select RxDMA automatically */
+#define PP_RxCFG_BufferCRC     0x0800  /* Include CRC characters in frame */
+#define PP_RxCFG_CRC           0x1000  /* Enable interrupt on CRC error */
+#define PP_RxCFG_RUNT          0x2000  /* Enable interrupt on RUNT frames */
+#define PP_RxCFG_EXTRA         0x4000  /* Enable interrupt on frames with extra data */
+
+#define PP_RxCTL     0x0104  /* Receiver control */
+#define PP_RxCTL_IAHash        0x0040  /* Accept frames that match hash */
+#define PP_RxCTL_Promiscuous   0x0080  /* Accept any frame */
+#define PP_RxCTL_RxOK          0x0100  /* Accept well formed frames */
+#define PP_RxCTL_Multicast     0x0200  /* Accept multicast frames */
+#define PP_RxCTL_IA            0x0400  /* Accept frame that matches IA */
+#define PP_RxCTL_Broadcast     0x0800  /* Accept broadcast frames */
+#define PP_RxCTL_CRC           0x1000  /* Accept frames with bad CRC */
+#define PP_RxCTL_RUNT          0x2000  /* Accept runt frames */
+#define PP_RxCTL_EXTRA         0x4000  /* Accept frames that are too long */
+
+#define PP_TxCFG     0x0106  /* Transmit configuration */
+#define PP_TxCFG_CRS           0x0040  /* Enable interrupt on loss of carrier */
+#define PP_TxCFG_SQE           0x0080  /* Enable interrupt on Signal Quality Error */
+#define PP_TxCFG_TxOK          0x0100  /* Enable interrupt on successful xmits */
+#define PP_TxCFG_Late          0x0200  /* Enable interrupt on "out of window" */
+#define PP_TxCFG_Jabber        0x0400  /* Enable interrupt on jabber detect */
+#define PP_TxCFG_Collision     0x0800  /* Enable interrupt if collision */
+#define PP_TxCFG_16Collisions  0x8000  /* Enable interrupt if > 16 collisions */
+
+#define PP_TxCmd     0x0108  /* Transmit command status */
+#define PP_TxCmd_TxStart_5     0x0000  /* Start after 5 bytes in buffer */
+#define PP_TxCmd_TxStart_381   0x0040  /* Start after 381 bytes in buffer */
+#define PP_TxCmd_TxStart_1021  0x0080  /* Start after 1021 bytes in buffer */
+#define PP_TxCmd_TxStart_Full  0x00C0  /* Start after all bytes loaded */
+#define PP_TxCmd_Force         0x0100  /* Discard any pending packets */
+#define PP_TxCmd_OneCollision  0x0200  /* Abort after a single collision */
+#define PP_TxCmd_NoCRC         0x1000  /* Do not add CRC */
+#define PP_TxCmd_NoPad         0x2000  /* Do not pad short packets */
+
+#define PP_BufCFG    0x010A  /* Buffer configuration */
+#define PP_BufCFG_SWI          0x0040  /* Force interrupt via software */
+#define PP_BufCFG_RxDMA        0x0080  /* Enable interrupt on Rx DMA */
+#define PP_BufCFG_TxRDY        0x0100  /* Enable interrupt when ready for Tx */
+#define PP_BufCFG_TxUE         0x0200  /* Enable interrupt in Tx underrun */
+#define PP_BufCFG_RxMiss       0x0400  /* Enable interrupt on missed Rx packets */
+#define PP_BufCFG_Rx128        0x0800  /* Enable Rx interrupt after 128 bytes */
+#define PP_BufCFG_TxCol        0x1000  /* Enable int on Tx collision ctr overflow */
+#define PP_BufCFG_Miss         0x2000  /* Enable int on Rx miss ctr overflow */
+#define PP_BufCFG_RxDest       0x8000  /* Enable int on Rx dest addr match */
+
+#define PP_LineCTL   0x0112  /* Line control */
+#define PP_LineCTL_Rx          0x0040  /* Enable receiver */
+#define PP_LineCTL_Tx          0x0080  /* Enable transmitter */
+#define PP_LineCTL_AUIonly     0x0100  /* AUI interface only */
+#define PP_LineCTL_AutoAUI10BT 0x0200  /* Autodetect AUI or 10BaseT interface */
+#define PP_LineCTL_ModBackoffE 0x0800  /* Enable modified backoff algorithm */
+#define PP_LineCTL_PolarityDis 0x1000  /* Disable Rx polarity autodetect */
+#define PP_LineCTL_2partDefDis 0x2000  /* Disable two-part defferal */
+#define PP_LineCTL_LoRxSquelch 0x4000  /* Reduce receiver squelch threshold */
+
+#define PP_SelfCTL   0x0114  /* Chip self control */
+#define PP_SelfCTL_Reset       0x0040  /* Self-clearing reset */
+#define PP_SelfCTL_SWSuspend   0x0100  /* Initiate suspend mode */
+#define PP_SelfCTL_HWSleepE    0x0200  /* Enable SLEEP input */
+#define PP_SelfCTL_HWStandbyE  0x0400  /* Enable standby mode */
+#define PP_SelfCTL_HC0E        0x1000  /* use HCB0 for LINK LED */
+#define PP_SelfCTL_HC1E        0x2000  /* use HCB1 for BSTATUS LED */
+#define PP_SelfCTL_HCB0        0x4000  /* control LINK LED if HC0E set */
+#define PP_SelfCTL_HCB1        0x8000  /* control BSTATUS LED if HC1E set */
+
+#define PP_BusCTL    0x0116  /* Bus control */
+#define PP_BusCTL_ResetRxDMA   0x0040  /* Reset RxDMA pointer */
+#define PP_BusCTL_DMAextend    0x0100  /* Extend DMA cycle */
+#define PP_BusCTL_UseSA        0x0200  /* Assert MEMCS16 on address decode */
+#define PP_BusCTL_MemoryE      0x0400  /* Enable memory mode */
+#define PP_BusCTL_DMAburst     0x0800  /* Limit DMA access burst */
+#define PP_BusCTL_IOCHRDYE     0x1000  /* Set IOCHRDY high impedence */
+#define PP_BusCTL_RxDMAsize    0x2000  /* Set DMA buffer size 64KB */
+#define PP_BusCTL_EnableIRQ    0x8000  /* Generate interrupt on interrupt event */
+
+#define PP_TestCTL   0x0118  /* Test control */
+#define PP_TestCTL_DisableLT   0x0080  /* Disable link status */
+#define PP_TestCTL_ENDECloop   0x0200  /* Internal loopback */
+#define PP_TestCTL_AUIloop     0x0400  /* AUI loopback */
+#define PP_TestCTL_DisBackoff  0x0800  /* Disable backoff algorithm */
+#define PP_TestCTL_FDX         0x4000  /* Enable full duplex mode */
+
+#define PP_ISQ       0x0120  /* Interrupt Status Queue */
+
+#define PP_RER       0x0124  /* Receive event */
+#define PP_RER_IAHash          0x0040  /* Frame hash match */
+#define PP_RER_Dribble         0x0080  /* Frame had 1-7 extra bits after last byte */
+#define PP_RER_RxOK            0x0100  /* Frame received with no errors */
+#define PP_RER_Hashed          0x0200  /* Frame address hashed OK */
+#define PP_RER_IA              0x0400  /* Frame address matched IA */
+#define PP_RER_Broadcast       0x0800  /* Broadcast frame */
+#define PP_RER_CRC             0x1000  /* Frame had CRC error */
+#define PP_RER_RUNT            0x2000  /* Runt frame */
+#define PP_RER_EXTRA           0x4000  /* Frame was too long */
+
+#define PP_TER       0x0128 /* Transmit event */
+#define PP_TER_CRS             0x0040  /* Carrier lost */
+#define PP_TER_SQE             0x0080  /* Signal Quality Error */
+#define PP_TER_TxOK            0x0100  /* Packet sent without error */
+#define PP_TER_Late            0x0200  /* Out of window */
+#define PP_TER_Jabber          0x0400  /* Stuck transmit? */
+#define PP_TER_NumCollisions   0x7800  /* Number of collisions */
+#define PP_TER_16Collisions    0x8000  /* > 16 collisions */
+
+#define PP_BER       0x012C /* Buffer event */
+#define PP_BER_SWint           0x0040 /* Software interrupt */
+#define PP_BER_RxDMAFrame      0x0080 /* Received framed DMAed */
+#define PP_BER_Rdy4Tx          0x0100 /* Ready for transmission */
+#define PP_BER_TxUnderrun      0x0200 /* Transmit underrun */
+#define PP_BER_RxMiss          0x0400 /* Received frame missed */
+#define PP_BER_Rx128           0x0800 /* 128 bytes received */
+#define PP_BER_RxDest          0x8000 /* Received framed passed address filter */
+
+#define PP_RxMiss    0x0130  /*  Receiver miss counter */
+
+#define PP_TxCol     0x0132  /*  Transmit collision counter */
+
+#define PP_LineSTAT  0x0134  /* Line status */
+#define PP_LineSTAT_LinkOK     0x0080  /* Line is connected and working */
+#define PP_LineSTAT_AUI        0x0100  /* Connected via AUI */
+#define PP_LineSTAT_10BT       0x0200  /* Connected via twisted pair */
+#define PP_LineSTAT_Polarity   0x1000  /* Line polarity OK (10BT only) */
+#define PP_LineSTAT_CRS        0x4000  /* Frame being received */
+
+#define PP_SelfSTAT  0x0136  /* Chip self status */
+#define PP_SelfSTAT_33VActive  0x0040  /* supply voltage is 3.3V */
+#define PP_SelfSTAT_InitD      0x0080  /* Chip initialization complete */
+#define PP_SelfSTAT_SIBSY      0x0100  /* EEPROM is busy */
+#define PP_SelfSTAT_EEPROM     0x0200  /* EEPROM present */
+#define PP_SelfSTAT_EEPROM_OK  0x0400  /* EEPROM checks out */
+#define PP_SelfSTAT_ELPresent  0x0800  /* External address latch logic available */
+#define PP_SelfSTAT_EEsize     0x1000  /* Size of EEPROM */
+
+#define PP_BusSTAT   0x0138  /* Bus status */
+#define PP_BusSTAT_TxBid       0x0080  /* Tx error */
+#define PP_BusSTAT_TxRDY       0x0100  /* Ready for Tx data */
+
+#define PP_TDR       0x013C  /* AUI Time Domain Reflectometer */
+
+/* initiate transmit registers */
+
+#define PP_TxCommand 0x0144  /* Tx Command */
+#define PP_TxLength  0x0146  /* Tx Length */
+
+
+/* address filter registers */
+
+#define PP_LAF       0x0150  /* Logical address filter (6 bytes) */
+#define PP_IA        0x0158  /* Individual address (MAC) */
+
+/* EEPROM Kram */
+#define SI_BUSY 0x0100
+#define PP_SelfST 0x0136	/*  Self State register */
+#define PP_EECMD 0x0040		/*  NVR Interface Command register */
+#define PP_EEData 0x0042	/*  NVR Interface Data Register */
+#define EEPROM_WRITE_EN		0x00F0
+#define EEPROM_WRITE_DIS	0x0000
+#define EEPROM_WRITE_CMD	0x0100
+#define EEPROM_READ_CMD		0x0200
+#define EEPROM_ERASE_CMD	0x0300
+
+static int cs8900_e2prom_read(uchar, ushort *);
+static int cs8900_e2prom_write(uchar, ushort);
+
+#endif /* CONFIG_DRIVER_CS8900 */
diff --git a/cpu/mips/jz_eth.c b/cpu/mips/jz_eth.c
new file mode 100644
index 0000000..1ef2516
--- /dev/null
+++ b/cpu/mips/jz_eth.c
@@ -0,0 +1,376 @@
+/* Jz ethernet support
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ5730) || defined(CONFIG_FPGA)
+
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+#if defined(CONFIG_JZ4750D)
+#include <asm/jz4750d.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#include "jz_eth.h"
+
+#define MAX_WAIT 1000
+
+/* Tx and Rx Descriptor */
+typedef struct {
+	u32 status;
+	u32 ctrl;
+	u32 addr;
+	u32 next;
+} eth_desc_t;
+
+#define NUM_RX_DESCS 16
+#define NUM_TX_DESCS 4
+
+static eth_desc_t rx_desc[NUM_RX_DESCS];
+static eth_desc_t tx_desc[NUM_TX_DESCS];
+
+static int next_rx;
+static int next_tx;
+
+static u32 full_duplex, phy_mode;
+
+static inline void reset_eth(void)
+{
+    int i;
+
+    jz_writel(ETH_BMR, jz_readl(ETH_BMR) | BMR_SWR);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+         if(!(jz_readl(ETH_BMR) & BMR_SWR))
+	     break;
+         udelay(1);
+    }
+
+    if (i == MAX_WAIT)
+	printf("Reset eth timeout\n");
+}
+
+static inline void enable_eth(void)
+{
+	jz_writel(ETH_OMR, jz_readl(ETH_OMR) | OMR_ST | OMR_SR);
+}
+	
+static inline void disable_eth(void)
+{
+	jz_writel(ETH_OMR, jz_readl(ETH_OMR) & ~(OMR_ST | OMR_SR));
+}
+
+#define MII_CMD_ADDR(id, offset) (((id) << 11) | ((offset) << 6))
+#define MII_CMD_READ(id, offset) (MII_CMD_ADDR(id, offset))
+#define MII_CMD_WRITE(id, offset) (MII_CMD_ADDR(id, offset) | 0x2)
+
+static u32 mii_read(int phy_id, int offset)
+{
+	int i;
+	u32 mii_cmd = MII_CMD_READ(phy_id, offset);
+
+	jz_writel(ETH_MIAR, mii_cmd);
+
+	/* wait for completion */
+	for (i = 0; i < MAX_WAIT; i++) {
+		if (!(jz_readl(ETH_MIAR) & 0x1))
+			break;
+		udelay(1);
+	}
+
+	if (i == MAX_WAIT) {
+		printf("MII wait timeout\n");
+		return 0;
+	}
+
+	return jz_readl(ETH_MIDR) & 0x0000ffff;
+}
+
+static int autonet_complete(int phy_id)
+{
+	int i;
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		if (mii_read(phy_id, MII_SR) & 0x0020) 
+			break;  /* auto negotiation completed */
+		udelay(500);
+	}
+
+	if (i == MAX_WAIT)
+		return -1;     /* auto negotiation  error */
+	else
+		return 0;
+}
+
+static int search_phy(int phy_id)
+{
+	unsigned int r;
+	r = mii_read(phy_id, 1);
+	if (r!=0 && r!=0xffff)
+		return 1;
+	return 0;
+}
+
+static void config_phy(int phy_id)
+{
+	u32 mii_reg5;
+
+	full_duplex = 0;
+
+	mii_reg5 = mii_read(phy_id, MII_ANLPA);
+
+	if (mii_reg5 != 0xffff) {
+		mii_reg5 = mii_read(phy_id, MII_ANLPA);
+		if ((mii_reg5 & 0x0100) || (mii_reg5 & 0x01C0) == 0x0040)
+			full_duplex = 1;
+
+		phy_mode = mii_reg5 >> 5;
+
+		printf("ETH: setting %s %s-duplex based on MII tranceiver #%d\n",
+		       (phy_mode & MII_ANLPA_100M) ? "100Mbps" : "10Mbps",
+		       full_duplex ? "full" : "half", phy_id);
+	}
+}
+
+static void config_mac(void)
+{
+	u32 omr, mcr;
+
+	/* Set MAC address */
+#define ea eth_get_dev()->enetaddr
+	jz_writel(ETH_MALR, (ea[3] << 24) | (ea[2] << 16) | (ea[1] <<  8) | ea[0]);
+	jz_writel(ETH_MAHR, (ea[5] <<  8) | ea[4]);
+
+	jz_writel(ETH_HTLR, 0);
+	jz_writel(ETH_HTHR, 0);
+
+	/* Assert the MCR_PS bit in CSR */
+	if (phy_mode & MII_ANLPA_100M)
+		omr = OMR_SF;
+	else
+		omr = OMR_TTM | OMR_SF;
+
+	mcr = MCR_TE | MCR_RE | MCR_DBF | MCR_LCC; 
+    
+	if (full_duplex)
+		mcr |= MCR_FDX;
+
+	/* Set the Operation Mode (OMR) and Mac Control (MCR) registers */
+	jz_writel(ETH_OMR, omr);
+	jz_writel(ETH_MCR, mcr);
+
+	/* Set the Programmable Burst Length (BMR.PBL, value 1 or 4 is validate) */
+	jz_writel(ETH_BMR, DMA_BURST << 8);
+
+	/* Reset csr8 */
+	jz_readl(ETH_MFCR); /*  missed frams counter */
+}
+
+/*---------------------------------------------------------------------------
+ * ETH interface routines
+ *--------------------------------------------------------------------------*/
+
+static int jz_send(struct eth_device* dev, volatile void *packet, int length)
+{
+	volatile eth_desc_t *desc = 
+		(volatile eth_desc_t *)((unsigned int)(tx_desc + next_tx) | 0xa0000000);
+	int i;
+
+	/* tx fifo should always be idle */
+	desc->addr = virt_to_phys(packet);
+	desc->ctrl |= TD_LS | TD_FS | length;
+	desc->status = T_OWN;
+
+	jz_flush_dcache();
+	jz_sync();
+
+	/* Start the tx */
+	jz_writel(ETH_TPDR, 1);
+
+	i = 0;
+	while (desc->status & T_OWN) {
+		if(i > MAX_WAIT) {
+			printf("ETH TX timeout\n");
+			break;
+		}
+		udelay(1);
+		i++;
+	}
+
+	/* Clear done bits */
+	jz_writel(ETH_SR,  DMA_TX_DEFAULT);
+
+	desc->status = 0;
+	desc->addr = 0;
+	desc->ctrl &= ~(TD_LS | TD_FS);
+
+	next_tx++;
+	if (next_tx >= NUM_TX_DESCS){
+		next_tx=0;
+	}
+
+	return (desc->status);
+}
+
+static int jz_recv(struct eth_device* dev)
+{
+	volatile eth_desc_t *desc;
+	int length;
+	u32 status;
+
+	for(;;) {
+		desc = (volatile eth_desc_t *)((unsigned int)(rx_desc + next_rx) | 0xa0000000);
+
+		status = desc->status;
+
+		if (status & R_OWN) {
+			/* Nothing has been received */
+			return(-1);
+		}
+
+		length = ((status & RD_FL) >> 16); /* with 4-byte CRC value */
+
+		if (status & RD_ES) {
+			printf("ETH RX error 0x%x\n", status);
+		}
+		else {
+			/* Pass the packet up to the protocol layers. */
+			NetReceive(NetRxPackets[next_rx], length - 4);
+		}
+
+		/* Clear done bits */
+		jz_writel(ETH_SR,  DMA_RX_DEFAULT);
+
+		desc->status = R_OWN;
+
+		jz_flush_dcache();
+		jz_sync();
+
+		next_rx++;
+		if (next_rx >= NUM_RX_DESCS) {
+			next_rx = 0;
+		}
+	} /* for */
+
+	return(0); /* Does anyone use this? */
+}
+
+static int jz_init(struct eth_device* dev, bd_t * bd)
+{
+	int i, phyid = -1;
+
+	/* Reset ethernet unit */
+	reset_eth();
+
+	/* Disable interrupts: we don't use ethernet interrupts */
+	jz_writel(ETH_IER, 0);
+
+	for (i=0;i<32;i++)
+		if (search_phy(i)) {
+			phyid = i;
+			break;
+		}
+
+	if (phyid == -1)
+		printf("Can't locate any PHY\n");
+
+	/* Start Auto Negotiation of PHY 0 and check it */
+	if (autonet_complete(phyid))
+		printf("ETH Auto-Negotiation failed\n");
+
+	/* Configure PHY */
+	config_phy(phyid);
+
+	/* Configure MAC */
+	config_mac();
+
+	/* Setup the Rx&Tx descriptors */
+	for (i = 0; i < NUM_RX_DESCS; i++) {
+		rx_desc[i].status  = R_OWN;
+		rx_desc[i].ctrl    = PKTSIZE_ALIGN | RD_RCH;
+		rx_desc[i].addr    = virt_to_phys(NetRxPackets[i]);
+		rx_desc[i].next    = virt_to_phys(rx_desc + i + 1);
+	}
+	rx_desc[NUM_RX_DESCS - 1].next = virt_to_phys(rx_desc); /*  The last links to the first	 */
+	rx_desc[NUM_RX_DESCS - 1].ctrl |= RD_RER;  /*  Set the Receive End Of Ring flag */
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		tx_desc[i].status  = 0;
+		tx_desc[i].ctrl    = TD_TCH;
+		tx_desc[i].addr    = 0;
+		tx_desc[i].next    = virt_to_phys(tx_desc + i + 1);
+	}
+	tx_desc[NUM_TX_DESCS - 1].next = virt_to_phys(tx_desc); /*  The last links to the first */
+	tx_desc[NUM_TX_DESCS - 1].ctrl |= TD_TER;  /*  Set the Transmit End Of Ring flag */
+
+	jz_flush_dcache();
+
+	jz_writel(ETH_RAR, virt_to_phys(rx_desc));
+	jz_writel(ETH_TAR, virt_to_phys(tx_desc));
+
+	next_rx = next_tx = 0;
+
+	/* Enable ETH */
+	enable_eth();
+
+	return (1);
+}
+
+static void jz_halt(struct eth_device *dev)
+{
+	disable_eth();
+}
+
+int jz_enet_initialize(bd_t *bis)
+{
+	struct eth_device *dev;
+
+	dev = (struct eth_device *) malloc(sizeof *dev);
+	memset(dev, 0, sizeof *dev);
+
+	sprintf(dev->name, "JZ ETHERNET");
+	dev->iobase = 0;
+	dev->priv   = 0;
+	dev->init   = jz_init;
+	dev->halt   = jz_halt;
+	dev->send   = jz_send;
+	dev->recv   = jz_recv;
+
+	eth_register(dev);
+
+	return 1;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ5730 */
diff --git a/cpu/mips/jz_eth.h b/cpu/mips/jz_eth.h
new file mode 100644
index 0000000..8a235eb
--- /dev/null
+++ b/cpu/mips/jz_eth.h
@@ -0,0 +1,267 @@
+#ifndef __JZ_ETH_H__
+#define __JZ_ETH_H__
+
+#define ETH_BASE	0xB3100000
+
+#define ETH_BMR		(ETH_BASE + 0x1000)
+#define ETH_TPDR	(ETH_BASE + 0x1004)
+#define ETH_RPDR	(ETH_BASE + 0x1008)
+#define ETH_RAR		(ETH_BASE + 0x100C)
+#define ETH_TAR		(ETH_BASE + 0x1010)
+#define ETH_SR		(ETH_BASE + 0x1014)
+#define ETH_OMR		(ETH_BASE + 0x1018)
+#define ETH_IER		(ETH_BASE + 0x101C)
+#define ETH_MFCR	(ETH_BASE + 0x1020)
+#define ETH_CTAR	(ETH_BASE + 0x1050)
+#define ETH_CRAR	(ETH_BASE + 0x1054)
+#define ETH_MCR		(ETH_BASE + 0x0000)
+#define ETH_MAHR	(ETH_BASE + 0x0004)
+#define ETH_MALR	(ETH_BASE + 0x0008)
+#define ETH_HTHR	(ETH_BASE + 0x000C)
+#define ETH_HTLR	(ETH_BASE + 0x0010)
+#define ETH_MIAR	(ETH_BASE + 0x0014)
+#define ETH_MIDR	(ETH_BASE + 0x0018)
+#define ETH_FCR		(ETH_BASE + 0x001C)
+#define ETH_VTR1	(ETH_BASE + 0x0020)
+#define ETH_VTR2	(ETH_BASE + 0x0024)
+#define ETH_WKFR	(ETH_BASE + 0x0028)
+#define ETH_PMTR	(ETH_BASE + 0x002C)
+
+/*  Bus Mode Register (DMA_BMR) */
+#define BMR_PBL		0x00003f00	/*  Programmable Burst Length */
+#define BMR_DSL		0x0000007c	/*  Descriptor Skip Length */
+#define BMR_BAR		0x00000002	/*  Bus ARbitration */
+#define BMR_SWR		0x00000001	/*  Software Reset */
+
+#define DMA_BURST       4
+
+/*  Status Register (DMA_STS) */
+#define STS_BE		0x03800000	/*  Bus Error Bits */
+#define STS_TS		0x00700000	/*  Transmit Process State */
+#define STS_RS		0x000e0000	/*  Receive Process State */
+
+#define TS_STOP		0x00000000	/*  Stopped */
+#define TS_FTD		0x00100000	/*  Running Fetch Transmit Descriptor */
+#define TS_WEOT		0x00200000	/*  Running Wait for End Of Transmission */
+#define TS_QDAT		0x00300000	/*  Running Queue skb data into TX FIFO */
+#define TS_RES		0x00400000	/*  Reserved */
+#define TS_SPKT		0x00500000	/*  Reserved */
+#define TS_SUSP		0x00600000	/*  Suspended */
+#define TS_CLTD		0x00700000	/*  Running Close Transmit Descriptor */
+
+#define RS_STOP		0x00000000	/*  Stopped */
+#define RS_FRD		0x00020000	/*  Running Fetch Rx Descriptor */
+#define RS_CEOR		0x00040000	/*  Running Check for End of Rx Packet */
+#define RS_WFRP		0x00060000	/*  Running Wait for Rx Packet */
+#define RS_SUSP		0x00080000	/*  Suspended */
+#define RS_CLRD		0x000a0000	/*  Running Close Rx Descriptor */
+#define RS_FLUSH	0x000c0000	/*  Running Flush RX FIFO */
+#define RS_QRFS		0x000e0000	/*  Running Queue RX FIFO into RX Skb */
+
+/*  Operation Mode Register (DMA_OMR) */
+#define OMR_TTM		0x00400000	/*  Transmit Threshold Mode */
+#define OMR_SF		0x00200000	/*  Store and Forward */
+#define OMR_TR		0x0000c000	/*  Threshold Control Bits */
+#define OMR_ST		0x00002000	/*  Start/Stop Transmission Command */
+#define OMR_SR		0x00000002	/*  Start/Stop Receive */
+
+#define TR_18		0x00000000	/*  Threshold set to 18 (32) bytes */
+#define TR_24		0x00004000	/*  Threshold set to 24 (64) bytes */
+#define TR_32		0x00008000	/*  Threshold set to 32 (128) bytes */
+#define TR_40		0x0000c000	/*  Threshold set to 40 (256) bytes */
+
+/*  Missed Frames Counters (DMA_MFC) */
+#define MFC_CNT1	0xffff0000	/*  Missed Frames Counter Bits by */
+					/*  application */
+#define MFC_CNT2	0x0000ffff	/*  Missed Frames Counter Bits by */
+					/*  controller */
+
+/*  Mac control  Register (MAC_MCR) */
+#define MCR_RA		0x80000000	/*  Receive All */
+#define MCR_HBD		0x10000000	/*  HeartBeat Disable */
+#define MCR_PS		0x08000000	/*  Port Select */
+#define MCR_DRO		0x00800000	/*  Receive own Disable */
+#define MCR_OM		0x00600000	/*  Operating(loopback) Mode */
+#define MCR_FDX		0x00100000	/*  Full Duplex Mode */
+#define MCR_PM		0x00080000	/*  Pass All Multicast */
+#define MCR_PR		0x00040000	/*  Promiscuous Mode */
+#define MCR_IF		0x00020000	/*  Inverse Filtering */
+#define MCR_PB		0x00010000	/*  Pass Bad Frames */
+#define MCR_HO		0x00008000	/*  Hash Only Filtering Mode */
+#define MCR_HP		0x00002000	/*  Hash/Perfect Receive Filtering Mode */
+#define MCR_LCC		0x00001000	/*  Late Collision control */
+#define MCR_DBF		0x00000800	/*  Boardcast frame Disable */
+#define MCR_DTRY	0x00000400	/*  Retry Disable */
+#define MCR_ASTP	0x00000100	/*  Automatic pad stripping */
+#define MCR_BOLMT	0x000000c0	/*  Back off Limit */
+#define MCR_DC		0x00000020	/*  Deferral check */
+#define MCR_TE		0x00000008	/*  Transmitter enable */
+#define MCR_RE		0x00000004	/*  Receiver enable */
+
+#define MCR_MII_10	( OMR_TTM | MCR_PS)
+#define MCR_MII_100	( MCR_HBD | MCR_PS)
+
+/*  Constants for the intr mask and intr status registers. (DMA_SIS and DMA_IER) */
+#define DMA_INT_NI	0x00010000	/*  Normal interrupt summary */
+#define DMA_INT_AI	0x00008000	/*  Abnormal interrupt summary */
+#define DMA_INT_ER	0x00004000	/*  Early receive interrupt */
+#define DMA_INT_FB	0x00002000	/*  Fatal bus error */
+#define DMA_INT_ET	0x00000400	/*  Early transmit interrupt */
+#define DMA_INT_RW	0x00000200	/*  Receive watchdog timeout */
+#define DMA_INT_RS	0x00000100	/*  Receive stop */
+#define DMA_INT_RU	0x00000080	/*  Receive buffer unavailble */
+#define DMA_INT_RI	0x00000040	/*  Receive interrupt */
+#define DMA_INT_UN	0x00000020	/*  Underflow  */
+#define DMA_INT_TJ	0x00000008	/*  Transmit jabber timeout */
+#define DMA_INT_TU	0x00000004	/*  Transmit buffer unavailble  */
+#define DMA_INT_TS	0x00000002	/*  Transmit stop */
+#define DMA_INT_TI	0x00000001	/*  Transmit interrupt */
+
+#define DMA_TX_DEFAULT 	( DMA_INT_TI | DMA_INT_TS | DMA_INT_TU | DMA_INT_TJ | DMA_INT_FB )
+
+#define DMA_RX_DEFAULT 	( DMA_INT_RI | DMA_INT_RS | DMA_INT_RU | DMA_INT_RW | DMA_INT_FB )
+
+#define DMA_ENABLE	(DMA_INT_NI | DMA_INT_AI)
+
+
+/*  Receive Descriptor Bit Summary */
+#define R_OWN		0x80000000	/*  Own Bit */
+#define RD_FF		0x40000000	/*  Filtering Fail */
+#define RD_FL		0x3fff0000	/*  Frame Length */
+#define RD_ES		0x00008000	/*  Error Summary */
+#define RD_DE		0x00004000	/*  Descriptor Error */
+#define RD_LE		0x00001000	/*  Length Error */
+#define RD_RF		0x00000800	/*  Runt Frame */
+#define RD_MF		0x00000400	/*  Multicast Frame */
+#define RD_FS		0x00000200	/*  First Descriptor */
+#define RD_LS		0x00000100	/*  Last Descriptor */
+#define RD_TL		0x00000080	/*  Frame Too Long */
+#define RD_CS		0x00000040	/*  Collision Seen */
+#define RD_FT		0x00000020	/*  Frame Type */
+#define RD_RJ		0x00000010	/*  Receive Watchdog timeout */
+#define RD_RE		0x00000008	/*  Report on MII Error */
+#define RD_DB		0x00000004	/*  Dribbling Bit */
+#define RD_CE		0x00000002	/*  CRC Error */
+
+#define RD_RER		0x02000000	/*  Receive End Of Ring */
+#define RD_RCH		0x01000000	/*  Second Address Chained */
+#define RD_RBS2		0x003ff800	/*  Buffer 2 Size */
+#define RD_RBS1		0x000007ff	/*  Buffer 1 Size */
+
+/*  Transmit Descriptor Bit Summary */
+#define T_OWN		0x80000000	/*  Own Bit */
+#define TD_ES		0x00008000	/*  Frame Aborted (error summary) */
+#define TD_LO		0x00000800	/*  Loss Of Carrier */
+#define TD_NC		0x00000400	/*  No Carrier */
+#define TD_LC		0x00000200	/*  Late Collision */
+#define TD_EC		0x00000100	/*  Excessive Collisions */
+#define TD_HF		0x00000080	/*  Heartbeat Fail */
+#define TD_CC		0x0000003c	/*  Collision Counter */
+#define TD_UF		0x00000002	/*  Underflow Error */
+#define TD_DE		0x00000001	/*  Deferred */
+
+#define TD_IC		0x80000000	/*  Interrupt On Completion */
+#define TD_LS		0x40000000	/*  Last Segment */
+#define TD_FS		0x20000000	/*  First Segment */
+#define TD_FT1		0x10000000	/*  Filtering Type */
+#define TD_SET		0x08000000	/*  Setup Packet */
+#define TD_AC		0x04000000	/*  Add CRC Disable */
+#define TD_TER		0x02000000	/*  Transmit End Of Ring */
+#define TD_TCH		0x01000000	/*  Second Address Chained */
+#define TD_DPD		0x00800000	/*  Disabled Padding */
+#define TD_FT0		0x00400000	/*  Filtering Type */
+#define TD_TBS2		0x003ff800	/*  Buffer 2 Size */
+#define TD_TBS1		0x000007ff	/*  Buffer 1 Size */
+
+#define PERFECT_F  	0x00000000
+#define HASH_F     	TD_FT0
+#define INVERSE_F  	TD_FT1
+#define HASH_O_F   	(TD_FT1 | TD_F0)
+
+/*  ------------------------------------------------------------------------ */
+/*  MII Registers and Definitions */
+/*  ------------------------------------------------------------------------ */
+#define MII_CR       0x00          /* MII Management Control Register */
+#define MII_SR       0x01          /* MII Management Status Register */
+#define MII_ID0      0x02          /* PHY Identifier Register 0 */
+#define MII_ID1      0x03          /* PHY Identifier Register 1 */
+#define MII_ANA      0x04          /* Auto Negotiation Advertisement */
+#define MII_ANLPA    0x05          /* Auto Negotiation Link Partner Ability */
+#define MII_ANE      0x06          /* Auto Negotiation Expansion */
+#define MII_ANP      0x07          /* Auto Negotiation Next Page TX */
+
+/*  MII Management Control Register */
+#define MII_CR_RST  0x8000         /* RESET the PHY chip */
+#define MII_CR_LPBK 0x4000         /* Loopback enable */
+#define MII_CR_SPD  0x2000         /* 0: 10Mb/s; 1: 100Mb/s */
+#define MII_CR_10   0x0000         /* Set 10Mb/s */
+#define MII_CR_100  0x2000         /* Set 100Mb/s */
+#define MII_CR_ASSE 0x1000         /* Auto Speed Select Enable */
+#define MII_CR_PD   0x0800         /* Power Down */
+#define MII_CR_ISOL 0x0400         /* Isolate Mode */
+#define MII_CR_RAN  0x0200         /* Restart Auto Negotiation */
+#define MII_CR_FDM  0x0100         /* Full Duplex Mode */
+#define MII_CR_CTE  0x0080         /* Collision Test Enable */
+
+/*  MII Management Status Register */
+#define MII_SR_T4C  0x8000         /* 100BASE-T4 capable */
+#define MII_SR_TXFD 0x4000         /* 100BASE-TX Full Duplex capable */
+#define MII_SR_TXHD 0x2000         /* 100BASE-TX Half Duplex capable */
+#define MII_SR_TFD  0x1000         /* 10BASE-T Full Duplex capable */
+#define MII_SR_THD  0x0800         /* 10BASE-T Half Duplex capable */
+#define MII_SR_ASSC 0x0020         /* Auto Speed Selection Complete*/
+#define MII_SR_RFD  0x0010         /* Remote Fault Detected */
+#define MII_SR_ANC  0x0008         /* Auto Negotiation capable */
+#define MII_SR_LKS  0x0004         /* Link Status */
+#define MII_SR_JABD 0x0002         /* Jabber Detect */
+#define MII_SR_XC   0x0001         /* Extended Capabilities */
+
+/*  MII Management Auto Negotiation Advertisement Register */
+#define MII_ANA_TAF  0x03e0        /* Technology Ability Field */
+#define MII_ANA_T4AM 0x0200        /* T4 Technology Ability Mask */
+#define MII_ANA_TXAM 0x0180        /* TX Technology Ability Mask */
+#define MII_ANA_FDAM 0x0140        /* Full Duplex Technology Ability Mask */
+#define MII_ANA_HDAM 0x02a0        /* Half Duplex Technology Ability Mask */
+#define MII_ANA_100M 0x0380        /* 100Mb Technology Ability Mask */
+#define MII_ANA_10M  0x0060        /* 10Mb Technology Ability Mask */
+#define MII_ANA_CSMA 0x0001        /* CSMA-CD Capable */
+
+/*  MII Management Auto Negotiation Remote End Register */
+#define MII_ANLPA_NP   0x8000      /* Next Page (Enable) */
+#define MII_ANLPA_ACK  0x4000      /* Remote Acknowledge */
+#define MII_ANLPA_RF   0x2000      /* Remote Fault */
+#define MII_ANLPA_TAF  0x03e0      /* Technology Ability Field */
+#define MII_ANLPA_T4AM 0x0200      /* T4 Technology Ability Mask */
+#define MII_ANLPA_TXAM 0x0180      /* TX Technology Ability Mask */
+#define MII_ANLPA_FDAM 0x0140      /* Full Duplex Technology Ability Mask */
+#define MII_ANLPA_HDAM 0x02a0      /* Half Duplex Technology Ability Mask */
+#define MII_ANLPA_100M 0x0380      /* 100Mb Technology Ability Mask */
+#define MII_ANLPA_10M  0x0060      /* 10Mb Technology Ability Mask */
+#define MII_ANLPA_CSMA 0x0001      /* CSMA-CD Capable */
+
+/*  Media / mode state machine definitions */
+/*  User selectable: */
+#define TP              0x0040     /* 10Base-T (now equiv to _10Mb)        */
+#define TP_NW           0x0002     /* 10Base-T with Nway                   */
+#define BNC             0x0004     /* Thinwire                             */
+#define AUI             0x0008     /* Thickwire                            */
+#define BNC_AUI         0x0010     /* BNC/AUI on DC21040 indistinguishable */
+#define _10Mb           0x0040     /* 10Mb/s Ethernet                      */
+#define _100Mb          0x0080     /* 100Mb/s Ethernet                     */
+#define AUTO            0x4000     /* Auto sense the media or speed        */
+
+/*  Internal states */
+#define NC              0x0000     /* No Connection                        */
+#define ANS             0x0020     /* Intermediate AutoNegotiation State   */
+#define SPD_DET         0x0100     /* Parallel speed detection             */
+#define INIT            0x0200     /* Initial state                        */
+#define EXT_SIA         0x0400     /* External SIA for motherboard chip    */
+#define ANS_SUSPECT     0x0802     /* Suspect the ANS (TP) port is down    */
+#define TP_SUSPECT      0x0803     /* Suspect the TP port is down          */
+#define BNC_AUI_SUSPECT 0x0804     /* Suspect the BNC or AUI port is down  */
+#define EXT_SIA_SUSPECT 0x0805     /* Suspect the EXT SIA port is down     */
+#define BNC_SUSPECT     0x0806     /* Suspect the BNC port is down         */
+#define AUI_SUSPECT     0x0807     /* Suspect the AUI port is down         */
+#define MII             0x1000     /* MII on the 21143                     */
+
+#endif /* __JZ_ETH_H__ */
diff --git a/cpu/mips/jz_i2c.c b/cpu/mips/jz_i2c.c
new file mode 100644
index 0000000..9f3faee
--- /dev/null
+++ b/cpu/mips/jz_i2c.c
@@ -0,0 +1,234 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ4740) || defined(CONFIG_JZ5730) || defined(CONFIG_JZ4750)
+
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+
+
+/* I2C protocol */
+#define I2C_READ	1
+#define I2C_WRITE	0
+
+#define TIMEOUT         1000
+
+#define ETIMEDOUT 1
+
+
+static inline void my_udelay(int n )
+{
+	int i;
+	i=n*100;
+	while ( i-- )
+		;
+}
+
+
+/*
+ * I2C bus protocol basic routines
+ */
+static int i2c_put_data(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (!__i2c_received_ack() && timeout)
+		timeout--;
+
+	if (timeout)
+		return 0;
+	else
+		return -ETIMEDOUT;
+}
+
+static int i2c_get_data(unsigned char *data, int ack)
+{
+	int timeout = TIMEOUT*10;
+
+	if (!ack)
+		__i2c_send_nack();
+	else
+		__i2c_send_ack();
+
+	while (__i2c_check_drf() == 0 && timeout)
+		timeout--;
+
+	if (timeout) {
+		if (!ack)
+			__i2c_send_stop();
+		*data = __i2c_read();
+		__i2c_clear_drf();
+		return 0;
+	} else
+		return -ETIMEDOUT;
+}
+
+/*
+ * I2C interface
+ */
+void i2c_open(void)
+{
+	__i2c_set_clk(CONFIG_EXTAL, 10000); /* default 10 KHz */
+	__i2c_enable();
+}
+
+void i2c_close(void)
+{
+	my_udelay(300); /* wait for STOP goes over. */
+	__i2c_disable();
+}
+
+void i2c_setclk(unsigned int i2cclk)
+{
+	__i2c_set_clk(CONFIG_EXTAL, i2cclk);
+}
+
+int i2c_lseek(unsigned char device, unsigned char offset)
+{
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(offset) < 0)
+		goto address_err;
+	return 0;
+ device_err:
+	printf("No I2C device (0x%02x) installed.\n", device);
+	__i2c_send_stop();
+	return -1;
+ address_err:
+	printf("No I2C device (0x%02x) response.\n", device);
+	__i2c_send_stop();
+	return -1;
+}
+
+int i2c_read(unsigned char device, unsigned char *buf,
+	       unsigned char address, int count)
+{
+	int cnt = count;
+	int timeout = 5;
+
+L_try_again:
+
+	if (timeout < 0)
+		goto L_timeout;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_werr;
+	if (i2c_put_data(address) < 0)
+		goto address_err;
+
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_READ ) < 0)
+		goto device_rerr;
+	__i2c_send_ack();	/* Master sends ACK for continue reading */
+	while (cnt) {
+		if (cnt == 1) {
+			if (i2c_get_data(buf, 0) < 0)
+				break;
+		} else {
+			if (i2c_get_data(buf, 1) < 0)
+				break;
+		}
+		cnt--;
+		buf++;
+	}
+
+	__i2c_send_stop();
+	return count - cnt;
+ device_rerr:
+ device_werr:
+ address_err:
+	timeout --;
+	__i2c_send_stop();
+	goto L_try_again;
+
+L_timeout:
+	__i2c_send_stop();
+	printf("Read I2C device 0x%2x failed.\n", device);
+	return -1;
+}
+
+int i2c_write(unsigned char device, unsigned char *buf,
+		unsigned char address, int count)
+{
+	int cnt = count;
+	int cnt_in_pg;
+	int timeout = 5;
+	unsigned char *tmpbuf;
+	unsigned char tmpaddr;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+
+ W_try_again:
+	if (timeout < 0)
+		goto W_timeout;
+
+	cnt = count;
+	tmpbuf = (unsigned char *)buf;
+	tmpaddr = address;
+
+ start_write_page:
+	cnt_in_pg = 0;
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(tmpaddr) < 0)
+		goto address_err;
+	while (cnt) {
+		if (++cnt_in_pg > 8) {
+			__i2c_send_stop();
+			my_udelay(1000);
+			tmpaddr += 8;
+			goto start_write_page;
+		}
+		if (i2c_put_data(*tmpbuf) < 0)
+			break;
+		cnt--;
+		tmpbuf++;
+	}
+	__i2c_send_stop();
+	return count - cnt;
+ device_err:
+ address_err:
+	timeout--;
+	__i2c_send_stop();
+	goto W_try_again;
+
+ W_timeout:
+	printf("Write I2C device 0x%2x failed.\n", device);
+	__i2c_send_stop();
+	return -1;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ4740 || CONFIG_JZ5730 */
+
+
diff --git a/cpu/mips/jz_lcd.c b/cpu/mips/jz_lcd.c
new file mode 100644
index 0000000..36361ba
--- /dev/null
+++ b/cpu/mips/jz_lcd.c
@@ -0,0 +1,643 @@
+/*
+ * JzRISC lcd controller
+ *
+ * xiangfu liu <xiangfu.z@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* 
+ * Fallowing macro may be used:
+ *  CONFIG_LCD                        : LCD support 
+ *  LCD_BPP                           : Bits per pixel, 0 = 1, 1 = 2, 2 = 4, 3 = 8
+ *  CONFIG_LCD_LOGO                   : show logo
+ */
+
+#include <config.h>
+#include <common.h>
+#include <lcd.h>
+
+#include <asm/io.h>               /* virt_to_phys() */
+
+#if defined(CONFIG_LCD) && !defined(CONFIG_SLCD)
+
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#include "jz_lcd.h"
+
+
+struct jzfb_info {
+	unsigned int cfg;	/* panel mode and pin usage etc. */
+	unsigned int w;
+	unsigned int h;
+	unsigned int bpp;	/* bit per pixel */
+	unsigned int fclk;	/* frame clk */
+	unsigned int hsw;	/* hsync width, in pclk */
+	unsigned int vsw;	/* vsync width, in line count */
+	unsigned int elw;	/* end of line, in pclk */
+	unsigned int blw;	/* begin of line, in pclk */
+	unsigned int efw;	/* end of frame, in line count */
+	unsigned int bfw;	/* begin of frame, in line count */
+};
+
+static struct jzfb_info jzfb = {
+#if defined(CONFIG_JZLCD_SHARP_LQ035Q7)
+	MODE_TFT_SHARP | PCLK_N | VSYNC_N,
+	240, 320, 16, 60, 1, 2, 1, 2, 0, 6
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTS350Q1)
+	MODE_TFT_SAMSUNG | PCLK_N,
+	240, 320, 16, 60, 1, 2, (254-240), 0, 7, 0
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTV350QVF04)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N,
+	320, 240, 16, 70, 19, 4, 20, 14, 18, 6
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF01)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N,
+	480, 272, 16, 60, 41, 10, 2, 2, 2, 2
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF02_18BIT)
+	MODE_TFT_GEN | MODE_TFT_18BIT | HSYNC_N | VSYNC_N, /* MODE_TFT_18BIT: JZ4740@ version */
+	480, 272, 32, 60, 41, 10, 2, 2, 2, 2
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N | PCLK_N,
+	320, 240, 16, 85, 30, 3, 38, 20, 11, 8
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL)
+	MODE_8BIT_SERIAL_TFT | HSYNC_N | VSYNC_N | PCLK_N,
+	/* serial mode 280 lines, parallel mode 240 lines */
+	320, 280, 32, 60, (30*3), 3, (20*3), (38*3), 46, 23 
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N | PCLK_N | DE_N,
+	/* 240, 320, 16, 60, 3, 3, 3, 3, 3, 3 */ /* 240x320 */
+	320, 240, 16, 60, 3, 3, 3, 3, 3, 85 /* 320x240 */
+#endif
+#if defined(CONFIG_JZLCD_HYNIX_HT10X21)
+	MODE_TFT_GEN | PCLK_N,
+	1024, 768, 16, 45, 1, 1, 75, 0, 3, 0
+#endif
+#if defined(CONFIG_JZLCD_TOSHIBA_LTM084P363)
+	MODE_TFT_GEN | PCLK_N,
+	800, ,600, 16, 50, 1, 2, 199, 0, 2, 0
+#endif
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01)
+
+	#if defined(CONFIG_PAVO)
+		MODE_TFT_GEN | HSYNC_N | VSYNC_N | MODE_TFT_18BIT | PCLK_N,
+		320, 240, 18, 110, 1, 1, 10, 50, 10, 13
+	#elif defined(CONFIG_QI_LB60)
+		MODE_8BIT_SERIAL_TFT | PCLK_N | HSYNC_N | VSYNC_N,
+		320, 240, 32, 70, 1, 1, 273, 140, 1, 20
+	#else  /* defined(CONFIG_JZLCD_FOXCONN_PT035TN01) && (!defined(CONFIG_PAVO)) */
+		MODE_TFT_GEN | HSYNC_N | VSYNC_N | PCLK_N,
+		320, 240, 16, 110, 1, 1, 10, 50, 10, 13
+	#endif
+
+#endif	/* CONFIG_JZLCD_FOXCONN_PT035TN01 */
+#if defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+	MODE_8BIT_SERIAL_TFT | PCLK_N | HSYNC_N | VSYNC_N,
+	320, 240, 32, 60, 1, 1, 10, 50, 10, 13
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+	MODE_TFT_SHARP | PCLK_N,
+	800, 600, 16, 50, 1, 1, 255, 0, 34, 0 
+#endif
+#if defined(CONFIG_JZLCD_CSTN_800x600)
+	MODE_STN_COLOR_DUAL | STN_DAT_PIN8,
+	800, 600, 16, 30, 8, 1, 0, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_CSTN_320x240)
+	MODE_STN_COLOR_SINGLE | STN_DAT_PIN8,
+	320, 240, 16, 120, 8, 1, 8, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_640x480)
+	MODE_STN_MONO_DUAL | STN_DAT_PIN4,
+	640, 480, 8, 110, 4, 1, 4, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_320x240)
+	MODE_STN_MONO_SINGLE | STN_DAT_PIN4,
+	320, 240, 8, 110, 4, 1, 4, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_480x320)
+	MODE_STN_MONO_SINGLE | STN_DAT_PIN8
+#if defined(CONFIG_JZLCD_MSTN_INVERSE)
+	| DATA_INVERSE
+#endif
+	, 480, 320, 8, 65, 8, 1, 8, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_240x128)
+	MODE_STN_MONO_SINGLE | STN_DAT_PIN1
+#if defined(CONFIG_JZLCD_MSTN_INVERSE)
+	| DATA_INVERSE
+#endif
+	, 240, 128, 8, 100, 1, 1, 1, 0, 0, 0 
+#endif
+};
+
+/************************************************************************/
+
+vidinfo_t panel_info = {
+#if defined(CONFIG_JZLCD_SHARP_LQ035Q7)
+	240, 320, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTS350Q1)
+	240, 320, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTV350QVF04)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF01)
+	480, 272, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF02_18BIT)
+	480, 272, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL)
+	320, 280, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_HYNIX_HT10X21)
+	1024, 768, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TOSHIBA_LTM084P363)
+	800, 600, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+	800, 600, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_CSTN_800x600)
+	800, 600, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_CSTN_320x240)
+	320, 240, LCD_BPP,
+#endif
+};
+
+/*----------------------------------------------------------------------*/
+
+int lcd_line_length;
+
+int lcd_color_fg;
+int lcd_color_bg;
+
+/*
+ * Frame buffer memory information
+ */
+void *lcd_base;			/* Start of framebuffer memory	*/
+void *lcd_console_address;	/* Start of console buffer	*/
+
+short console_col;
+short console_row;
+
+/*----------------------------------------------------------------------*/
+
+void lcd_ctrl_init (void *lcdbase);
+
+void lcd_enable (void);
+void lcd_disable (void);
+
+/*----------------------------------------------------------------------*/
+
+static int  jz_lcd_init_mem(void *lcdbase, vidinfo_t *vid);
+static void jz_lcd_desc_init(vidinfo_t *vid);
+static int  jz_lcd_hw_init( vidinfo_t *vid );
+extern int flush_cache_all(void);
+
+#if LCD_BPP == LCD_COLOR8
+void lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue);
+#endif
+#if LCD_BPP == LCD_MONOCHROME
+void lcd_initcolregs (void);
+#endif
+
+/*-----------------------------------------------------------------------*/
+
+void lcd_ctrl_init (void *lcdbase)
+{
+	__lcd_display_pin_init();
+
+	jz_lcd_init_mem(lcdbase, &panel_info);
+	jz_lcd_desc_init(&panel_info);
+	jz_lcd_hw_init(&panel_info);
+
+	__lcd_display_on() ;
+}
+
+/*----------------------------------------------------------------------*/
+#if LCD_BPP == LCD_COLOR8
+void
+lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue)
+{
+}
+#endif
+/*----------------------------------------------------------------------*/
+
+#if LCD_BPP == LCD_MONOCHROME
+static
+void lcd_initcolregs (void)
+{
+}
+#endif
+
+/*
+ * Before enabled lcd controller, lcd registers should be configured correctly.
+ */
+
+void lcd_enable (void)
+{
+	REG_LCD_CTRL &= ~(1<<4); /* LCDCTRL.DIS */
+	REG_LCD_CTRL |= 1<<3;    /* LCDCTRL.ENA*/
+}
+
+void lcd_disable (void)
+{
+	REG_LCD_CTRL |= (1<<4); /* LCDCTRL.DIS, regular disable */
+	/* REG_LCD_CTRL |= (1<<3); */  /* LCDCTRL.DIS, quikly disable */
+}
+
+static int jz_lcd_init_mem(void *lcdbase, vidinfo_t *vid)
+{
+	u_long palette_mem_size;
+	struct jz_fb_info *fbi = &vid->jz_fb;
+	int fb_size = vid->vl_row * (vid->vl_col * NBITS (vid->vl_bpix)) / 8;
+
+	fbi->screen = (u_long)lcdbase;
+	fbi->palette_size = 256;
+	palette_mem_size = fbi->palette_size * sizeof(u16);
+
+	debug("jz_lcd.c palette_mem_size = 0x%08lx\n", (u_long) palette_mem_size);
+	/* locate palette and descs at end of page following fb */
+	fbi->palette = (u_long)lcdbase + fb_size + PAGE_SIZE - palette_mem_size;
+
+	return 0;
+}
+
+static void jz_lcd_desc_init(vidinfo_t *vid)
+{
+	struct jz_fb_info * fbi;
+	fbi = &vid->jz_fb;
+	fbi->dmadesc_fblow = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 3*16);
+	fbi->dmadesc_fbhigh = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 2*16);
+	fbi->dmadesc_palette = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 1*16);
+
+	#define BYTES_PER_PANEL	 (vid->vl_col * vid->vl_row * NBITS(vid->vl_bpix) / 8)
+
+	/* populate descriptors */
+	fbi->dmadesc_fblow->fdadr = virt_to_phys(fbi->dmadesc_fblow);
+	fbi->dmadesc_fblow->fsadr = virt_to_phys((void *)(fbi->screen + BYTES_PER_PANEL));
+	fbi->dmadesc_fblow->fidr  = 0;
+	fbi->dmadesc_fblow->ldcmd = BYTES_PER_PANEL / 4 ;
+
+	fbi->fdadr1 = virt_to_phys(fbi->dmadesc_fblow); /* only used in dual-panel mode */
+
+	fbi->dmadesc_fbhigh->fsadr = virt_to_phys((void *)fbi->screen); 
+	fbi->dmadesc_fbhigh->fidr = 0;
+	fbi->dmadesc_fbhigh->ldcmd =  BYTES_PER_PANEL / 4; /* length in word */
+
+	fbi->dmadesc_palette->fsadr = virt_to_phys((void *)fbi->palette);
+	fbi->dmadesc_palette->fidr  = 0;
+	fbi->dmadesc_palette->ldcmd = (fbi->palette_size * 2)/4 | (1<<28);
+
+	if( NBITS(vid->vl_bpix) < 12)
+	{
+		/* assume any mode with <12 bpp is palette driven */
+		fbi->dmadesc_palette->fdadr = virt_to_phys(fbi->dmadesc_fbhigh);
+		fbi->dmadesc_fbhigh->fdadr = virt_to_phys(fbi->dmadesc_palette);
+		/* flips back and forth between pal and fbhigh */
+		fbi->fdadr0 = virt_to_phys(fbi->dmadesc_palette);
+	} else {
+		/* palette shouldn't be loaded in true-color mode */
+		fbi->dmadesc_fbhigh->fdadr = virt_to_phys((void *)fbi->dmadesc_fbhigh);
+		fbi->fdadr0 = virt_to_phys(fbi->dmadesc_fbhigh); /* no pal just fbhigh */
+	}
+
+	flush_cache_all();
+}
+
+static int  jz_lcd_hw_init(vidinfo_t *vid)
+{
+	struct jz_fb_info *fbi = &vid->jz_fb;
+	unsigned int val = 0;
+	unsigned int pclk;
+	unsigned int stnH;
+#if defined(CONFIG_MIPS_JZ4740)
+	int pll_div;
+#endif
+
+	/* Setting Control register */
+	switch (jzfb.bpp) {
+	case 1:
+		val |= LCD_CTRL_BPP_1;
+		break;
+	case 2:
+		val |= LCD_CTRL_BPP_2;
+		break;
+	case 4:
+		val |= LCD_CTRL_BPP_4;
+		break;
+	case 8:
+		val |= LCD_CTRL_BPP_8;
+		break;
+	case 15:
+		val |= LCD_CTRL_RGB555;
+	case 16:
+		val |= LCD_CTRL_BPP_16;
+		break;
+#if defined(CONFIG_MIPS_JZ4740)
+	case 17 ... 32:
+		val |= LCD_CTRL_BPP_18_24;	/* target is 4bytes/pixel */
+		break;
+#endif
+	default:
+		printf("jz_lcd.c The BPP %d is not supported\n", jzfb.bpp);
+		val |= LCD_CTRL_BPP_16;
+		break;
+	}
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_STN_MONO_DUAL:
+	case MODE_STN_COLOR_DUAL:
+	case MODE_STN_MONO_SINGLE:
+	case MODE_STN_COLOR_SINGLE:
+		switch (jzfb.bpp) {
+		case 1:
+			/* val |= LCD_CTRL_PEDN; */
+		case 2:
+			val |= LCD_CTRL_FRC_2;
+			break;
+		case 4:
+			val |= LCD_CTRL_FRC_4;
+			break;
+		case 8:
+		default:
+			val |= LCD_CTRL_FRC_16;
+			break;
+		}
+		break;
+	}
+
+	val |= LCD_CTRL_BST_16;		/* Burst Length is 16WORD=64Byte */
+	val |= LCD_CTRL_OFUP;		/* OutFIFO underrun protect */
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_STN_MONO_DUAL:
+	case MODE_STN_COLOR_DUAL:
+	case MODE_STN_MONO_SINGLE:
+	case MODE_STN_COLOR_SINGLE:
+		switch (jzfb.cfg & STN_DAT_PINMASK) {
+#define align2(n) (n)=((((n)+1)>>1)<<1)
+#define align4(n) (n)=((((n)+3)>>2)<<2)
+#define align8(n) (n)=((((n)+7)>>3)<<3)
+		case STN_DAT_PIN1:
+			/* Do not adjust the hori-param value. */
+			break;
+		case STN_DAT_PIN2:
+			align2(jzfb.hsw);
+			align2(jzfb.elw);
+			align2(jzfb.blw);
+			break;
+		case STN_DAT_PIN4:
+			align4(jzfb.hsw);
+			align4(jzfb.elw);
+			align4(jzfb.blw);
+			break;
+		case STN_DAT_PIN8:
+			align8(jzfb.hsw);
+			align8(jzfb.elw);
+			align8(jzfb.blw);
+			break;
+		}
+		break;
+	}
+
+	REG_LCD_CTRL = val;
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_STN_MONO_DUAL:
+	case MODE_STN_COLOR_DUAL:
+	case MODE_STN_MONO_SINGLE:
+	case MODE_STN_COLOR_SINGLE:
+		if (((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL) ||
+		    ((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL))
+			stnH = jzfb.h >> 1;
+		else
+			stnH = jzfb.h;
+
+		REG_LCD_VSYNC = (0 << 16) | jzfb.vsw;
+		REG_LCD_HSYNC = ((jzfb.blw+jzfb.w) << 16) | (jzfb.blw+jzfb.w+jzfb.hsw);
+
+		/* Screen setting */
+		REG_LCD_VAT = ((jzfb.blw + jzfb.w + jzfb.hsw + jzfb.elw) << 16) | (stnH + jzfb.vsw + jzfb.bfw + jzfb.efw);
+		REG_LCD_DAH = (jzfb.blw << 16) | (jzfb.blw + jzfb.w);
+		REG_LCD_DAV = (0 << 16) | (stnH);
+
+		/* AC BIAs signal */
+		REG_LCD_PS = (0 << 16) | (stnH+jzfb.vsw+jzfb.efw+jzfb.bfw);
+
+		break;
+
+	case MODE_TFT_GEN:
+	case MODE_TFT_SHARP:
+	case MODE_TFT_CASIO:
+	case MODE_TFT_SAMSUNG:
+	case MODE_8BIT_SERIAL_TFT:
+	case MODE_TFT_18BIT:
+		REG_LCD_VSYNC = (0 << 16) | jzfb.vsw;
+		REG_LCD_HSYNC = (0 << 16) | jzfb.hsw;
+#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+		REG_LCD_DAV = (0 << 16) | ( jzfb.h );
+#else
+		REG_LCD_DAV =((jzfb.vsw+jzfb.bfw) << 16) | (jzfb.vsw +jzfb.bfw+jzfb.h);
+#endif /*#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)*/
+		REG_LCD_DAH = ((jzfb.hsw + jzfb.blw) << 16) | (jzfb.hsw + jzfb.blw + jzfb.w );
+		REG_LCD_VAT = (((jzfb.blw + jzfb.w + jzfb.elw + jzfb.hsw)) << 16) \
+			| (jzfb.vsw + jzfb.bfw + jzfb.h + jzfb.efw);
+		break;
+	}
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_TFT_SAMSUNG:
+	{
+		unsigned int total, tp_s, tp_e, ckv_s, ckv_e;
+		unsigned int rev_s, rev_e, inv_s, inv_e;
+
+		pclk = val * (jzfb.w + jzfb.hsw + jzfb.elw + jzfb.blw) *
+			(jzfb.h + jzfb.vsw + jzfb.efw + jzfb.bfw); /* Pixclk */
+
+		total = jzfb.blw + jzfb.w + jzfb.elw + jzfb.hsw;
+		tp_s = jzfb.blw + jzfb.w + 1;
+		tp_e = tp_s + 1;
+		/* ckv_s = tp_s - jz_clocks.pixclk/(1000000000/4100); */
+		ckv_s = tp_s - pclk/(1000000000/4100);
+		ckv_e = tp_s + total;
+		rev_s = tp_s - 11;	/* -11.5 clk */
+		rev_e = rev_s + total;
+		inv_s = tp_s;
+		inv_e = inv_s + total;
+		REG_LCD_CLS = (tp_s << 16) | tp_e;
+		REG_LCD_PS = (ckv_s << 16) | ckv_e;
+		REG_LCD_SPL = (rev_s << 16) | rev_e;
+		REG_LCD_REV = (inv_s << 16) | inv_e;
+		jzfb.cfg |= STFT_REVHI | STFT_SPLHI;
+		break;
+	}
+	case MODE_TFT_SHARP:
+	{
+		unsigned int total, cls_s, cls_e, ps_s, ps_e;
+		unsigned int spl_s, spl_e, rev_s, rev_e;
+		total = jzfb.blw + jzfb.w + jzfb.elw + jzfb.hsw;
+#if !defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+		spl_s = 1;
+		spl_e = spl_s + 1;
+		cls_s = 0;
+		cls_e = total - 60;	/* > 4us (pclk = 80ns) */
+		ps_s = cls_s;
+		ps_e = cls_e;
+		rev_s = total - 40;	/* > 3us (pclk = 80ns) */
+		rev_e = rev_s + total;
+		jzfb.cfg |= STFT_PSHI; 
+#else           /*#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)*/
+		spl_s = total - 5; /* LD */
+		spl_e = total -3;
+		cls_s = 32;	/* CKV */
+		cls_e = 145;
+		ps_s  = 0;      /* OEV */
+		ps_e  = 45;
+		rev_s = 0;	/* POL */
+		rev_e = 0;
+#endif          /*#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)*/
+		REG_LCD_SPL = (spl_s << 16) | spl_e;
+		REG_LCD_CLS = (cls_s << 16) | cls_e;
+		REG_LCD_PS = (ps_s << 16) | ps_e;
+		REG_LCD_REV = (rev_s << 16) | rev_e;
+		break;
+	}
+	case MODE_TFT_CASIO:
+		break;
+	}
+
+	/* Configure the LCD panel */
+	REG_LCD_CFG = jzfb.cfg;
+
+	/* Timing setting */
+	__cpm_stop_lcd();
+
+	val = jzfb.fclk; /* frame clk */
+	if ( (jzfb.cfg & MODE_MASK) != MODE_8BIT_SERIAL_TFT) {
+		pclk = val * (jzfb.w + jzfb.hsw + jzfb.elw + jzfb.blw) *
+			(jzfb.h + jzfb.vsw + jzfb.efw + jzfb.bfw); /* Pixclk */
+	}
+	else {
+		/* serial mode: Hsync period = 3*Width_Pixel */
+		pclk = val * (jzfb.w*3 + jzfb.hsw + jzfb.elw + jzfb.blw) *
+			(jzfb.h + jzfb.vsw + jzfb.efw + jzfb.bfw); /* Pixclk */
+	}
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_SINGLE) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL))
+		pclk = (pclk * 3);
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_SINGLE) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_SINGLE) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL))
+		pclk = pclk >> ((jzfb.cfg & STN_DAT_PINMASK) >> 4);
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL))
+		pclk >>= 1;
+
+#if defined(CONFIG_MIPS_JZ4730)
+	val = __cpm_get_pllout() / pclk;
+	REG_CPM_CFCR2 = val - 1;
+	val = pclk * 4 ;
+	if ( val > 150000000 ) {
+		printf("Warning: LCDClock=%d\n, LCDClock must less or equal to 150MHz.\n", val);
+		printf("Change LCDClock to 150MHz\n");
+		val = 150000000;
+	}
+	val = __cpm_get_pllout() / val;
+	val--;
+	if ( val > 0xF ) 
+		val = 0xF;
+	__cpm_set_lcdclk_div(val);
+	REG_CPM_CFCR |= CPM_CFCR_UPE;
+
+#elif defined(CONFIG_MIPS_JZ4740)
+	pll_div = ( REG_CPM_CPCCR & CPM_CPCCR_PCS ); /* clock source,0:pllout/2 1: pllout */
+	pll_div = pll_div ? 1 : 2 ;
+	val = ( __cpm_get_pllout()/pll_div ) / pclk;
+	val--;
+	if ( val > 0x1ff ) {
+		printf("CPM_LPCDR too large, set it to 0x1ff\n");
+		val = 0x1ff;
+	}
+	__cpm_set_pixdiv(val);
+
+	val = pclk * 3 ;	/* LCDClock > 2.5*Pixclock */
+	if ( val > 150000000 ) {
+		printf("Warning: LCDClock=%d\n, LCDClock must less or equal to 150MHz.\n", val);
+		printf("Change LCDClock to 150MHz\n");
+		val = 150000000;
+	}
+	val = ( __cpm_get_pllout()/pll_div ) / val;
+	val--;
+	if ( val > 0x1f ) {
+		printf("CPM_CPCCR.LDIV too large, set it to 0x1f\n");
+		val = 0x1f;
+	}
+	__cpm_set_ldiv( val );
+	REG_CPM_CPCCR |= CPM_CPCCR_CE ; /* update divide */
+
+#else
+#error "cpu/mips/jz_lcd.c, CONFIG_MIPS_JZ4730, please set chip type."
+#endif /*#ifdef CONFIG_MIPS_JZ4730 */
+
+	__cpm_start_lcd();
+	udelay(1000);
+
+	REG_LCD_DA0 = fbi->fdadr0; /* frame descripter*/
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL))
+		REG_LCD_DA1 = fbi->fdadr1; /* frame descripter*/
+
+	return 0;
+}
+
+#endif /* CONFIG_LCD */
diff --git a/cpu/mips/jz_lcd.h b/cpu/mips/jz_lcd.h
new file mode 100644
index 0000000..d2e7cc4
--- /dev/null
+++ b/cpu/mips/jz_lcd.h
@@ -0,0 +1,1020 @@
+/*
+ * JzRISC lcd controller
+ *
+ * xiangfu liu <xiangfu.z@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __JZLCD_H__
+#define __JZLCD_H__
+
+#include <asm/io.h>
+/*
+ * change u-boot macro to celinux macro 
+ */
+/* Chip type */
+#if defined(CONFIG_JZ4730)
+#define CONFIG_MIPS_JZ4730 		1
+#endif
+#if defined(CONFIG_JZ4740)
+#define CONFIG_MIPS_JZ4740 		1
+#endif
+#if defined(CONFIG_JZ5730)
+#define CONFIG_MIPS_JZ5730 		1
+#endif
+
+/* board type */
+#if defined(CONFIG_LIBRA)
+#define CONFIG_MIPS_JZ4730_LIBRA 		1
+#endif
+#if defined(CONFIG_PMPV1)
+#define CONFIG_MIPS_JZ4730_PMPV1 		1
+#endif
+#if defined(CONFIG_PMPV2)
+#define CONFIG_MIPS_JZ4730_PMPV2 		1
+#endif
+#if defined(CONFIG_GPS)
+#define CONFIG_MIPS_JZ4730_GPS 			1
+#endif
+#if defined(CONFIG_FPRINT)
+#define CONFIG_MIPS_JZ4730_FPRINT 		1
+#endif
+#if defined(CONFIG_LEO)
+#define CONFIG_MIPS_JZ4740_LEO 			1
+#endif
+#if defined(CONFIG_PAVO)
+#define CONFIG_MIPS_JZ4740_PAVO 		1
+#endif
+#if defined(CONFIG_QI_LB60)
+#define CONFIG_MIPS_JZ4740_PI 		1
+#endif
+#if defined(CONFIG_VIRGO)
+#define CONFIG_MIPS_JZ4740_VIRGO 		1
+#endif
+
+#define mdelay(n) 		udelay((n)*1000)
+
+/*
+ * change u-boot macro to celinux macro 
+ */
+
+#define NR_PALETTE	256
+
+struct lcd_desc{
+	unsigned int next_desc; /* LCDDAx */
+	unsigned int databuf;   /* LCDSAx */
+	unsigned int frame_id;  /* LCDFIDx */ 
+	unsigned int cmd;       /* LCDCMDx */
+};
+
+#define MODE_MASK		0x0f
+#define MODE_TFT_GEN		0x00
+#define MODE_TFT_SHARP		0x01
+#define MODE_TFT_CASIO		0x02
+#define MODE_TFT_SAMSUNG	0x03
+#define MODE_CCIR656_NONINT	0x04
+#define MODE_CCIR656_INT	0x05
+#define MODE_STN_COLOR_SINGLE	0x08
+#define MODE_STN_MONO_SINGLE	0x09
+#define MODE_STN_COLOR_DUAL	0x0a
+#define MODE_STN_MONO_DUAL	0x0b
+#define MODE_8BIT_SERIAL_TFT    0x0c
+
+#define MODE_TFT_18BIT          (1<<7)
+
+#define STN_DAT_PIN1	(0x00 << 4)
+#define STN_DAT_PIN2	(0x01 << 4)
+#define STN_DAT_PIN4	(0x02 << 4)
+#define STN_DAT_PIN8	(0x03 << 4)
+#define STN_DAT_PINMASK	STN_DAT_PIN8
+
+#define STFT_PSHI	(1 << 15)
+#define STFT_CLSHI	(1 << 14)
+#define STFT_SPLHI	(1 << 13)
+#define STFT_REVHI	(1 << 12)
+
+#define SYNC_MASTER	(0 << 16)
+#define SYNC_SLAVE	(1 << 16)
+
+#define DE_P		(0 << 9)
+#define DE_N		(1 << 9)
+
+#define PCLK_P		(0 << 10)
+#define PCLK_N		(1 << 10)
+
+#define HSYNC_P		(0 << 11)
+#define HSYNC_N		(1 << 11)
+
+#define VSYNC_P		(0 << 8)
+#define VSYNC_N		(1 << 8)
+
+#define DATA_NORMAL	(0 << 17)
+#define DATA_INVERSE	(1 << 17)
+
+
+/* Jz LCDFB supported I/O controls. */
+#define FBIOSETBACKLIGHT	0x4688
+#define FBIODISPON		0x4689
+#define FBIODISPOFF		0x468a
+#define FBIORESET		0x468b
+#define FBIOPRINT_REG		0x468c
+
+/*
+ * LCD panel specific definition
+ */
+
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW) || defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL)
+
+#if defined(CONFIG_MIPS_JZ4730_PMPV1)
+#define LCD_RESET_PIN	63
+#elif defined(CONFIG_MIPS_JZ4730_PMPV2)
+#define LCD_RESET_PIN	60
+#elif defined(CONFIG_MIPS_JZ4740_LEO)
+#define LCD_RESET_PIN	50
+#endif
+
+#define __lcd_special_on() \
+do { \
+	__gpio_set_pin(LCD_RESET_PIN); \
+	__gpio_as_output(LCD_RESET_PIN); \
+	__gpio_clear_pin(LCD_RESET_PIN); \
+	udelay(100); \
+	__gpio_set_pin(LCD_RESET_PIN); \
+} while (0)
+
+#endif /* CONFIG_JZLCD_TRULY_TFTG320240DTSW, parellel or serial RGB mode */
+
+#if defined(CONFIG_JZLCD_SAMSUNG_LTV350QVF04)
+
+#if defined(CONFIG_MIPS_JZ4730_FPRINT)
+#define PortSDI	60
+#define PortSCL	61
+#define PortCS	62
+#define PortRST	63
+#define PortSht 64
+#endif
+
+#if defined(CONFIG_MIPS_JZ4730_GPS)
+#define PortSDI	74
+#define PortSCL	72
+#define PortCS	73
+#define PortRST	60
+#define PortSht 59
+#endif
+
+#ifndef PortSDI
+#define PortSDI	0
+#endif
+#ifndef PortSCL
+#define PortSCL	0
+#endif
+#ifndef PortCS
+#define PortCS	0
+#endif
+#ifndef PortRST
+#define PortRST	0
+#endif
+#ifndef PortSht
+#define PortSht	0
+#endif
+
+#define __lcd_special_pin_init() \
+do { \
+	__gpio_as_output(PortSDI); /* SDI */\
+	__gpio_as_output(PortSCL); /* SCL */ \
+	__gpio_as_output(PortCS); /* CS */ \
+	__gpio_as_output(PortRST); /* Reset */ \
+	__gpio_as_output(PortSht); /* Shut Down # */ \
+	__gpio_set_pin(PortCS); \
+	__gpio_set_pin(PortSCL); \
+	__gpio_set_pin(PortSDI); \
+} while (0)
+
+#define __spi_out(val) \
+do { \
+	int __i__; \
+	unsigned int _t_ = (val); \
+	__gpio_clear_pin(PortCS); \
+	udelay(25); \
+	for (__i__ = 0; __i__ < 24; __i__++ ) { \
+		__gpio_clear_pin(PortSCL); \
+		if (_t_ & 0x800000) \
+			__gpio_set_pin(PortSDI); \
+		else \
+			__gpio_clear_pin(PortSDI); \
+		_t_ <<= 1; \
+		udelay(25); \
+		__gpio_set_pin(PortSCL); \
+		udelay(25); \
+	} \
+	__gpio_set_pin(PortCS); \
+	udelay(25); \
+	__gpio_set_pin(PortSDI); \
+	udelay(25); \
+	__gpio_set_pin(PortSCL); \
+} while (0)
+
+#define __spi_id_op_data(rs, rw, val) \
+	__spi_out((0x1d<<18)|((rs)<<17)|((rw)<<16)|(val))
+
+#define __spi_write_reg(reg, val) \
+do { \
+	__spi_id_op_data(0, 0, (reg)); \
+	__spi_id_op_data(1, 0, (val)); \
+} while (0)
+
+#define __lcd_special_on() \
+do { \
+	__gpio_set_pin(PortSht); \
+	__gpio_clear_pin(PortRST); \
+	mdelay(10); \
+	__gpio_set_pin(PortRST); \
+	mdelay(1); \
+	__spi_write_reg(0x09, 0); \
+	mdelay(10); \
+	__spi_write_reg(0x09, 0x4000); \
+	__spi_write_reg(0x0a, 0x2000); \
+	mdelay(40); \
+	__spi_write_reg(0x09, 0x4055); \
+	mdelay(50); \
+	__spi_write_reg(0x01, 0x409d); \
+	__spi_write_reg(0x02, 0x0204); \
+	__spi_write_reg(0x03, 0x0100); \
+	__spi_write_reg(0x04, 0x3000); \
+	__spi_write_reg(0x05, 0x4003); \
+	__spi_write_reg(0x06, 0x000a); \
+	__spi_write_reg(0x07, 0x0021); \
+	__spi_write_reg(0x08, 0x0c00); \
+	__spi_write_reg(0x10, 0x0103); \
+	__spi_write_reg(0x11, 0x0301); \
+	__spi_write_reg(0x12, 0x1f0f); \
+	__spi_write_reg(0x13, 0x1f0f); \
+	__spi_write_reg(0x14, 0x0707); \
+	__spi_write_reg(0x15, 0x0307); \
+	__spi_write_reg(0x16, 0x0707); \
+	__spi_write_reg(0x17, 0x0000); \
+	__spi_write_reg(0x18, 0x0004); \
+	__spi_write_reg(0x19, 0x0000); \
+	mdelay(60); \
+	__spi_write_reg(0x09, 0x4a55); \
+	__spi_write_reg(0x05, 0x5003); \
+} while (0)
+
+#define __lcd_special_off() \
+do { \
+	__spi_write_reg(0x09, 0x4055); \
+	__spi_write_reg(0x05, 0x4003); \
+	__spi_write_reg(0x0a, 0x0000); \
+	mdelay(10); \
+	__spi_write_reg(0x09, 0x4000); \
+	__gpio_clear_pin(PortSht); \
+} while (0)
+
+#endif  /* CONFIG_JZLCD_SAMSUNG_LTV350QVF04 */
+
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01) || defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01) /* board pmp */
+#define MODE 0xcd 		/* 24bit parellel RGB */
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+#define MODE 0xc9		/* 8bit serial RGB */
+#endif
+
+#if defined(CONFIG_MIPS_JZ4730_PMPV1) || defined(CONFIG_MIPS_JZ4730_PMPV2)
+	#define SPEN	60       /*LCD_SPL */
+	#define SPCK	61       /*LCD_CLS */
+	#define SPDA	62       /*LCD_PS */
+	#define LCD_RET 63       /*LCD_REV */ /*use for lcd reset */
+#elif defined(CONFIG_MIPS_JZ4740_LEO) /* board leo */
+	#define SPEN	(32*1+18)       /*LCD_SPL */
+	#define SPCK	(32*1+17)       /*LCD_CLS */
+	#define SPDA	(32*2+22)       /*LCD_PS */
+	#define LCD_RET (32*2+23)       /*LCD_REV  */ /* use for lcd reset */
+#elif defined(CONFIG_MIPS_JZ4740_PAVO) /* board pavo */
+	#define SPEN	(32*1+18)       /*LCD_SPL */
+	#define SPCK	(32*1+17)       /*LCD_CLS */
+	#define SPDA	(32*2+12)       /*LCD_D12 */
+	#define LCD_RET (32*2+23)       /*LCD_REV, GPC23 */
+#elif defined(CONFIG_MIPS_JZ4740_PI) /* board pavo */
+	#define SPEN	(32*2+21)       /*LCD_SPL */
+	#define SPCK	(32*2+23)       /*LCD_CLS */
+	#define SPDA	(32*2+22)       /*LCD_D12 */
+	#define LCD_RET (32*3+27) 
+#else
+#error "cpu/misp/Jzlcd.h, please define SPI pins on your board."
+#endif
+
+	#define __spi_write_reg1(reg, val) \
+	do { \
+		unsigned char no;\
+		unsigned short value;\
+		unsigned char a=0;\
+		unsigned char b=0;\
+		a=reg;\
+		b=val;\
+		__gpio_set_pin(SPEN);\
+		__gpio_set_pin(SPCK);\
+		__gpio_clear_pin(SPDA);\
+		__gpio_clear_pin(SPEN);\
+		udelay(25);\
+		value=((a<<8)|(b&0xFF));\
+		for(no=0;no<16;no++)\
+		{\
+			__gpio_clear_pin(SPCK);\
+			if((value&0x8000)==0x8000)\
+			__gpio_set_pin(SPDA);\
+			else\
+			__gpio_clear_pin(SPDA);\
+			udelay(25);\
+			__gpio_set_pin(SPCK);\
+			value=(value<<1); \
+			udelay(25);\
+		 }\
+		__gpio_set_pin(SPEN);\
+		udelay(100);\
+	} while (0)
+
+	#define __spi_write_reg(reg, val) \
+	do {\
+		__spi_write_reg1((reg<<2|2), val);\
+		udelay(100); \
+	}while(0)
+
+	
+	#define __lcd_special_pin_init() \
+	do { \
+		__gpio_as_output(SPEN); /* use SPDA */\
+		__gpio_as_output(SPCK); /* use SPCK */\
+		__gpio_as_output(SPDA); /* use SPDA */\
+		__gpio_as_output(LCD_RET);\
+	} while (0)
+
+#if defined(CONFIG_QI_LB60)
+	#define __lcd_special_on() \
+		do { \
+		udelay(50);\
+		__spi_write_reg1(0x05, 0x16); \
+		__spi_write_reg1(0x04, 0x0b); \
+		__spi_write_reg1(0x07, 0x8d); \
+		__spi_write_reg1(0x01, 0x95); \
+		__spi_write_reg1(0x08, 0xc0); \
+		__spi_write_reg1(0x03, 0x40); \
+		__spi_write_reg1(0x06, 0x15); \
+		__spi_write_reg1(0x05, 0xd7); \
+		} while (0)	/* reg 0x0a is control the display direction:DB0->horizontal level DB1->vertical level */
+
+	#define __lcd_special_off()				\
+			  do {					\
+				  __spi_write_reg1(0x05, 0x5e);	\
+			  } while (0)
+#else 
+	#define __lcd_special_on() \
+	do { \
+		udelay(50);\
+		__gpio_clear_pin(LCD_RET);\
+		mdelay(150);\
+		__gpio_set_pin(LCD_RET);\
+		mdelay(10);\
+		__spi_write_reg(0x00, 0x03); \
+		__spi_write_reg(0x01, 0x40); \
+		__spi_write_reg(0x02, 0x11); \
+		__spi_write_reg(0x03, MODE); /* mode */ \
+		__spi_write_reg(0x04, 0x32); \
+		__spi_write_reg(0x05, 0x0e); \
+		__spi_write_reg(0x07, 0x03); \
+		__spi_write_reg(0x08, 0x08); \
+		__spi_write_reg(0x09, 0x40); \
+		__spi_write_reg(0x0A, 0x88); \
+		__spi_write_reg(0x0B, 0x88); \
+		__spi_write_reg(0x0C, 0x20); \
+		__spi_write_reg(0x0D, 0x20); \
+	} while (0)	/*reg 0x0a is control the display direction:DB0->horizontal level DB1->vertical level */
+	
+	#define __lcd_special_off() \
+	do { \
+		__spi_write_reg(0x00, 0x03); \
+	} while (0)
+
+#endif	/* CONFIG_QI_LB60 */
+#endif	/* CONFIG_JZLCD_FOXCONN_PT035TN01 or CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL */
+
+#if defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+		
+#if defined(CONFIG_MIPS_JZ4730_FPRINT)
+ #define PortSDI	60
+ #define PortSCL	65		/* GPIO65 as WR/SCL */
+ #define PortCS	62
+ #define PortRST	63
+ #define PortSDO 64
+ #define PortSCL1  61
+#else
+ #error "driver/video/Jzlcd.h, please define pins on your board."
+#endif
+
+#define __spi_out(val) \
+do { \
+	int __i__; \
+	unsigned int _t_ = (val); \
+	__gpio_clear_pin(PortCS); \
+	udelay(2); \
+	for (__i__ = 0; __i__ < 24; __i__++ ) { \
+		__gpio_clear_pin(PortSCL); \
+		if (_t_ & 0x800000) \
+			__gpio_set_pin(PortSDI); \
+		else \
+			__gpio_clear_pin(PortSDI); \
+		_t_ <<= 1; \
+		udelay(1); \
+		__gpio_set_pin(PortSCL); \
+		udelay(1); \
+	} \
+	udelay(2); \
+	__gpio_set_pin(PortCS); \
+	__gpio_set_pin(PortSDI); \
+	__gpio_set_pin(PortSCL); \
+} while (0)
+
+#define __spi_id_op_data(rs, rw, val) \
+	__spi_out((0x0e<<19)|(0<<18)|((rs)<<17)|((rw)<<16)|(val)) /* 0e: 01110. ID:? */
+
+#define __spi_write_reg(reg, val) \
+do { \
+	__spi_id_op_data(0, 0, (reg)); \
+	__spi_id_op_data(1, 0, (val)); \
+} while (0)
+
+#define get_data(n)	(__gpio_get_pin((n)) ? 1:0) /* 1: high level, 0: low level */
+
+static inline unsigned int __spi_in(void)
+{
+	int __i__; 
+	unsigned int read_val = 0;
+	unsigned int _t_ = (0x0e<<19)|(0<<18)|((1)<<17)|((1)<<16);/* 0e: 01110. ID:? */
+
+	__gpio_clear_pin(PortCS); 
+	udelay(2); 
+	for (__i__ = 0; __i__ < 32; __i__++ ) { 
+		__gpio_clear_pin(PortSCL); 
+		if (_t_ & 0x800000) /* send data */
+			__gpio_set_pin(PortSDI); 
+		else 
+			__gpio_clear_pin(PortSDI); 
+		_t_ <<= 1; 
+		udelay(1); 
+		__gpio_set_pin(PortSCL); 
+		read_val <<= 1;
+		read_val |= get_data(PortSDO); /* receive data */
+		udelay(1); 
+	} 
+	udelay(2); 
+	__gpio_set_pin(PortCS); 
+	__gpio_set_pin(PortSDI); 
+	__gpio_set_pin(PortSCL); 
+
+	return read_val;
+ }
+static inline unsigned int __spi_read_reg(int reg)
+{
+	unsigned int read_val;
+	__spi_id_op_data(0, 0, (reg));
+	udelay(40);
+	read_val = __spi_in();
+	return read_val;
+}
+
+#define WMLCDCOM(val)	__spi_id_op_data(0,0,val)
+#define WMLCDDATA(val)	__spi_id_op_data(1,0,val)
+#define Delayms(n) 	mdelay(n)
+
+static inline void mlcd_mode_setting(void)
+{
+	/* RGB Interface */ 
+	WMLCDCOM(0x0001);WMLCDDATA(0x0000); /* Horizontal reverse  */
+	WMLCDCOM(0x0002);WMLCDDATA(0x0700);
+	/* Entry Mode */
+	/*WMLCDCOM(0x0003);WMLCDDATA(0x1230);*/ /* default 240x320, HWM=1 write data in high speed */
+	WMLCDCOM(0x0003);WMLCDDATA(0x1038); /* Rotate to 320x240, HWM=0, low speed */
+	WMLCDCOM(0x000C);WMLCDDATA(0x0111); /* External interface, as 16bit RGB interface */
+	WMLCDCOM(0x0020);WMLCDDATA(0x0000); /* Horizontal base */
+	WMLCDCOM(0x0021);WMLCDDATA(0x0000); /* Vertical base */
+	WMLCDCOM(0x0030);WMLCDDATA(0x0707);
+	WMLCDCOM(0x0031);WMLCDDATA(0x0407);
+	WMLCDCOM(0x0032);WMLCDDATA(0x0203);
+	WMLCDCOM(0x0033);WMLCDDATA(0x0303);
+	WMLCDCOM(0x0034);WMLCDDATA(0x0303);
+	WMLCDCOM(0x0035);WMLCDDATA(0x0202);
+	WMLCDCOM(0x0036);WMLCDDATA(0x001F);
+	WMLCDCOM(0x0037);WMLCDDATA(0x0707);
+	WMLCDCOM(0x0038);WMLCDDATA(0x0407);
+	WMLCDCOM(0x0039);WMLCDDATA(0x0203);
+	WMLCDCOM(0x003A);WMLCDDATA(0x0303);
+	WMLCDCOM(0x003B);WMLCDDATA(0x0303);
+	WMLCDCOM(0x003C);WMLCDDATA(0x0202);
+	WMLCDCOM(0x003D);WMLCDDATA(0x001F);
+	WMLCDCOM(0x0050);WMLCDDATA(0x0000); /* X start:  0 */
+	WMLCDCOM(0x0051);WMLCDDATA(0x00EF); /* X end:  239 */
+	WMLCDCOM(0x0052);WMLCDDATA(0x0000); /* Y start:  0 */
+	WMLCDCOM(0x0053);WMLCDDATA(0x013F); /* Y end:  319 */
+	WMLCDCOM(0x0060);WMLCDDATA(0x2700);
+	WMLCDCOM(0x0061);WMLCDDATA(0x0001);
+	WMLCDCOM(0x006A);WMLCDDATA(0x0000); /* VL: Vertical Scroll */
+	WMLCDCOM(0x0090);WMLCDDATA(0x0016);
+	WMLCDCOM(0x0092);WMLCDDATA(0x0000);
+	WMLCDCOM(0x0093);WMLCDDATA(0x0000);
+}
+
+static inline void mlcd_power_on(void)
+{ 
+	/* Power supply on */
+	WMLCDCOM(0x0007);WMLCDDATA(0x0001);
+	WMLCDCOM(0x0017);WMLCDDATA(0x0001);
+	Delayms(50);
+	WMLCDCOM(0x0010);WMLCDDATA(0x17B0);
+	WMLCDCOM(0x0011);WMLCDDATA(0x0007);
+	WMLCDCOM(0x0012);WMLCDDATA(0x011A);
+	WMLCDCOM(0x0013);WMLCDDATA(0x0F00);
+	WMLCDCOM(0x0029);WMLCDDATA(0x0010);
+	WMLCDCOM(0x0012);WMLCDDATA(0x013A);
+	Delayms(50);
+}
+
+static inline void mlcd_power_off(void)
+{ 
+	WMLCDCOM(0x0010);WMLCDDATA(0x0780);
+	WMLCDCOM(0x0011);WMLCDDATA(0x0067);
+	WMLCDCOM(0x0012);WMLCDDATA(0x010A);
+	Delayms(20);
+	WMLCDCOM(0x0010);WMLCDDATA(0x0700);
+}
+
+static inline void mlcd_display_on(void)
+{
+	/* Display on sequence */
+	WMLCDCOM(0x0007);WMLCDDATA(0x0021);
+	Delayms(1);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0061);
+	Delayms(20);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0173);
+	WMLCDCOM(0x0022);	/* set Index register R22 */
+}
+
+static inline void mlcd_display_off(void)
+{
+	/* Display off sequence */
+	WMLCDCOM(0x0007);WMLCDDATA(0x0072);
+	Delayms(20);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0001);
+	Delayms(1);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0000);
+}
+	
+#define __lcd_special_pin_init() \
+do { \
+	__gpio_as_input(PortSDO);  /* SDO */\
+	__gpio_as_output(PortSDI); /* SDI */\
+	__gpio_as_output(PortSCL); /* SCL */ \
+	__gpio_as_output(PortCS);  /* CS */ \
+	__gpio_as_output(PortRST); /* Reset */ \
+	__gpio_as_output(PortSCL1); /* SCL1 */ \
+	__gpio_set_pin(PortCS); \
+	__gpio_set_pin(PortSCL); \
+	__gpio_set_pin(PortSDI); \
+	__gpio_set_pin(PortRST); \
+	__gpio_set_pin(PortSCL1); \
+	__gpio_set_pin(PortRST); \
+} while (0)
+
+#define __lcd_special_on() \
+do { \
+	mdelay(10); \
+	__gpio_clear_pin(PortRST); /* Reset period > 1ms */ \
+	mdelay(10); \
+	__gpio_set_pin(PortRST); \
+	mdelay(1); \
+	mlcd_power_on(); \
+	mlcd_mode_setting();\
+	mlcd_display_on(); \
+} while (0)
+
+#if 0				/* Customer need Power Off? --No need, right now */
+#define __lcd_special_off() \
+do { \
+	mlcd_display_off(); \
+	mlcd_power_off(); \
+} while (0)
+#endif /* if 0 */
+
+#endif	/* CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E */
+
+#ifndef __lcd_special_pin_init
+#define __lcd_special_pin_init()
+#endif
+#ifndef __lcd_special_on
+#define __lcd_special_on()
+#endif
+#ifndef __lcd_special_off
+#define __lcd_special_off()
+#endif
+
+
+/*
+ * Platform specific definition
+ */
+
+#if defined(CONFIG_MIPS_JZ4730_GPS)
+
+#define __lcd_set_backlight_level(n) \
+do { \
+	; \
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init(); \
+	__gpio_as_output(94); /* PWM0 pin */ \
+	__gpio_as_output(95); /* PWM1 pin */ \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_special_on(); \
+	__gpio_set_pin(94); /* PWM0 pin */ \
+	__gpio_set_pin(95); /* PWM1 pin */ \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_special_off(); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4730_GPS */
+
+#if defined(CONFIG_MIPS_JZ4730_FPRINT)
+
+#define __lcd_set_backlight_level(n) \
+do { \
+	REG_PWM_DUT(0) = n; \
+	REG_PWM_PER(0) = 7; \
+	REG_PWM_CTR(0) = 0xc1; \
+} while (0)
+
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init();\
+	__gpio_as_pwm();\
+	__lcd_set_backlight_level(8);\
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_set_backlight_level(8); \
+	__lcd_special_on();\
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_set_backlight_level(0); \
+	__lcd_special_off();\
+} while (0)
+
+#elif	defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+/* pwm circle frequece = 1KHz */
+/* back light level: 0~100 */
+#undef  __lcd_set_backlight_level
+#define __lcd_set_backlight_level(n) \
+do { \
+	REG_PWM_DUT(0) = n; \
+	REG_PWM_PER(0) = 99; \
+	REG_PWM_CTR(0) = 0xe4; \
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init();\
+	__gpio_as_pwm();\
+	__lcd_set_backlight_level(88);\
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_set_backlight_level(88); \
+	__lcd_special_on();\
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_set_backlight_level(0); \
+	__lcd_special_off();\
+} while (0)
+
+#else
+
+#define __lcd_display_pin_init() \
+do { \
+	__gpio_as_output(GPIO_DISP_OFF_N); \
+	__gpio_as_pwm(); \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_set_backlight_level(8); \
+	__gpio_set_pin(GPIO_DISP_OFF_N); \
+} while (0)
+	
+#define __lcd_display_off() \
+do { \
+	__lcd_set_backlight_level(0); \
+	__gpio_clear_pin(GPIO_DISP_OFF_N); \
+} while (0)
+#endif
+
+#endif /* CONFIG_MIPS_JZ4730_FPRINT */
+
+#if defined(CONFIG_MIPS_JZ4730_LIBRA)
+
+#define __lcd_set_backlight_level(n) \
+do { \
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init(); \
+	__gpio_clear_pin(100); \
+	__gpio_as_output(100); \
+	__gpio_as_output(94); \
+	__gpio_as_output(95); \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_special_on(); \
+	__gpio_set_pin(100); \
+	__gpio_set_pin(94); \
+	__gpio_set_pin(95); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_special_off(); \
+	__gpio_clear_pin(100); \
+	__gpio_clear_pin(94); \
+	__gpio_clear_pin(95); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4730_LIBRA */
+
+#if defined(CONFIG_MIPS_JZ4730_PMPV1) || defined(CONFIG_MIPS_JZ4730_PMPV2)
+
+#define GPIO_PWM0 94
+
+#define __lcd_set_backlight_level(n) \
+do { \
+	__gpio_as_pwm(); \
+	REG_PWM_DUT(0) = n; \
+	REG_PWM_PER(0) = 7; \
+	REG_PWM_CTR(0) = 0xc1; \
+} while (0)
+
+#define __lcd_close_backlight() \
+do { \
+__gpio_as_output(GPIO_PWM0);\
+__gpio_clear_pin(GPIO_PWM0);\
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__gpio_as_output(GPIO_DISP_OFF_N); \
+	__lcd_set_backlight_level(8); \
+	__lcd_special_pin_init(); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__gpio_set_pin(GPIO_DISP_OFF_N); \
+	__lcd_special_on(); \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_special_off(); \
+	__lcd_close_backlight(); \
+	__gpio_clear_pin(GPIO_DISP_OFF_N); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4730_PMPV1 | CONFIG_MIPS_JZ4730_PMPV1 */
+
+
+#if defined(CONFIG_MIPS_JZ4740_LEO) || defined(CONFIG_MIPS_JZ4740_PAVO)|| defined(CONFIG_MIPS_JZ4740_VIRGO)
+
+#if defined(CONFIG_MIPS_JZ4740_PAVO)
+#define GPIO_PWM    123		/* GP_D27 */
+#define PWM_CHN 4    /* pwm channel */
+#define PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+/*#define __lcd_set_backlight_level(n)                     \
+do {                                                     \
+	__gpio_as_pwm(4); \
+        __tcu_disable_pwm_output(PWM_CHN);               \
+        __tcu_stop_counter(PWM_CHN);                     \
+        __tcu_init_pwm_output_high(PWM_CHN);             \
+        __tcu_set_pwm_output_shutdown_abrupt(PWM_CHN);   \
+        __tcu_select_clk_div1(PWM_CHN);                  \
+        __tcu_mask_full_match_irq(PWM_CHN);              \
+        __tcu_mask_half_match_irq(PWM_CHN);              \
+        __tcu_set_count(PWM_CHN,0);                      \
+        __tcu_set_full_data(PWM_CHN,__cpm_get_extalclk()/1000);           \
+        __tcu_set_half_data(PWM_CHN,__cpm_get_extalclk()/1000*n/100);     \
+        __tcu_enable_pwm_output(PWM_CHN);                \
+        __tcu_select_extalclk(PWM_CHN);                  \
+        __tcu_start_counter(PWM_CHN);                    \
+} while (0)
+*/
+#define __lcd_set_backlight_level(n)                     \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_set_pin(GPIO_PWM); \
+} while (0)
+
+#define __lcd_close_backlight() \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_clear_pin(GPIO_PWM); \
+} while (0)
+
+#elif defined(CONFIG_MIPS_JZ4740_VIRGO)
+#define GPIO_PWM    119		/* GP_D23 */
+#define PWM_CHN 0    /* pwm channel */
+#define PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+/*#define __lcd_set_backlight_level(n)                     \
+do {                                                     \
+	__gpio_as_pwm(0); \
+        __tcu_disable_pwm_output(PWM_CHN);               \
+        __tcu_stop_counter(PWM_CHN);                     \
+        __tcu_init_pwm_output_high(PWM_CHN);             \
+        __tcu_set_pwm_output_shutdown_abrupt(PWM_CHN);   \
+        __tcu_select_clk_div1(PWM_CHN);                  \
+        __tcu_mask_full_match_irq(PWM_CHN);              \
+        __tcu_mask_half_match_irq(PWM_CHN);              \
+        __tcu_set_count(PWM_CHN,0);                      \
+        __tcu_set_full_data(PWM_CHN,__cpm_get_extalclk()/1000);           \
+        __tcu_set_half_data(PWM_CHN,__cpm_get_extalclk()/1000*n/100);     \
+        __tcu_enable_pwm_output(PWM_CHN);                \
+        __tcu_select_extalclk(PWM_CHN);                  \
+        __tcu_start_counter(PWM_CHN);                    \
+	} while (0)
+*/
+
+#define __lcd_set_backlight_level(n)                     \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_set_pin(GPIO_PWM); \
+} while (0)
+
+#define __lcd_close_backlight() \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_clear_pin(GPIO_PWM); \
+} while (0)
+
+#elif defined CONFIG_MIPS_JZ4740_LEO
+
+#define __lcd_set_backlight_level(n)
+#define __lcd_close_backlight()
+
+#endif /* #if defined(CONFIG_MIPS_JZ4740_PAVO) */
+
+#define __lcd_display_pin_init() \
+do { \
+	__gpio_as_output(GPIO_DISP_OFF_N); \
+	__cpm_start_tcu(); \
+	__lcd_special_pin_init(); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_special_on(); \
+	__gpio_set_pin(GPIO_DISP_OFF_N); \
+        udelay(500000); \
+	__lcd_set_backlight_level(80); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_close_backlight(); \
+	__lcd_special_off(); \
+	__gpio_clear_pin(GPIO_DISP_OFF_N); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4740_LEO */
+
+#if defined(CONFIG_JZLCD_MSTN_240x128)
+#if 0	/* The final version does not use software emulation of VCOM. */
+
+#define GPIO_VSYNC	59
+#define GPIO_VCOM	90
+
+#define REG_VCOM	REG_GPIO_GPDR((GPIO_VCOM>>5))
+#define VCOM_BIT	(1 << (GPIO_VCOM & 0x1f))
+static unsigned int vcom_static;
+static void vsync_irq(int irq, void *dev_id, struct pt_regs *reg)
+{
+	vcom_static = REG_VCOM;
+	vcom_static ^= VCOM_BIT;
+	REG_VCOM = vcom_static;
+}
+
+#define __lcd_display_pin_init()					  \
+	__gpio_as_irq_rise_edge(GPIO_VSYNC);				  \
+	__gpio_as_output(GPIO_VCOM);					  \
+	{								  \
+	static int inited = 0;						  \
+	if (!inited) {							  \
+	inited = 1;							  \
+	if (request_irq(IRQ_GPIO_0 + GPIO_VSYNC, vsync_irq, SA_INTERRUPT, \
+			"vsync", 0)) {					  \
+		err = -EBUSY;						  \
+		goto failed;						  \
+	}}}
+
+#endif
+
+/* We uses AC BIAs pin to generate VCOM signal, so above code should be removed.
+ */
+
+#endif
+
+#if defined(CONFIG_MIPS_JZ4740_PI)
+
+	/* 100 level: 0,1,...,100 */
+	#define __lcd_set_backlight_level(n)\
+	do { \
+	__gpio_as_output(32*3+27); \
+	__gpio_set_pin(32*3+27); \
+	} while (0)
+
+	#define __lcd_close_backlight() \
+	do { \
+	__gpio_as_output(GPIO_PWM); \
+	__gpio_clear_pin(GPIO_PWM); \
+	} while (0)
+
+	#define __lcd_display_pin_init() \
+	do { \
+		__gpio_as_output(GPIO_DISP_OFF_N); \
+		__cpm_start_tcu(); \
+		__lcd_special_pin_init(); \
+	} while (0)
+	/*	__lcd_set_backlight_level(100); \*/
+	#define __lcd_display_on() \
+	do { \
+		__gpio_set_pin(GPIO_DISP_OFF_N); \
+		__lcd_special_on(); \
+	} while (0)
+
+	#define __lcd_display_off() \
+	do { \
+		__lcd_special_off(); \
+		__gpio_clear_pin(GPIO_DISP_OFF_N); \
+	} while (0)
+
+#endif /* CONFIG_MIPS_JZ4740_PI) */
+
+/*****************************************************************************
+ * LCD display pin dummy macros
+ *****************************************************************************/
+#ifndef __lcd_display_pin_init
+#define __lcd_display_pin_init()
+#endif
+#ifndef __lcd_display_on
+#define __lcd_display_on()
+#endif
+#ifndef __lcd_display_off
+#define __lcd_display_off()
+#endif
+#ifndef __lcd_set_backlight_level
+#define __lcd_set_backlight_level(n)
+#endif
+
+#endif /* __JZLCD_H__ */
diff --git a/cpu/mips/jz_mmc.c b/cpu/mips/jz_mmc.c
new file mode 100644
index 0000000..ec0a518
--- /dev/null
+++ b/cpu/mips/jz_mmc.c
@@ -0,0 +1,1404 @@
+/*
+ * (C) Copyright 2003
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h> 
+#include <common.h>
+#include <part.h>
+
+#if defined CONFIG_JZ4740 || defined CONFIG_JZ4730
+#ifdef CONFIG_JZ4730
+#include <asm-mips/jz4730.h>
+#endif
+#ifdef CONFIG_JZ4740
+#include <asm-mips/jz4740.h>
+#endif
+
+#include "jz_mmc.h"
+
+#define CFG_MMC_BASE		0x80600000
+static int sd2_0 = 0;
+
+/*
+ * GPIO definition
+ */
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected()			\
+({						\
+	int detected = 1;			\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+	if (!__gpio_get_pin(GPIO_SD_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+/*
+ * Local functions
+ */
+
+#ifdef CONFIG_MMC
+extern int
+fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static int mmc_ready = 0;
+static mmc_csd_t mmc_csd;
+static int use_4bit;                    /* Use 4-bit data bus */
+/*
+ *  MMC Events
+ */
+#define MMC_EVENT_NONE	        0x00	/* No events */
+#define MMC_EVENT_RX_DATA_DONE	0x01	/* Rx data done */
+#define MMC_EVENT_TX_DATA_DONE	0x02	/* Tx data done */
+#define MMC_EVENT_PROG_DONE	0x04	/* Programming is done */
+
+
+#define MMC_IRQ_MASK()				\
+do {						\
+      	REG_MSC_IMASK = 0xffff;			\
+      	REG_MSC_IREG = 0xffff;			\
+} while (0)
+
+/* Stop the MMC clock and wait while it happens */
+static inline int jz_mmc_stop_clock(void)
+{
+	int timeout = 1000;
+	
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;
+
+	while (timeout && (REG_MSC_STAT & MSC_STAT_CLK_EN)) {
+		timeout--;
+		if (timeout == 0) {
+			return MMC_ERROR_TIMEOUT;
+		}
+		udelay(1);
+	}
+        return MMC_NO_ERROR;
+}
+
+/* Start the MMC clock and operation */
+static inline int jz_mmc_start_clock(void)
+{
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START | MSC_STRPCL_START_OP;
+	return MMC_NO_ERROR;
+}
+
+static inline u32 jz_mmc_calc_clkrt(int is_sd, u32 rate)
+{
+	u32 clkrt;
+	u32 clk_src = is_sd ? 24000000: 16000000;
+
+	clkrt = 0;
+  	while (rate < clk_src)
+    	{
+      		clkrt ++;
+      		clk_src >>= 1;
+    	}
+	return clkrt;
+}
+
+/* Set the MMC clock frequency */
+void jz_mmc_set_clock(int sd, u32 rate)
+{
+	jz_mmc_stop_clock();
+
+	/* Select clock source of MSC */
+	__cpm_select_msc_clk(sd);
+
+	/* Set clock dividor of MSC */
+	REG_MSC_CLKRT = jz_mmc_calc_clkrt(sd, rate);
+}
+
+static int jz_mmc_check_status(struct mmc_request *request)
+{
+	u32 status = REG_MSC_STAT;
+
+	/* Checking for response or data timeout */
+	if (status & (MSC_STAT_TIME_OUT_RES | MSC_STAT_TIME_OUT_READ)) {
+		printf("MMC/SD timeout, MMC_STAT 0x%x CMD %d\n", status, request->cmd);
+		return MMC_ERROR_TIMEOUT;
+	}
+
+	/* Checking for CRC error */
+	if (status & (MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR | MSC_STAT_CRC_RES_ERR)) {
+		printf("MMC/CD CRC error, MMC_STAT 0x%x\n", status);
+		return MMC_ERROR_CRC;
+	}
+
+	return MMC_NO_ERROR;
+}
+
+/* Obtain response to the command and store it to response buffer */
+static void jz_mmc_get_response(struct mmc_request *request)
+{
+	int i;
+	u8 *buf;
+	u32 data;
+
+	DEBUG(3, "fetch response for request %d, cmd %d\n", request->rtype, request->cmd);
+
+	buf = request->response;
+	request->result = MMC_NO_ERROR;
+
+	switch (request->rtype) {
+	case RESPONSE_R1: case RESPONSE_R1B: case RESPONSE_R6:
+	case RESPONSE_R3: case RESPONSE_R4: case RESPONSE_R5:
+	{
+		data = REG_MSC_RES;
+		buf[0] = (data >> 8) & 0xff;
+		buf[1] = data & 0xff;
+		data = REG_MSC_RES;
+		buf[2] = (data >> 8) & 0xff;
+		buf[3] = data & 0xff;
+		data = REG_MSC_RES;
+		buf[4] = data & 0xff;
+
+		DEBUG(3, "request %d, response [%02x %02x %02x %02x %02x]\n",
+		      request->rtype, buf[0], buf[1], buf[2], buf[3], buf[4]);
+		break;
+	}
+	case RESPONSE_R2_CID: case RESPONSE_R2_CSD:
+	{
+		for (i = 0; i < 16; i += 2) {
+			data = REG_MSC_RES;
+			buf[i] = (data >> 8) & 0xff;
+			buf[i+1] = data & 0xff;
+		}
+		DEBUG(3, "request %d, response [", request->rtype);
+#if CONFIG_MMC_DEBUG_VERBOSE > 2
+		if (g_mmc_debug >= 3) {
+			int n;
+			for (n = 0; n < 17; n++)
+				printk("%02x ", buf[n]);
+			printk("]\n");
+		}
+#endif
+		break;
+	}
+	case RESPONSE_NONE:
+		DEBUG(3, "No response\n");
+		break;
+		
+	default:
+		DEBUG(3, "unhandled response type for request %d\n", request->rtype);
+		break;
+	}
+}
+
+static int jz_mmc_receive_data(struct mmc_request *req)
+{
+	u32  stat, timeout, data, cnt;
+	u8 *buf = req->buffer;
+	u32 wblocklen = (u32)(req->block_len + 3) >> 2; /* length in word */
+	
+	timeout = 0x3ffffff;
+	
+	while (timeout) {
+		timeout--;
+		stat = REG_MSC_STAT;
+		
+		if (stat & MSC_STAT_TIME_OUT_READ)
+			return MMC_ERROR_TIMEOUT;
+		else if (stat & MSC_STAT_CRC_READ_ERROR)
+			return MMC_ERROR_CRC;
+		else if (!(stat & MSC_STAT_DATA_FIFO_EMPTY) 
+			 || (stat & MSC_STAT_DATA_FIFO_AFULL)) {
+			/* Ready to read data */
+			break;
+		}
+		udelay(1);
+	}
+	if (!timeout)
+		return MMC_ERROR_TIMEOUT;
+	
+	/* Read data from RXFIFO. It could be FULL or PARTIAL FULL */
+	cnt = wblocklen;
+	while (cnt) {
+		data = REG_MSC_RXFIFO;
+		{
+			*buf++ = (u8)(data >> 0);
+			*buf++ = (u8)(data >> 8);
+			*buf++ = (u8)(data >> 16);
+			*buf++ = (u8)(data >> 24);
+		}
+		cnt --;
+		while (cnt && (REG_MSC_STAT & MSC_STAT_DATA_FIFO_EMPTY))
+			;
+	}
+	return MMC_NO_ERROR;
+}
+
+static int jz_mmc_transmit_data(struct mmc_request *req)
+{
+#if 0
+	u32 nob = req->nob;
+	u32 wblocklen = (u32)(req->block_len + 3) >> 2; /* length in word */
+	u8 *buf = req->buffer;
+	u32 *wbuf = (u32 *)buf;
+	u32 waligned = (((u32)buf & 0x3) == 0); /* word aligned ? */
+	u32 stat, timeout, data, cnt;
+
+	for (nob; nob >= 1; nob--) {
+		timeout = 0x3FFFFFF;
+
+		while (timeout) {
+			timeout--;
+			stat = REG_MSC_STAT;
+
+			if (stat & (MSC_STAT_CRC_WRITE_ERROR | MSC_STAT_CRC_WRITE_ERROR_NOSTS))
+				return MMC_ERROR_CRC;
+			else if (!(stat & MSC_STAT_DATA_FIFO_FULL)) {
+				/* Ready to write data */
+				break;
+			}
+
+			udelay(1);
+		}
+
+		if (!timeout)
+			return MMC_ERROR_TIMEOUT;
+
+		/* Write data to TXFIFO */
+		cnt = wblocklen;
+		while (cnt) {
+			while (REG_MSC_STAT & MSC_STAT_DATA_FIFO_FULL)
+				;
+
+			if (waligned) {
+				REG_MSC_TXFIFO = *wbuf++;
+			}
+			else {
+				data = *buf++ | (*buf++ << 8) | (*buf++ << 16) | (*buf++ << 24);
+				REG_MSC_TXFIFO = data;
+			}
+
+			cnt--;
+		}
+	}
+#endif
+	return MMC_NO_ERROR;
+}
+
+
+/*
+ * Name:	  int jz_mmc_exec_cmd()
+ * Function:      send command to the card, and get a response
+ * Input:	  struct mmc_request *req	: MMC/SD request
+ * Output:	  0:  right		>0:  error code
+ */
+int jz_mmc_exec_cmd(struct mmc_request *request)
+{
+	u32 cmdat = 0, events = 0;
+	int retval, timeout = 0x3fffff;
+
+	/* Indicate we have no result yet */
+	request->result = MMC_NO_RESPONSE;
+	if (request->cmd == MMC_CIM_RESET) {
+		/* On reset, 1-bit bus width */
+		use_4bit = 0;
+
+		/* Reset MMC/SD controller */
+		__msc_reset();
+
+		/* On reset, drop MMC clock down */
+		jz_mmc_set_clock(0, MMC_CLOCK_SLOW);
+
+		/* On reset, stop MMC clock */
+		jz_mmc_stop_clock();
+	}
+	if (request->cmd == MMC_SEND_OP_COND) {
+		DEBUG(3, "Have an MMC card\n");
+		/* always use 1bit for MMC */
+		use_4bit = 0;
+	}
+	if (request->cmd == SET_BUS_WIDTH) {
+		if (request->arg == 0x2) {
+			DEBUG(2, "Use 4-bit bus width\n");
+			use_4bit = 1;
+		}
+		else {
+			DEBUG(2, "Use 1-bit bus width\n");
+			use_4bit = 0;
+		}
+	}
+
+	/* stop clock */
+	jz_mmc_stop_clock();
+
+	/* mask all interrupts */
+	REG_MSC_IMASK = 0xffff;
+
+	/* clear status */
+	REG_MSC_IREG = 0xffff;
+
+	/* use 4-bit bus width when possible */
+	if (use_4bit)
+		cmdat |= MSC_CMDAT_BUS_WIDTH_4BIT;
+
+        /* Set command type and events */ 
+	switch (request->cmd) {
+	/* MMC core extra command */
+	case MMC_CIM_RESET:
+		cmdat |= MSC_CMDAT_INIT; /* Initialization sequence sent prior to command */
+		break;
+
+	/* bc - broadcast - no response */
+	case MMC_GO_IDLE_STATE:
+	case MMC_SET_DSR:
+		break;
+
+	/* bcr - broadcast with response */
+	case MMC_SEND_OP_COND:
+	case MMC_ALL_SEND_CID:
+	case MMC_GO_IRQ_STATE:
+		break;
+
+	/* adtc - addressed with data transfer */
+	case MMC_READ_DAT_UNTIL_STOP:
+	case MMC_READ_SINGLE_BLOCK:
+	case MMC_READ_MULTIPLE_BLOCK:
+	case SEND_SCR:
+		cmdat |= MSC_CMDAT_DATA_EN | MSC_CMDAT_READ;
+		events = MMC_EVENT_RX_DATA_DONE;
+		break;
+
+	case MMC_WRITE_DAT_UNTIL_STOP:
+	case MMC_WRITE_BLOCK:
+	case MMC_WRITE_MULTIPLE_BLOCK:
+	case MMC_PROGRAM_CID:
+	case MMC_PROGRAM_CSD:
+	case MMC_SEND_WRITE_PROT:
+	case MMC_GEN_CMD:
+	case MMC_LOCK_UNLOCK:
+		cmdat |= MSC_CMDAT_DATA_EN | MSC_CMDAT_WRITE;
+		events = MMC_EVENT_TX_DATA_DONE | MMC_EVENT_PROG_DONE;
+
+		break;
+
+	case MMC_STOP_TRANSMISSION:
+		events = MMC_EVENT_PROG_DONE;
+		break;
+
+	/* ac - no data transfer */
+	default: 
+		break;
+	}
+
+	/* Set response type */
+	switch (request->rtype) {
+	case RESPONSE_NONE:
+		break;
+
+	case RESPONSE_R1B:
+		cmdat |= MSC_CMDAT_BUSY;
+		/*FALLTHRU*/
+	case RESPONSE_R1:
+		cmdat |= MSC_CMDAT_RESPONSE_R1;
+		break;
+	case RESPONSE_R2_CID:
+	case RESPONSE_R2_CSD:
+		cmdat |= MSC_CMDAT_RESPONSE_R2;
+		break;
+	case RESPONSE_R3:
+		cmdat |= MSC_CMDAT_RESPONSE_R3;
+		break;
+	case RESPONSE_R4:
+		cmdat |= MSC_CMDAT_RESPONSE_R4;
+		break;
+	case RESPONSE_R5:
+		cmdat |= MSC_CMDAT_RESPONSE_R5;
+		break;
+	case RESPONSE_R6:
+		cmdat |= MSC_CMDAT_RESPONSE_R6;
+		break;
+	default:
+		break;
+	}
+
+	/* Set command index */
+	if (request->cmd == MMC_CIM_RESET) {
+		REG_MSC_CMD = MMC_GO_IDLE_STATE;
+	} else {
+		REG_MSC_CMD = request->cmd;
+	}
+
+        /* Set argument */
+	REG_MSC_ARG = request->arg;
+
+	/* Set block length and nob */
+	if (request->cmd == SEND_SCR) { /* get SCR from DataFIFO */
+		REG_MSC_BLKLEN = 8;
+		REG_MSC_NOB = 1;
+	} else {
+		REG_MSC_BLKLEN = request->block_len;
+		REG_MSC_NOB = request->nob;
+	}
+
+	/* Set command */
+	REG_MSC_CMDAT = cmdat;
+
+	DEBUG(1, "Send cmd %d cmdat: %x arg: %x resp %d\n", request->cmd,
+	      cmdat, request->arg, request->rtype);
+
+        /* Start MMC/SD clock and send command to card */
+	jz_mmc_start_clock();
+
+	/* Wait for command completion */
+	while (timeout-- && !(REG_MSC_STAT & MSC_STAT_END_CMD_RES))
+		;
+
+	if (timeout == 0)
+		return MMC_ERROR_TIMEOUT;
+
+	REG_MSC_IREG = MSC_IREG_END_CMD_RES; /* clear flag */
+
+	/* Check for status */
+	retval = jz_mmc_check_status(request);
+	if (retval) {
+		return retval;
+	}
+
+	/* Complete command with no response */
+	if (request->rtype == RESPONSE_NONE) {
+		return MMC_NO_ERROR;
+	}
+
+	/* Get response */
+	jz_mmc_get_response(request);
+
+	/* Start data operation */
+	if (events & (MMC_EVENT_RX_DATA_DONE | MMC_EVENT_TX_DATA_DONE)) {
+		if (events & MMC_EVENT_RX_DATA_DONE) {
+			if (request->cmd == SEND_SCR) {
+				/* SD card returns SCR register as data. 
+				   MMC core expect it in the response buffer, 
+				   after normal response. */
+				request->buffer = (u8 *)((u32)request->response + 5);
+			}
+			jz_mmc_receive_data(request);
+		}
+		
+		if (events & MMC_EVENT_TX_DATA_DONE) {
+			jz_mmc_transmit_data(request);
+		}
+		
+		/* Wait for Data Done */
+		while (!(REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE))
+			;
+		REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE; /* clear status */
+	}
+
+	/* Wait for Prog Done event */
+	if (events & MMC_EVENT_PROG_DONE) {
+		while (!(REG_MSC_IREG & MSC_IREG_PRG_DONE))
+			;
+		REG_MSC_IREG = MSC_IREG_PRG_DONE; /* clear status */
+	}
+
+	/* Command completed */
+
+	return MMC_NO_ERROR;			 /* return successfully */
+}
+
+int mmc_block_read(u8 *dst, ulong src, ulong len)
+{
+
+	struct mmc_request request;
+	struct mmc_response_r1 r1;
+	int retval; 
+
+	if (len == 0) {
+		return 0;
+	}
+	mmc_simple_cmd(&request, MMC_SEND_STATUS, mmcinfo.rca, RESPONSE_R1);
+	retval = mmc_unpack_r1(&request, &r1, 0);
+	if (retval && (retval != MMC_ERROR_STATE_MISMATCH)) {
+		return retval;
+	}
+
+	mmc_simple_cmd(&request, MMC_SET_BLOCKLEN, len, RESPONSE_R1);
+	if ((retval = mmc_unpack_r1(&request, &r1, 0))) {
+		return retval;
+	}
+
+	if (sd2_0)
+		src /= len;
+	
+	mmc_send_cmd(&request, MMC_READ_SINGLE_BLOCK, src, 1,len, RESPONSE_R1, dst);
+	if ((retval = mmc_unpack_r1(&request, &r1, 0))) {
+		return retval;
+	}
+	return retval;
+}
+
+int mmc_block_write(ulong dst, uchar *src, int len)
+{
+	return 0;
+}
+
+int mmc_read(ulong src, uchar *dst, int size)
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("MMC card is not ready\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CFG_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf+part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+
+		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+
+	if (part_end && src < end) {
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+
+}
+
+int mmc_write(uchar *src, ulong dst, int size)
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+	
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("MMC card is not ready\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CFG_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		(ulong)src, dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf+part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && dst < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
+{
+	ulong src;
+	int mmc_block_size = MMC_BLOCK_SIZE;
+
+	src = blknr * mmc_block_size + CFG_MMC_BASE;
+	mmc_read(src, (uchar *)dst, blkcnt*mmc_block_size);
+	return blkcnt;
+}
+
+int mmc_select_card(void)
+{
+	struct mmc_request request;
+	struct mmc_response_r1 r1;
+	int retval;
+
+	mmc_simple_cmd(&request, MMC_SELECT_CARD, mmcinfo.rca, RESPONSE_R1B);
+	retval = mmc_unpack_r1(&request, &r1, 0);
+	if (retval) {
+		return retval;
+	}
+
+	if (mmcinfo.sd) {
+		mmc_simple_cmd(&request, MMC_APP_CMD,  mmcinfo.rca, RESPONSE_R1);
+		retval = mmc_unpack_r1(&request,&r1,0);
+		if (retval) {
+			return retval;
+		}
+		mmc_simple_cmd(&request, SET_BUS_WIDTH, 2, RESPONSE_R1);
+                retval = mmc_unpack_r1(&request,&r1,0);
+                if (retval) {
+			return retval;
+		}
+	}
+	return 0;
+}
+
+/*
+ * Configure card
+ */
+static void mmc_configure_card(void)
+{
+	u32 rate;
+
+	/* Get card info */
+	if (sd2_0)
+		mmcinfo.block_num = (mmcinfo.csd.c_size + 1) << 10;
+	else
+		mmcinfo.block_num = (mmcinfo.csd.c_size + 1) * (1 << (mmcinfo.csd.c_size_mult + 2));
+
+	mmcinfo.block_len = 1 << mmcinfo.csd.read_bl_len;
+
+	/* Fix the clock rate */
+	rate = mmc_tran_speed(mmcinfo.csd.tran_speed);
+	if (rate < MMC_CLOCK_SLOW)
+		rate = MMC_CLOCK_SLOW;
+	if ((mmcinfo.sd == 0) && (rate > MMC_CLOCK_FAST))
+		rate = MMC_CLOCK_FAST;
+        if ((mmcinfo.sd) && (rate > SD_CLOCK_FAST))
+		rate = SD_CLOCK_FAST;
+
+	DEBUG(2,"mmc_configure_card: block_len=%d block_num=%d rate=%d\n", mmcinfo.block_len, mmcinfo.block_num, rate);
+
+	jz_mmc_set_clock(mmcinfo.sd, rate);
+}
+
+/*
+ * State machine routines to initialize card(s)
+ */
+
+/*
+  CIM_SINGLE_CARD_ACQ  (frequency at 400 kHz)
+  --- Must enter from GO_IDLE_STATE ---
+  1. SD_SEND_OP_COND (SD Card) [CMD55] + [CMD41]
+  2. SEND_OP_COND (Full Range) [CMD1]   {optional}
+  3. SEND_OP_COND (Set Range ) [CMD1]
+     If busy, delay and repeat step 2
+  4. ALL_SEND_CID              [CMD2]
+     If timeout, set an error (no cards found)
+  5. SET_RELATIVE_ADDR         [CMD3]
+  6. SEND_CSD                  [CMD9]
+  7. SET_DSR                   [CMD4]    Only call this if (csd.dsr_imp).
+  8. Set clock frequency (check available in csd.tran_speed)
+ */
+
+#define MMC_INIT_DOING   0
+#define MMC_INIT_PASSED  1
+#define MMC_INIT_FAILED  2
+
+static int mmc_init_card_state(struct mmc_request *request)
+{
+	struct mmc_response_r1 r1;
+	struct mmc_response_r3 r3;
+	int retval;
+	int ocr = 0x40300000;
+	int limit_41 = 0;
+
+	DEBUG(2,"mmc_init_card_state\n");
+
+	switch (request->cmd) {
+	case MMC_GO_IDLE_STATE: /* No response to parse */
+		if (mmcinfo.sd)
+			mmc_simple_cmd(request, 8, 0x1aa, RESPONSE_R1);
+		else
+			mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+		break;
+
+	case 8:
+        	retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+		mmc_simple_cmd(request, MMC_APP_CMD,  0, RESPONSE_R1);
+		break;
+
+        case MMC_APP_CMD:
+        	retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+		if (retval & (limit_41 < 100)) {
+			DEBUG(0, "mmc_init_card_state: unable to MMC_APP_CMD error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			limit_41++;
+			mmc_simple_cmd(request, SD_SEND_OP_COND, ocr, RESPONSE_R3);
+		} else if (limit_41 < 100) {
+			limit_41++;		
+			mmc_simple_cmd(request, SD_SEND_OP_COND, ocr, RESPONSE_R3);
+		} else{
+			/* reset the card to idle*/
+			mmc_simple_cmd(request, MMC_GO_IDLE_STATE, 0, RESPONSE_NONE);
+			mmcinfo.sd = 0;
+		}
+		break;
+
+        case SD_SEND_OP_COND:
+                retval = mmc_unpack_r3(request, &r3);
+                if (retval) {
+                  /* Try MMC card */
+                    mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+                    break;
+		}
+
+                DEBUG(2,"mmc_init_card_state: read ocr value = 0x%08x\n", r3.ocr);
+		
+		if(!(r3.ocr & MMC_CARD_BUSY || ocr == 0)){
+			udelay(10000);
+			mmc_simple_cmd(request, MMC_APP_CMD, 0, RESPONSE_R1);
+		}
+		else {
+		  /* Set the data bus width to 4 bits */
+                  mmcinfo.sd = 1; /* SD Card ready */
+                  mmcinfo.state = CARD_STATE_READY;
+		  mmc_simple_cmd(request, MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID);
+		}
+		break;
+
+	case MMC_SEND_OP_COND:
+		retval = mmc_unpack_r3(request, &r3);
+		if (retval) {
+			DEBUG(0,"mmc_init_card_state: failed SEND_OP_COND error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+
+		DEBUG(2,"mmc_init_card_state: read ocr value = 0x%08x\n", r3.ocr);
+		if (!(r3.ocr & MMC_CARD_BUSY)) {
+	                mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+		}
+		else {
+		        mmcinfo.sd = 0; /* MMC Card ready */
+			mmcinfo.state = CARD_STATE_READY;
+			mmc_simple_cmd(request, MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID);
+		}
+		break;
+		
+	case MMC_ALL_SEND_CID: 
+		retval = mmc_unpack_cid( request, &mmcinfo.cid );
+		mmc_dev.if_type = IF_TYPE_MMC;
+		mmc_dev.part_type = PART_TYPE_DOS;
+		mmc_dev.dev = 0;
+		mmc_dev.lun = 0;
+		mmc_dev.type = 0;
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_dev.blksz = 512;
+		mmc_dev.lba = 0x10000;
+		mmc_dev.removable = 0;
+		
+		/*FIXME:ignore CRC error for CMD2/CMD9/CMD10 */
+		if ( retval && (retval != MMC_ERROR_CRC)) {
+			DEBUG(0,"mmc_init_card_state: unable to ALL_SEND_CID error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		mmcinfo.state = CARD_STATE_IDENT;
+		if(mmcinfo.sd)
+			mmc_simple_cmd(request, MMC_SET_RELATIVE_ADDR, 0, RESPONSE_R6);
+                else
+			mmc_simple_cmd(request, MMC_SET_RELATIVE_ADDR, ID_TO_RCA(mmcinfo.id) << 16, RESPONSE_R1);
+		break;
+
+        case MMC_SET_RELATIVE_ADDR:
+	        if (mmcinfo.sd)	{
+			retval = mmc_unpack_r6(request, &r1, mmcinfo.state, &mmcinfo.rca);
+			mmcinfo.rca = mmcinfo.rca << 16; 
+			DEBUG(2, "mmc_init_card_state: Get RCA from SD: 0x%04x Status: %x\n", mmcinfo.rca, r1.status);
+                } else {
+			retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+			mmcinfo.rca = ID_TO_RCA(mmcinfo.id) << 16;
+	        }
+		if (retval) {
+			DEBUG(0, "mmc_init_card_state: unable to SET_RELATIVE_ADDR error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		
+		mmcinfo.state = CARD_STATE_STBY;
+                mmc_simple_cmd(request, MMC_SEND_CSD, mmcinfo.rca, RESPONSE_R2_CSD);
+		
+		break;
+        
+	case MMC_SEND_CSD:
+		retval = mmc_unpack_csd(request, &mmcinfo.csd);
+			mmc_csd_t *csd = (mmc_csd_t *)retval;
+			memcpy(&mmc_csd, csd, sizeof(csd));
+			mmc_ready = 1;
+
+			printf("MMC card is ready\n");
+			/* FIXME add verbose printout for csd */
+                
+		/*FIXME:ignore CRC error for CMD2/CMD9/CMD10 */
+	        if (retval && (retval != MMC_ERROR_CRC)) {
+			DEBUG(0, "mmc_init_card_state: unable to SEND_CSD error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		if (mmcinfo.csd.dsr_imp) {
+			DEBUG(0, "mmc_init_card_state: driver doesn't support setting DSR\n");
+		}
+		mmc_configure_card();
+		return MMC_INIT_PASSED;
+		
+	default:
+		DEBUG(0, "mmc_init_card_state: error!  Illegal last cmd %d\n", request->cmd);
+		return MMC_INIT_FAILED;
+	}
+
+	return MMC_INIT_DOING;
+}
+
+int mmc_init_card(void)
+{
+	struct mmc_request request;
+	int retval;
+
+	mmc_simple_cmd(&request, MMC_CIM_RESET, 0, RESPONSE_NONE); /* reset card */
+	mmc_simple_cmd(&request, MMC_GO_IDLE_STATE, 0, RESPONSE_NONE);
+	mmcinfo.sd = 1;  /* assuming a SD card */
+
+	while ((retval = mmc_init_card_state(&request)) == MMC_INIT_DOING)
+		;
+
+	if (retval == MMC_INIT_PASSED)
+		return MMC_NO_ERROR;
+	else
+		return MMC_NO_RESPONSE;
+}
+
+int mmc_legacy_init(int verbose)
+{
+	if (!__msc_card_detected())
+		return 1;
+	
+	printf("MMC card found\n");
+ 
+	/* Step-1: init GPIO */
+	__gpio_as_msc();
+
+	__msc_init_io();
+
+	/* Step-2: turn on power of card */
+	__msc_enable_power();
+
+	/* Step-3: Reset MSC Controller. */
+	__msc_reset();
+
+	/* Step-3: mask all IRQs. */
+	MMC_IRQ_MASK();	
+
+	/* Step-4: stop MMC/SD clock */
+	jz_mmc_stop_clock();
+	mmc_init_card();
+	mmc_select_card();
+
+	mmc_dev.block_read = mmc_bread; 
+	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
+
+	return 0;
+}
+
+int mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+int mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000) {
+	return 1; 
+	} 
+	return 0;
+}
+/*
+ * Debugging functions
+ */
+
+static char * mmc_result_strings[] = {
+	"NO_RESPONSE",
+	"NO_ERROR",
+	"ERROR_OUT_OF_RANGE",
+	"ERROR_ADDRESS",
+	"ERROR_BLOCK_LEN",
+	"ERROR_ERASE_SEQ",
+	"ERROR_ERASE_PARAM",
+	"ERROR_WP_VIOLATION",
+	"ERROR_CARD_IS_LOCKED",
+	"ERROR_LOCK_UNLOCK_FAILED",
+	"ERROR_COM_CRC",
+	"ERROR_ILLEGAL_COMMAND",
+	"ERROR_CARD_ECC_FAILED",
+	"ERROR_CC",
+	"ERROR_GENERAL",
+	"ERROR_UNDERRUN",
+	"ERROR_OVERRUN",
+	"ERROR_CID_CSD_OVERWRITE",
+	"ERROR_STATE_MISMATCH",
+	"ERROR_HEADER_MISMATCH",
+	"ERROR_TIMEOUT",
+	"ERROR_CRC",
+	"ERROR_DRIVER_FAILURE",
+};
+
+char * mmc_result_to_string(int i)
+{
+	return mmc_result_strings[i+1];
+}
+
+static char * card_state_strings[] = {
+	"empty",
+	"idle",
+	"ready",
+	"ident",
+	"stby",
+	"tran",
+	"data",
+	"rcv",
+	"prg",
+	"dis",
+};
+
+static inline char * card_state_to_string(int i)
+{
+	return card_state_strings[i+1];
+}
+
+/*
+ * Utility functions
+ */
+
+#define PARSE_U32(_buf,_index) \
+	(((u32)_buf[_index]) << 24) | (((u32)_buf[_index+1]) << 16) | \
+        (((u32)_buf[_index+2]) << 8) | ((u32)_buf[_index+3]);
+
+#define PARSE_U16(_buf,_index) \
+	(((u16)_buf[_index]) << 8) | ((u16)_buf[_index+1]);
+
+int mmc_unpack_csd(struct mmc_request *request, struct mmc_csd *csd)
+{
+	u8 *buf = request->response;
+	int num = 0;
+	
+	if (request->result)
+		return request->result;
+
+	csd->csd_structure      = (buf[1] & 0xc0) >> 6;
+	if (csd->csd_structure)
+		sd2_0 = 1;
+	else
+		sd2_0 = 0;
+	
+	switch (csd->csd_structure) {
+	case 0 :
+		csd->taac               = buf[2];
+		csd->nsac               = buf[3];
+		csd->tran_speed         = buf[4];
+		csd->ccc                = (((u16)buf[5]) << 4) | ((buf[6] & 0xf0) >> 4);
+		csd->read_bl_len        = buf[6] & 0x0f;
+		/* for support 2GB card*/
+		if (csd->read_bl_len >= 10) 
+		{
+			num = csd->read_bl_len - 9;
+			csd->read_bl_len = 9;
+		}
+		
+		csd->read_bl_partial    = (buf[7] & 0x80) ? 1 : 0;
+		csd->write_blk_misalign = (buf[7] & 0x40) ? 1 : 0;
+		csd->read_blk_misalign  = (buf[7] & 0x20) ? 1 : 0;
+		csd->dsr_imp            = (buf[7] & 0x10) ? 1 : 0;
+		csd->c_size             = ((((u16)buf[7]) & 0x03) << 10) | (((u16)buf[8]) << 2) | (((u16)buf[9]) & 0xc0) >> 6;
+
+		if (num)
+			csd->c_size = csd->c_size << num;
+		
+		
+		csd->vdd_r_curr_min     = (buf[9] & 0x38) >> 3;
+		csd->vdd_r_curr_max     = buf[9] & 0x07;
+		csd->vdd_w_curr_min     = (buf[10] & 0xe0) >> 5;
+		csd->vdd_w_curr_max     = (buf[10] & 0x1c) >> 2;
+		csd->c_size_mult        = ((buf[10] & 0x03) << 1) | ((buf[11] & 0x80) >> 7);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			csd->erase.v22.sector_size    = (buf[11] & 0x7c) >> 2;
+			csd->erase.v22.erase_grp_size = ((buf[11] & 0x03) << 3) | ((buf[12] & 0xe0) >> 5);
+
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			csd->erase.v31.erase_grp_size = (buf[11] & 0x7c) >> 2;
+			csd->erase.v31.erase_grp_mult = ((buf[11] & 0x03) << 3) | ((buf[12] & 0xe0) >> 5);
+			break;
+		}
+		csd->wp_grp_size        = buf[12] & 0x1f;
+		csd->wp_grp_enable      = (buf[13] & 0x80) ? 1 : 0;
+		csd->default_ecc        = (buf[13] & 0x60) >> 5;
+		csd->r2w_factor         = (buf[13] & 0x1c) >> 2;
+		csd->write_bl_len       = ((buf[13] & 0x03) << 2) | ((buf[14] & 0xc0) >> 6);
+		if (csd->write_bl_len >= 10)
+			csd->write_bl_len = 9;
+		
+		csd->write_bl_partial   = (buf[14] & 0x20) ? 1 : 0;
+		csd->file_format_grp    = (buf[15] & 0x80) ? 1 : 0;
+		csd->copy               = (buf[15] & 0x40) ? 1 : 0;
+		csd->perm_write_protect = (buf[15] & 0x20) ? 1 : 0;
+		csd->tmp_write_protect  = (buf[15] & 0x10) ? 1 : 0;
+		csd->file_format        = (buf[15] & 0x0c) >> 2;
+		csd->ecc                = buf[15] & 0x03;
+		
+		DEBUG(2,"  csd_structure=%d  spec_vers=%d  taac=%02x  nsac=%02x  tran_speed=%02x\n"
+		      "  ccc=%04x  read_bl_len=%d  read_bl_partial=%d  write_blk_misalign=%d\n"
+		      "  read_blk_misalign=%d  dsr_imp=%d  c_size=%d  vdd_r_curr_min=%d\n"
+		      "  vdd_r_curr_max=%d  vdd_w_curr_min=%d  vdd_w_curr_max=%d  c_size_mult=%d\n"
+		      "  wp_grp_size=%d  wp_grp_enable=%d  default_ecc=%d  r2w_factor=%d\n"
+		      "  write_bl_len=%d  write_bl_partial=%d  file_format_grp=%d  copy=%d\n"
+		      "  perm_write_protect=%d  tmp_write_protect=%d  file_format=%d  ecc=%d\n",
+		      csd->csd_structure, csd->spec_vers, 
+		      csd->taac, csd->nsac, csd->tran_speed,
+		      csd->ccc, csd->read_bl_len, 
+		      csd->read_bl_partial, csd->write_blk_misalign,
+		      csd->read_blk_misalign, csd->dsr_imp, 
+		      csd->c_size, csd->vdd_r_curr_min,
+		      csd->vdd_r_curr_max, csd->vdd_w_curr_min, 
+		      csd->vdd_w_curr_max, csd->c_size_mult,
+		      csd->wp_grp_size, csd->wp_grp_enable,
+		      csd->default_ecc, csd->r2w_factor, 
+		      csd->write_bl_len, csd->write_bl_partial,
+		      csd->file_format_grp, csd->copy, 
+		      csd->perm_write_protect, csd->tmp_write_protect,
+		      csd->file_format, csd->ecc);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			DEBUG(2," V22 sector_size=%d erase_grp_size=%d\n", 
+			      csd->erase.v22.sector_size, 
+			      csd->erase.v22.erase_grp_size);
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			DEBUG(2," V31 erase_grp_size=%d erase_grp_mult=%d\n", 
+			      csd->erase.v31.erase_grp_size,
+			      csd->erase.v31.erase_grp_mult);
+			break;
+			
+		}
+		break;	
+		
+	case 1 :
+		csd->taac               = 0;
+		csd->nsac               = 0;
+		csd->tran_speed         = buf[4];
+		csd->ccc                = (((u16)buf[5]) << 4) | ((buf[6] & 0xf0) >> 4);
+
+		csd->read_bl_len        = 9;
+		csd->read_bl_partial    = 0;
+		csd->write_blk_misalign = 0;
+		csd->read_blk_misalign  = 0;
+		csd->dsr_imp            = (buf[7] & 0x10) ? 1 : 0;
+		csd->c_size             = ((((u16)buf[8]) & 0x3f) << 16) | (((u16)buf[9]) << 8) | ((u16)buf[10]) ;
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			csd->erase.v22.sector_size    = 0x7f;
+			csd->erase.v22.erase_grp_size = 0;
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			csd->erase.v31.erase_grp_size = 0x7f;
+			csd->erase.v31.erase_grp_mult = 0;
+			break;
+		}
+		csd->wp_grp_size        = 0;
+		csd->wp_grp_enable      = 0;
+		csd->default_ecc        = (buf[13] & 0x60) >> 5;
+		csd->r2w_factor         = 4;/* Unused */
+		csd->write_bl_len       = 9;
+		
+		csd->write_bl_partial   = 0;
+		csd->file_format_grp    = 0;
+		csd->copy               = (buf[15] & 0x40) ? 1 : 0;
+		csd->perm_write_protect = (buf[15] & 0x20) ? 1 : 0;
+		csd->tmp_write_protect  = (buf[15] & 0x10) ? 1 : 0;
+		csd->file_format        = 0;
+		csd->ecc                = buf[15] & 0x03;
+		
+		DEBUG(2,"  csd_structure=%d  spec_vers=%d  taac=%02x  nsac=%02x  tran_speed=%02x\n"
+		      "  ccc=%04x  read_bl_len=%d  read_bl_partial=%d  write_blk_misalign=%d\n"
+		      "  read_blk_misalign=%d  dsr_imp=%d  c_size=%d  vdd_r_curr_min=%d\n"
+		      "  vdd_r_curr_max=%d  vdd_w_curr_min=%d  vdd_w_curr_max=%d  c_size_mult=%d\n"
+		      "  wp_grp_size=%d  wp_grp_enable=%d  default_ecc=%d  r2w_factor=%d\n"
+		      "  write_bl_len=%d  write_bl_partial=%d  file_format_grp=%d  copy=%d\n"
+		      "  perm_write_protect=%d  tmp_write_protect=%d  file_format=%d  ecc=%d\n",
+		      csd->csd_structure, csd->spec_vers, 
+		      csd->taac, csd->nsac, csd->tran_speed,
+		      csd->ccc, csd->read_bl_len, 
+		      csd->read_bl_partial, csd->write_blk_misalign,
+		      csd->read_blk_misalign, csd->dsr_imp, 
+		      csd->c_size, csd->vdd_r_curr_min,
+		      csd->vdd_r_curr_max, csd->vdd_w_curr_min, 
+		      csd->vdd_w_curr_max, csd->c_size_mult,
+		      csd->wp_grp_size, csd->wp_grp_enable,
+		      csd->default_ecc, csd->r2w_factor, 
+		      csd->write_bl_len, csd->write_bl_partial,
+		      csd->file_format_grp, csd->copy, 
+		      csd->perm_write_protect, csd->tmp_write_protect,
+		      csd->file_format, csd->ecc);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			DEBUG(2," V22 sector_size=%d erase_grp_size=%d\n", 
+			      csd->erase.v22.sector_size, 
+			      csd->erase.v22.erase_grp_size);
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			DEBUG(2," V31 erase_grp_size=%d erase_grp_mult=%d\n", 
+			      csd->erase.v31.erase_grp_size,
+			      csd->erase.v31.erase_grp_mult);
+			break;
+		}
+	}
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+
+	return 0;
+}
+
+int mmc_unpack_r1(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state)
+{
+	u8 *buf = request->response;
+
+	if (request->result)        return request->result;
+
+	r1->cmd    = buf[0];
+	r1->status = PARSE_U32(buf,1);
+
+	DEBUG(2, "mmc_unpack_r1: cmd=%d status=%08x\n", r1->cmd, r1->status);
+
+	if (R1_STATUS(r1->status)) {
+		if (r1->status & R1_OUT_OF_RANGE)       return MMC_ERROR_OUT_OF_RANGE;
+		if (r1->status & R1_ADDRESS_ERROR)      return MMC_ERROR_ADDRESS;
+		if (r1->status & R1_BLOCK_LEN_ERROR)    return MMC_ERROR_BLOCK_LEN;
+		if (r1->status & R1_ERASE_SEQ_ERROR)    return MMC_ERROR_ERASE_SEQ;
+		if (r1->status & R1_ERASE_PARAM)        return MMC_ERROR_ERASE_PARAM;
+		if (r1->status & R1_WP_VIOLATION)       return MMC_ERROR_WP_VIOLATION;
+		/*if (r1->status & R1_CARD_IS_LOCKED)     return MMC_ERROR_CARD_IS_LOCKED; */
+		if (r1->status & R1_LOCK_UNLOCK_FAILED) return MMC_ERROR_LOCK_UNLOCK_FAILED;
+		if (r1->status & R1_COM_CRC_ERROR)      return MMC_ERROR_COM_CRC;
+		if (r1->status & R1_ILLEGAL_COMMAND)    return MMC_ERROR_ILLEGAL_COMMAND;
+		if (r1->status & R1_CARD_ECC_FAILED)    return MMC_ERROR_CARD_ECC_FAILED;
+		if (r1->status & R1_CC_ERROR)           return MMC_ERROR_CC;
+		if (r1->status & R1_ERROR)              return MMC_ERROR_GENERAL;
+		if (r1->status & R1_UNDERRUN)           return MMC_ERROR_UNDERRUN;
+		if (r1->status & R1_OVERRUN)            return MMC_ERROR_OVERRUN;
+		if (r1->status & R1_CID_CSD_OVERWRITE)  return MMC_ERROR_CID_CSD_OVERWRITE;
+	}
+
+	if (buf[0] != request->cmd) return MMC_ERROR_HEADER_MISMATCH;
+
+	/* This should be last - it's the least dangerous error */
+
+	return 0;
+}
+
+int mmc_unpack_scr(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, u32 *scr)
+{
+        u8 *buf = request->response;
+	if (request->result)        return request->result;
+        
+        *scr = PARSE_U32(buf, 5); /* Save SCR returned by the SD Card */
+        return mmc_unpack_r1(request, r1, state);
+        
+}
+
+int mmc_unpack_r6(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, int *rca)
+{
+	u8 *buf = request->response;
+
+	if (request->result)        return request->result;
+        
+        *rca = PARSE_U16(buf,1);  /* Save RCA returned by the SD Card */
+        
+        *(buf+1) = 0;
+        *(buf+2) = 0;
+        
+        return mmc_unpack_r1(request, r1, state);
+}   
+
+int mmc_unpack_cid(struct mmc_request *request, struct mmc_cid *cid)
+{
+	u8 *buf = request->response;
+	int i;
+
+	if (request->result) return request->result;
+
+	cid->mid = buf[1];
+	cid->oid = PARSE_U16(buf,2);
+	for (i = 0 ; i < 6 ; i++)
+		cid->pnm[i] = buf[4+i];
+	cid->pnm[6] = 0;
+	cid->prv = buf[10];
+	cid->psn = PARSE_U32(buf,11);
+	cid->mdt = buf[15];
+	
+	DEBUG(2,"mmc_unpack_cid: mid=%d oid=%d pnm=%s prv=%d.%d psn=%08x mdt=%d/%d\n",
+	      cid->mid, cid->oid, cid->pnm, 
+	      (cid->prv>>4), (cid->prv&0xf), 
+	      cid->psn, (cid->mdt>>4), (cid->mdt&0xf)+1997);
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+      	return 0;
+}
+
+int mmc_unpack_r3(struct mmc_request *request, struct mmc_response_r3 *r3)
+{
+	u8 *buf = request->response;
+
+	if (request->result) return request->result;
+
+	r3->ocr = PARSE_U32(buf,1);
+	DEBUG(2,"mmc_unpack_r3: ocr=%08x\n", r3->ocr);
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+	return 0;
+}
+
+#define KBPS 1
+#define MBPS 1000
+
+static u32 ts_exp[] = { 100*KBPS, 1*MBPS, 10*MBPS, 100*MBPS, 0, 0, 0, 0 };
+static u32 ts_mul[] = { 0,    1000, 1200, 1300, 1500, 2000, 2500, 3000, 
+			3500, 4000, 4500, 5000, 5500, 6000, 7000, 8000 };
+
+u32 mmc_tran_speed(u8 ts)
+{
+	u32 rate = ts_exp[(ts & 0x7)] * ts_mul[(ts & 0x78) >> 3];
+
+	if (rate <= 0) {
+		DEBUG(0, "mmc_tran_speed: error - unrecognized speed 0x%02x\n", ts);
+		return 1;
+	}
+
+	return rate;
+}
+
+void mmc_send_cmd(struct mmc_request *request, int cmd, u32 arg, 
+		   u16 nob, u16 block_len, enum mmc_rsp_t rtype, u8 *buffer)
+{
+	request->cmd       = cmd;
+	request->arg       = arg;
+	request->rtype     = rtype;
+	request->nob       = nob;
+	request->block_len = block_len;
+	request->buffer    = buffer;
+	request->cnt       = nob * block_len;
+
+	jz_mmc_exec_cmd(request);
+}
+
+#endif	/* CONFIG_MMC */
+#endif  /* CONFIG_JZ4740 & CONFIG_JZ4730 */
diff --git a/cpu/mips/jz_mmc.h b/cpu/mips/jz_mmc.h
new file mode 100644
index 0000000..7f0fa1f
--- /dev/null
+++ b/cpu/mips/jz_mmc.h
@@ -0,0 +1,113 @@
+/*
+ *  linux/drivers/mmc/jz_mmc.h
+ *
+ *  Author: Vladimir Shebordaev, Igor Oblakov
+ *  Copyright:  MontaVista Software Inc.
+ *
+ *  $Id: jz_mmc.h,v 1.3 2007-06-15 08:04:20 jlwei Exp $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_JZMMC_H__
+#define __MMC_JZMMC_H__
+
+#include "mmc_protocol.h"
+
+#define MMC_DEBUG_LEVEL		0		/* Enable Debug: 0 - no debug */
+
+#define MMC_BLOCK_SIZE		512		/* MMC/SD Block Size */
+
+#define ID_TO_RCA(x) ((x)+1)
+
+#define MMC_OCR_ARG		0x00ff8000	/* Argument of OCR */
+
+enum mmc_result_t {
+	MMC_NO_RESPONSE        = -1,
+	MMC_NO_ERROR           = 0,
+	MMC_ERROR_OUT_OF_RANGE,
+	MMC_ERROR_ADDRESS,
+	MMC_ERROR_BLOCK_LEN,
+	MMC_ERROR_ERASE_SEQ,
+	MMC_ERROR_ERASE_PARAM,
+	MMC_ERROR_WP_VIOLATION,
+	MMC_ERROR_CARD_IS_LOCKED,
+	MMC_ERROR_LOCK_UNLOCK_FAILED,
+	MMC_ERROR_COM_CRC,
+	MMC_ERROR_ILLEGAL_COMMAND,
+	MMC_ERROR_CARD_ECC_FAILED,
+	MMC_ERROR_CC,
+	MMC_ERROR_GENERAL,
+	MMC_ERROR_UNDERRUN,
+	MMC_ERROR_OVERRUN,
+	MMC_ERROR_CID_CSD_OVERWRITE,
+	MMC_ERROR_STATE_MISMATCH,
+	MMC_ERROR_HEADER_MISMATCH,
+	MMC_ERROR_TIMEOUT,
+	MMC_ERROR_CRC,
+	MMC_ERROR_DRIVER_FAILURE,
+};
+
+/* the information structure of MMC/SD Card */
+typedef struct MMC_INFO
+{
+	int             id;     /* Card index */
+        int             sd;     /* MMC or SD card */
+        int             rca;    /* RCA */
+        u32             scr;    /* SCR 63:32*/        
+	int             flags;  /* Ejected, inserted */
+	enum card_state state;  /* empty, ident, ready, whatever */
+
+	/* Card specific information */
+	struct mmc_cid  cid;
+	struct mmc_csd  csd;
+	u32             block_num;
+	u32             block_len;
+	u32             erase_unit;
+} mmc_info;
+
+mmc_info mmcinfo;
+
+struct mmc_request {
+	int               index;      /* Slot index - used for CS lines */
+	int               cmd;        /* Command to send */
+	u32               arg;        /* Argument to send */
+	enum mmc_rsp_t    rtype;      /* Response type expected */
+
+	/* Data transfer (these may be modified at the low level) */
+	u16               nob;        /* Number of blocks to transfer*/
+	u16               block_len;  /* Block length */
+	u8               *buffer;     /* Data buffer */
+	u32               cnt;        /* Data length, for PIO */
+
+	/* Results */
+	u8                response[18]; /* Buffer to store response - CRC is optional */
+	enum mmc_result_t result;
+};
+
+char * mmc_result_to_string(int);
+int    mmc_unpack_csd(struct mmc_request *request, struct mmc_csd *csd);
+int    mmc_unpack_r1(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state);
+int    mmc_unpack_r6(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, int *rca);
+int    mmc_unpack_scr(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, u32 *scr);
+int    mmc_unpack_cid(struct mmc_request *request, struct mmc_cid *cid);
+int    mmc_unpack_r3(struct mmc_request *request, struct mmc_response_r3 *r3);
+
+void   mmc_send_cmd(struct mmc_request *request, int cmd, u32 arg, 
+		     u16 nob, u16 block_len, enum mmc_rsp_t rtype, u8 *buffer);
+u32    mmc_tran_speed(u8 ts);
+void   jz_mmc_set_clock(int sd, u32 rate);
+void   jz_mmc_hardware_init(void);
+
+static inline void mmc_simple_cmd(struct mmc_request *request, int cmd, u32 arg, enum mmc_rsp_t rtype)
+{
+	mmc_send_cmd( request, cmd, arg, 0, 0, rtype, 0);
+}
+
+int mmc_legacy_init(int verbose);
+int mmc_read(ulong src, uchar *dst, int size);
+int mmc_write(uchar *src, ulong dst, int size);
+int mmc2info(ulong addr);
+
+#endif /* __MMC_JZMMC_H__ */
diff --git a/cpu/mips/jz_serial.c b/cpu/mips/jz_serial.c
new file mode 100644
index 0000000..446ffa9
--- /dev/null
+++ b/cpu/mips/jz_serial.c
@@ -0,0 +1,167 @@
+/*
+ * Jz47xx UART support
+ *
+ * Hardcoded to UART 0 for now
+ * Options also hardcoded to 8N1
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750) \
+	|| defined(CONFIG_JZ4750D) || defined(CONFIG_JZ5730)
+
+#include <common.h>
+
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+#if defined(CONFIG_JZ4750D)
+#include <asm/jz4750d.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#undef UART_BASE
+#ifndef CONFIG_SYS_UART_BASE
+#define UART_BASE  UART0_BASE
+#else
+#define UART_BASE  CONFIG_SYS_UART_BASE
+#endif
+
+/******************************************************************************
+*
+* serial_init - initialize a channel
+*
+* This routine initializes the number of data bits, parity
+* and set the selected baud rate. Interrupts are disabled.
+* Set the modem control signals if the option is selected.
+*
+* RETURNS: N/A
+*/
+
+int serial_init (void)
+{
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+	volatile u8 *uart_fcr = (volatile u8 *)(UART_BASE + OFF_FCR);
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_ier = (volatile u8 *)(UART_BASE + OFF_IER);
+	volatile u8 *uart_sircr = (volatile u8 *)(UART_BASE + OFF_SIRCR);
+
+	/* Disable port interrupts while changing hardware */
+	*uart_ier = 0;
+
+	/* Disable UART unit function */
+	*uart_fcr = ~UART_FCR_UUE;
+
+	/* Set both receiver and transmitter in UART mode (not SIR) */
+	*uart_sircr = ~(SIRCR_RSIRE | SIRCR_TSIRE);
+
+	/* Set databits, stopbits and parity. (8-bit data, 1 stopbit, no parity) */
+	*uart_lcr = UART_LCR_WLEN_8 | UART_LCR_STOP_1;
+	
+	/* Set baud rate */
+	serial_setbrg();
+	
+	/* Enable UART unit, enable and clear FIFO */
+	*uart_fcr = UART_FCR_UUE | UART_FCR_FE | UART_FCR_TFLS | UART_FCR_RFLS;
+#endif
+	return 0;
+}
+
+void serial_setbrg (void)
+{
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_dlhr = (volatile u8 *)(UART_BASE + OFF_DLHR);
+	volatile u8 *uart_dllr = (volatile u8 *)(UART_BASE + OFF_DLLR);
+	u32 baud_div, tmp;
+
+#if defined(CONFIG_FPGA)
+	baud_div = (CONFIG_EXTAL / CFG_DIV) / 16 / CONFIG_BAUDRATE;
+#elif defined(CONFIG_JZ4750) || defined(CONFIG_JZ4750D)
+	if (CONFIG_EXTAL > 16000000) {
+		REG_CPM_CPCCR |= CPM_CPCCR_ECS;
+		baud_div = CONFIG_EXTAL / 32 / CONFIG_BAUDRATE;
+	} else {
+		REG_CPM_CPCCR &= ~CPM_CPCCR_ECS;
+		baud_div = CONFIG_EXTAL / 16 / CONFIG_BAUDRATE;
+	}
+#else /* CONFIG_JZ4740 | CONFIG_JZ4730 */
+	baud_div = CONFIG_EXTAL / 16 / CONFIG_BAUDRATE;
+#endif
+	tmp = *uart_lcr;
+	tmp |= UART_LCR_DLAB;
+	*uart_lcr = tmp;
+
+	*uart_dlhr = (baud_div >> 8) & 0xff;
+	*uart_dllr = baud_div & 0xff;
+
+	tmp &= ~UART_LCR_DLAB;
+	*uart_lcr = tmp;
+}
+
+void serial_putc (const char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART_BASE + OFF_TDR);
+
+	if (c == '\n') serial_putc ('\r');
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UART_LSR_TDRQ | UART_LSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int serial_getc (void)
+{
+	volatile u8 *uart_rdr = (volatile u8 *)(UART_BASE + OFF_RDR);
+
+	while (!serial_tstc());
+
+	return *uart_rdr;
+}
+
+int serial_tstc (void)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+
+	if (*uart_lsr & UART_LSR_DR) {
+		/* Data in rfifo */
+		return (1);
+	}
+	return 0;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ4740 || CONFIG_JZ4750 || CONFIG_JZ45730 */
diff --git a/cpu/mips/mmc_protocol.h b/cpu/mips/mmc_protocol.h
new file mode 100644
index 0000000..9028cdf
--- /dev/null
+++ b/cpu/mips/mmc_protocol.h
@@ -0,0 +1,273 @@
+/*
+**********************************************************************
+*
+*                            uC/MMC
+*
+*             (c) Copyright 2005 - 2007, Ingenic Semiconductor, Inc
+*                      All rights reserved.
+*
+***********************************************************************
+
+----------------------------------------------------------------------
+File        : mmc_protocol.h 
+Purpose     : MMC protocol definitions.
+
+----------------------------------------------------------------------
+Version-Date-----Author-Explanation
+----------------------------------------------------------------------
+1.00.00 20060831 WeiJianli     First release
+
+----------------------------------------------------------------------
+Known problems or limitations with current version
+----------------------------------------------------------------------
+(none)
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef __MMC_PROTOCOL__
+#define __MMC_PROTOCOL__
+
+/* Standard MMC/SD clock speeds */
+#define MMC_CLOCK_SLOW    400000      /* 400 kHz for initial setup */
+#define MMC_CLOCK_FAST  20000000      /* 20 MHz for maximum for normal operation */
+#define SD_CLOCK_FAST   24000000      /* 24 MHz for SD Cards */
+ 
+/* Extra MMC commands for state control */
+/* Use negative numbers to disambiguate */
+#define MMC_CIM_RESET            -1
+
+/* Standard MMC commands (3.1)           type  argument     response */
+   /* class 1 */
+#define	MMC_GO_IDLE_STATE         0   /* bc                          */
+#define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
+#define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
+#define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
+#define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
+#define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
+#define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
+#define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
+#define MMC_SEND_STATUS	         13   /* ac   [31:16] RCA        R1  */
+#define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+
+  /* class 2 */
+#define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
+#define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
+#define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
+
+  /* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
+
+  /* class 4 */
+#define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_BLOCK          24   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
+#define MMC_PROGRAM_CID          26   /* adtc                    R1  */
+#define MMC_PROGRAM_CSD          27   /* adtc                    R1  */
+
+  /* class 6 */
+#define MMC_SET_WRITE_PROT       28   /* ac   [31:0] data addr   R1b */
+#define MMC_CLR_WRITE_PROT       29   /* ac   [31:0] data addr   R1b */
+#define MMC_SEND_WRITE_PROT      30   /* adtc [31:0] wpdata addr R1  */
+
+  /* class 5 */
+#define MMC_ERASE_GROUP_START    35   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE_GROUP_END      36   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE                37   /* ac                      R1b */
+
+  /* class 9 */
+#define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
+#define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */
+
+  /* class 7 */
+#define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */
+
+  /* class 8 */
+#define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
+#define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1b */
+
+  /* SD class */
+#define SD_SEND_OP_COND          41   /* bcr  [31:0] OCR         R3  */
+#define SET_BUS_WIDTH            6    /* ac   [1:0] bus width    R1  */    
+#define SEND_SCR                 51   /* adtc [31:0] staff       R1  */   
+
+/* Don't change the order of these; they are used in dispatch tables */
+enum mmc_rsp_t {
+	RESPONSE_NONE   = 0,
+	RESPONSE_R1     = 1,
+	RESPONSE_R1B    = 2,
+	RESPONSE_R2_CID = 3,
+	RESPONSE_R2_CSD  = 4,
+	RESPONSE_R3      = 5,
+	RESPONSE_R4      = 6,
+	RESPONSE_R5      = 7,
+        RESPONSE_R6      = 8,
+};
+
+
+/*
+  MMC status in R1
+  Type
+  	e : error bit
+	s : status bit
+	r : detected and set for the actual command response
+	x : detected and set during command execution. the host must poll
+            the card by sending status command in order to read these bits.
+  Clear condition
+  	a : according to the card state
+	b : always related to the previous command. Reception of
+            a valid command will clear it (with a delay of one command)
+	c : clear by read
+ */
+
+#define R1_OUT_OF_RANGE		(1 << 31)	/* er, c */
+#define R1_ADDRESS_ERROR	(1 << 30)	/* erx, c */
+#define R1_BLOCK_LEN_ERROR	(1 << 29)	/* er, c */
+#define R1_ERASE_SEQ_ERROR      (1 << 28)	/* er, c */
+#define R1_ERASE_PARAM		(1 << 27)	/* ex, c */
+#define R1_WP_VIOLATION		(1 << 26)	/* erx, c */
+#define R1_CARD_IS_LOCKED	(1 << 25)	/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	(1 << 24)	/* erx, c */
+#define R1_COM_CRC_ERROR	(1 << 23)	/* er, b */
+#define R1_ILLEGAL_COMMAND	(1 << 22)	/* er, b */
+#define R1_CARD_ECC_FAILED	(1 << 21)	/* ex, c */
+#define R1_CC_ERROR		(1 << 20)	/* erx, c */
+#define R1_ERROR		(1 << 19)	/* erx, c */
+#define R1_UNDERRUN		(1 << 18)	/* ex, c */
+#define R1_OVERRUN		(1 << 17)	/* ex, c */
+#define R1_CID_CSD_OVERWRITE	(1 << 16)	/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	(1 << 15)	/* sx, c */
+#define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
+#define R1_ERASE_RESET		(1 << 13)	/* sr, c */
+#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)    	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
+#define R1_APP_CMD		(1 << 7)	/* sr, c */
+
+enum card_state {
+	CARD_STATE_EMPTY = -1,
+	CARD_STATE_IDLE	 = 0,
+	CARD_STATE_READY = 1,
+	CARD_STATE_IDENT = 2,
+	CARD_STATE_STBY	 = 3,
+	CARD_STATE_TRAN	 = 4,
+	CARD_STATE_DATA	 = 5,
+	CARD_STATE_RCV	 = 6,
+	CARD_STATE_PRG	 = 7,
+	CARD_STATE_DIS	 = 8,
+};
+
+/* These are unpacked versions of the actual responses */
+
+ struct mmc_response_r1 {
+	u8  cmd;
+	u32 status;
+};
+
+typedef struct mmc_cid {
+	u8  mid;
+	u16 oid;
+	u8  pnm[7];   /* Product name (we null-terminate) */
+	u8  prv;
+	u32 psn;
+	u8  mdt;
+}mmc_cid_t;
+
+typedef struct mmc_csd {
+	u8  csd_structure;
+	u8  spec_vers;
+	u8  taac;
+	u8  nsac;
+	u8  tran_speed;
+	u16 ccc;
+	u8  read_bl_len;
+	u8  read_bl_partial;
+	u8  write_blk_misalign;
+	u8  read_blk_misalign;
+	u8  dsr_imp;
+	u16 c_size;
+	u8  vdd_r_curr_min;
+	u8  vdd_r_curr_max;
+	u8  vdd_w_curr_min;
+	u8  vdd_w_curr_max;
+	u8  c_size_mult;
+	union {
+		struct { /* MMC system specification version 3.1 */
+			u8  erase_grp_size;  
+			u8  erase_grp_mult; 
+		} v31;
+		struct { /* MMC system specification version 2.2 */
+			u8  sector_size;
+			u8  erase_grp_size;
+		} v22;
+	} erase;
+	u8  wp_grp_size;
+	u8  wp_grp_enable;
+	u8  default_ecc;
+	u8  r2w_factor;
+	u8  write_bl_len;
+	u8  write_bl_partial;
+	u8  file_format_grp;
+	u8  copy;
+	u8  perm_write_protect;
+	u8  tmp_write_protect;
+	u8  file_format;
+	u8  ecc;
+}mmc_csd_t;;
+
+struct mmc_response_r3 {  
+	u32 ocr;
+}; 
+
+#define MMC_VDD_145_150	0x00000001	/* VDD voltage 1.45 - 1.50 */
+#define MMC_VDD_150_155	0x00000002	/* VDD voltage 1.50 - 1.55 */
+#define MMC_VDD_155_160	0x00000004	/* VDD voltage 1.55 - 1.60 */
+#define MMC_VDD_160_165	0x00000008	/* VDD voltage 1.60 - 1.65 */
+#define MMC_VDD_165_170	0x00000010	/* VDD voltage 1.65 - 1.70 */
+#define MMC_VDD_17_18	0x00000020	/* VDD voltage 1.7 - 1.8 */
+#define MMC_VDD_18_19	0x00000040	/* VDD voltage 1.8 - 1.9 */
+#define MMC_VDD_19_20	0x00000080	/* VDD voltage 1.9 - 2.0 */
+#define MMC_VDD_20_21	0x00000100	/* VDD voltage 2.0 ~ 2.1 */
+#define MMC_VDD_21_22	0x00000200	/* VDD voltage 2.1 ~ 2.2 */
+#define MMC_VDD_22_23	0x00000400	/* VDD voltage 2.2 ~ 2.3 */
+#define MMC_VDD_23_24	0x00000800	/* VDD voltage 2.3 ~ 2.4 */
+#define MMC_VDD_24_25	0x00001000	/* VDD voltage 2.4 ~ 2.5 */
+#define MMC_VDD_25_26	0x00002000	/* VDD voltage 2.5 ~ 2.6 */
+#define MMC_VDD_26_27	0x00004000	/* VDD voltage 2.6 ~ 2.7 */
+#define MMC_VDD_27_28	0x00008000	/* VDD voltage 2.7 ~ 2.8 */
+#define MMC_VDD_28_29	0x00010000	/* VDD voltage 2.8 ~ 2.9 */
+#define MMC_VDD_29_30	0x00020000	/* VDD voltage 2.9 ~ 3.0 */
+#define MMC_VDD_30_31	0x00040000	/* VDD voltage 3.0 ~ 3.1 */
+#define MMC_VDD_31_32	0x00080000	/* VDD voltage 3.1 ~ 3.2 */
+#define MMC_VDD_32_33	0x00100000	/* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34	0x00200000	/* VDD voltage 3.3 ~ 3.4 */
+#define MMC_VDD_34_35	0x00400000	/* VDD voltage 3.4 ~ 3.5 */
+#define MMC_VDD_35_36	0x00800000	/* VDD voltage 3.5 ~ 3.6 */
+#define MMC_CARD_BUSY	0x80000000	/* Card Power up status bit */
+
+
+/* CSD field definitions */
+ 
+#define CSD_STRUCT_VER_1_0  0           /* Valid for system specification 1.0 - 1.2 */
+#define CSD_STRUCT_VER_1_1  1           /* Valid for system specification 1.4 - 2.2 */
+#define CSD_STRUCT_VER_1_2  2           /* Valid for system specification 3.1       */
+
+#define CSD_SPEC_VER_0      0           /* Implements system specification 1.0 - 1.2 */
+#define CSD_SPEC_VER_1      1           /* Implements system specification 1.4 */
+#define CSD_SPEC_VER_2      2           /* Implements system specification 2.0 - 2.2 */
+#define CSD_SPEC_VER_3      3           /* Implements system specification 3.1 */
+
+#if MMC_DEBUG_LEVEL
+
+#define DEBUG(n, args...)			\
+    do {    \
+	if (n <=  MMC_DEBUG_LEVEL) {	\
+		printf(args);	\
+	}    \
+    } while(0)
+#else
+#define DEBUG(n, args...)
+#endif /* MMC_DEBUG_EN */
+
+#endif  /* __MMC_PROTOCOL__ */
diff --git a/cpu/mips/usb_boot.S b/cpu/mips/usb_boot.S
new file mode 100644
index 0000000..6c3788f
--- /dev/null
+++ b/cpu/mips/usb_boot.S
@@ -0,0 +1,821 @@
+/*
+ *  for jz4740 usb boot
+ *
+ *  Copyright (c) 2009	Xiangfu Liu <xiangfu.z@gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+    .set noreorder
+    .globl usb_boot
+    .text
+
+//----------------------------------------------------------------------
+// Both NAND and USB boot load data to D-Cache first, then transfer
+// data from D-Cache to I-Cache, and jump to execute the code in I-Cache.
+// So init caches first and then dispatch to a proper boot routine.
+//----------------------------------------------------------------------
+
+init_caches:
+	li	$2, 3			// cacheable for kseg0 access
+	mtc0	$2, $16			// CP0_CONFIG
+	nop
+
+	li	$2, 0x20000000		// enable idx-store-data cache insn
+	mtc0	$2, $26			// CP0_ERRCTL
+
+	ori	$2, $28, 0		// start address
+	ori	$3, $2, 0x3fe0		// end address, total 16KB
+	mtc0	$0, $28, 0		// CP0_TAGLO
+	mtc0	$0, $28, 1		// CP0_DATALO
+cache_clear_a_line:
+	cache	0x8, 0($2)		// Index_Store_Tag_I
+	cache	0x9, 0($2)		// Index_Store_Tag_D
+	bne	$2, $3, cache_clear_a_line
+	addiu	$2, $2, 32		// increment CACHE_LINE_SIZE
+
+	ori	$2, $28, 0		// start address
+	ori	$3, $2, 0x3fe0		// end address, total 16KB
+	la	$4, 0x1ffff000		// physical address and 4KB page mask
+cache_alloc_a_line:
+	and	$5, $2, $4
+	ori	$5, $5, 1		// V bit of the physical tag
+	mtc0	$5, $28, 0		// CP0_TAGLO
+	cache	0x8, 0($2)		// Index_Store_Tag_I
+	cache	0x9, 0($2)		// Index_Store_Tag_D
+	bne	$2, $3, cache_alloc_a_line
+	addiu	$2, $2, 32		// increment CACHE_LINE_SIZE
+
+	nop
+	nop
+	nop
+	//--------------------------------------------------------------
+	// Transfer data from dcache to icache, then jump to icache.
+	//
+	// Input parameters:
+	//
+	// $19: data length in bytes
+	// $20: jump target address
+	//--------------------------------------------------------------
+xfer_d2i:
+	ori	$2, $28, 0		// start address
+	add	$3, $2, $19		// end addres
+	addiu	$3, $3, -4
+
+xfer_a_word:
+	lw	$4, 0($2)
+	mtc0	$4, $28, 1		// CP0_DATALO
+	cache	0xc, 0($2)		// Index_Store_Data_I
+	bne	$2, $3, xfer_a_word
+	addiu	$2, $2, 4
+
+	mtc0	$0, $26			// CP0_ERRCTL, restore WST reset state
+
+	jalr	$20			// jump, and place the return address in $31
+	nop
+
+icache_return:
+	//--------------------------------------------------------------
+	// User code can return to here after executing itself in 
+	// icache, by jumping to $31.
+	//--------------------------------------------------------------
+	b	usb_boot_return
+	nop
+
+
+usb_boot:
+	//--------------------------------------------------------------
+	// Initialize PLL: set ICLK to 84MHz and HCLK to 42MHz.
+	//--------------------------------------------------------------
+	la	$9, 0xB0000000		// CPCCR: Clock Control Register
+	la	$8, 0x42041110		// I:S:M:P=1:2:2:2
+	sw	$8, 0($9)
+
+	la	$9, 0xB0000010		// CPPCR: PLL Control Register
+	la	$8, 0x06000120		// M=12 N=0 D=0 CLK=12*(M+2)/(N+2)
+	sw	$8, 0($9)
+
+usb_boot_return:
+	//--------------------------------------------------------------
+	// Enable the USB PHY
+	//--------------------------------------------------------------
+	la	$9, 0xB0000024		// CPM_SCR
+	lw	$8, 0($9)
+	ori	$8, 0x40		// USBPHY_ENABLE
+	sw	$8, 0($9)
+
+	//--------------------------------------------------------------
+	// Initialize USB registers
+	//--------------------------------------------------------------
+	la	$27, 0xb3040000		// USB registers base address
+
+	sb	$0, 0x0b($27)		// INTRUSBE: disable common USB interrupts
+	sh	$0, 0x06($27)		// INTRINE: disable EPIN interrutps
+	sh	$0, 0x08($27)		// INTROUTE: disable EPOUT interrutps
+
+	li	$9, 0x61
+	sb	$9, 0x01($27)		// POWER: HSENAB | SUSPENDM | SOFTCONN
+
+	//--------------------------------------------------------------
+	// Initialize USB states
+	//--------------------------------------------------------------
+	li	$22, 0			// set EP0 to IDLE state
+	li	$23, 1			// no data stage
+
+	//--------------------------------------------------------------
+	// Main loop of polling the usb commands
+	//--------------------------------------------------------------
+usb_command_loop:
+	lbu	$9, 0x0a($27)		// read INTRUSB
+	andi	$9, 0x04		// check USB_INTR_RESET
+	beqz	$9, check_intr_ep0in
+	nop
+
+	//--------------------------------------------------------------
+ 	// 1. Handle USB reset interrupt
+	//--------------------------------------------------------------
+handle_reset_intr:
+	lbu	$9, 0x01($27)		// read POWER
+	andi	$9, 0x10		// test HS_MODE
+	bnez	$9, _usb_set_maxpktsize
+	li	$9, 512			// max packet size of HS mode
+	li	$9, 64			// max packet size of FS mode
+
+_usb_set_maxpktsize:
+	li	$8, 1
+	sb	$8, 0x0e($27)		// set INDEX 1
+
+	sh	$9, 0x10($27)		// INMAXP
+	sb	$0, 0x13($27)		// INCSRH
+	sh	$9, 0x14($27)		// OUTMAXP
+	sb	$0, 0x17($27)		// OUTCSRH
+
+_usb_flush_fifo:
+	li	$8, 0x48		// INCSR_CDT && INCSR_FF
+	sb	$8, 0x12($27)		// INCSR
+	li	$8, 0x90		// OUTCSR_CDT && OUTCSR_FF
+	sb	$8, 0x16($27)		// OUTCSR
+
+	li	$22, 0			// set EP0 to IDLE state
+	li	$23, 1			// no data stage
+
+	//--------------------------------------------------------------
+	// 2. Check and handle EP0 interrupt
+	//--------------------------------------------------------------	
+check_intr_ep0in:
+	lhu	$10, 0x02($27)		// read INTRIN
+	andi	$9, $10, 0x1		// check EP0 interrupt
+	beqz	$9, check_intr_ep1in
+	nop
+
+handle_ep0_intr:
+	sb	$0, 0x0e($27)		// set INDEX 0
+	lbu	$11, 0x12($27)		// read CSR0
+
+	andi	$9, $11, 0x04		// check SENTSTALL
+	beqz	$9, _ep0_setupend
+	nop
+
+_ep0_sentstall:
+	andi	$9, $11, 0xdb
+	sb	$9, 0x12($27)		// clear SENDSTALL and SENTSTALL
+	li	$22, 0			// set EP0 to IDLE state
+
+_ep0_setupend:
+	andi	$9, $11, 0x10		// check SETUPEND
+	beqz	$9, ep0_idle_state
+	nop
+
+	ori	$9, $11, 0x80
+	sb	$9, 0x12($27)		// set SVDSETUPEND
+	li	$22, 0			// set EP0 to IDLE state
+
+ep0_idle_state:
+	bnez	$22, ep0_tx_state
+	nop
+
+	//--------------------------------------------------------------
+	// 2.1 Handle EP0 IDLE state interrupt
+	//--------------------------------------------------------------
+	andi	$9, $11, 0x01		// check OUTPKTRDY
+	beqz	$9, check_intr_ep1in
+	nop
+
+	//--------------------------------------------------------------
+	// Read 8-bytes setup packet from the FIFO
+	//--------------------------------------------------------------
+	lw	$25, 0x20($27)		// first word of setup packet
+	lw	$26, 0x20($27)		// second word of setup packet
+
+	andi	$9, $25, 0x60		// bRequestType & USB_TYPE_MASK
+	beqz	$9, _ep0_std_req
+	nop
+
+	//--------------------------------------------------------------
+	// 2.1.1 Vendor-specific setup request
+	//--------------------------------------------------------------
+_ep0_vend_req:
+	li	$22, 0			// set EP0 to IDLE state
+	li	$23, 1			// NoData = 1
+
+	andi	$9, $25, 0xff00		// check bRequest
+	srl	$9, $9, 8
+	beqz	$9, __ep0_get_cpu_info
+	sub	$8, $9, 0x1
+	beqz	$8, __ep0_set_data_address
+	sub	$8, $9, 0x2
+	beqz	$8, __ep0_set_data_length
+	sub	$8, $9, 0x3
+	beqz	$8, __ep0_flush_caches
+	sub	$8, $9, 0x4
+	beqz	$8, __ep0_prog_start1
+	sub	$8, $9, 0x5
+	beqz	$8, __ep0_prog_start2
+	nop
+	b	_ep0_idle_state_fini	// invalid request
+	nop
+
+__ep0_get_cpu_info:
+	la	$20, cpu_info_data	// data pointer to transfer
+	li	$21, 8			// bytes left to transfer
+	li	$22, 1			// set EP0 to TX state
+	li	$23, 0			// NoData = 0
+
+	b	_ep0_idle_state_fini
+	nop
+
+__ep0_set_data_address:
+	li	$9, 0xffff0000
+	and	$9, $25, $9
+	andi	$8, $26, 0xffff
+	or	$20, $9, $8		// data address of next transfer
+
+	b	_ep0_idle_state_fini
+	nop
+
+__ep0_set_data_length:
+	li	$9, 0xffff0000
+	and	$9, $25, $9
+	andi	$8, $26, 0xffff
+	or	$21, $9, $8		// data length of next transfer
+
+	li	$9, 0x48		// SVDOUTPKTRDY and DATAEND
+	sb	$9, 0x12($27)		// CSR0
+
+	// We must write packet to FIFO before EP1-IN interrupt here.
+	b	handle_epin1_intr
+	nop
+
+__ep0_flush_caches:
+	// Flush dcache and invalidate icache.
+	li	$8, 0x80000000
+	addi	$9, $8, 0x3fe0		// total 16KB
+
+1:
+	cache	0x0, 0($8)		// Index_Invalidate_I
+	cache	0x1, 0($8)		// Index_Writeback_Inv_D
+	bne	$8, $9, 1b
+	addiu	$8, $8, 32
+
+	// flush write-buffer
+	sync
+
+	// Invalidate BTB
+	mfc0	$8, $16, 7		// CP0_CONFIG
+	nop
+	ori	$8, 2
+	mtc0	$8, $16, 7
+	nop
+
+	b	_ep0_idle_state_fini
+	nop
+
+__ep0_prog_start1:
+	li	$9, 0x48		// SVDOUTPKTRDY and DATAEND
+	sb	$9, 0x12($27)		// CSR0
+
+	li	$9, 0xffff0000
+	and	$9, $25, $9
+	andi	$8, $26, 0xffff
+	or	$20, $9, $8		// target address
+
+	b	xfer_d2i
+	li	$19, 0x4000		// 16KB data length
+
+__ep0_prog_start2:
+	li	$9, 0x48		// SVDOUTPKTRDY and DATAEND
+	sb	$9, 0x12($27)		// CSR0
+
+	li	$9, 0xffff0000
+	and	$9, $25, $9
+	andi	$8, $26, 0xffff
+	or	$20, $9, $8		// target address
+
+	jalr	$20			// jump, and place the return address in $31
+	nop
+
+__ep0_prog_start2_return:
+	// User code can return to here after executing itself, by jumping to $31.
+	b	usb_boot_return
+	nop
+
+	//--------------------------------------------------------------
+	// 2.1.2 Standard setup request
+	//--------------------------------------------------------------
+_ep0_std_req:
+	andi	$12, $25, 0xff00	// check bRequest
+	srl	$12, $12, 8
+	sub	$9, $12, 0x05		// check USB_REQ_SET_ADDRESS
+	bnez	$9, __ep0_req_set_config
+	nop
+
+	//--------------------------------------------------------------
+	// Handle USB_REQ_SET_ADDRESS
+	//--------------------------------------------------------------
+__ep0_req_set_addr:
+	srl	$9, $25, 16		// get wValue
+	sb	$9, 0x0($27)		// set FADDR
+	li	$23, 1			// NoData = 1
+	b	_ep0_idle_state_fini
+	nop
+
+__ep0_req_set_config:
+	sub	$9, $12, 0x09		// check USB_REQ_SET_CONFIGURATION
+	bnez	$9, __ep0_req_get_desc
+	nop
+
+	//--------------------------------------------------------------
+	// Handle USB_REQ_SET_CONFIGURATION
+	//--------------------------------------------------------------
+	li	$23, 1			// NoData = 1
+	b	_ep0_idle_state_fini
+	nop
+
+__ep0_req_get_desc:
+	sub	$9, $12, 0x06		// check USB_REQ_GET_DESCRIPTOR
+	bnez	$9, _ep0_idle_state_fini
+	li	$23, 1			// NoData = 1
+
+	//--------------------------------------------------------------
+	// Handle USB_REQ_GET_DESCRIPTOR
+	//--------------------------------------------------------------
+	li	$23, 0			// NoData = 0
+
+	srl	$9, $25, 24		// wValue >> 8
+	sub	$8, $9, 0x01		// check USB_DT_DEVICE
+	beqz	$8, ___ep0_get_dev_desc
+	srl	$21, $26, 16		// get wLength
+	sub	$8, $9, 0x02		// check USB_DT_CONFIG
+	beqz	$8, ___ep0_get_conf_desc
+	sub	$8, $9, 0x03		// check USB_DT_STRING
+	beqz	$8, ___ep0_get_string_desc
+	sub	$8, $9, 0x06		// check USB_DT_DEVICE_QUALIFIER
+	beqz	$8, ___ep0_get_dev_qualifier
+	nop
+	b	_ep0_idle_state_fini
+	nop
+
+___ep0_get_dev_desc:
+	la	$20, device_desc	// data pointer
+	li	$22, 1			// set EP0 to TX state
+	sub	$8, $21, 18
+	blez	$8, _ep0_idle_state_fini // wLength <= 18
+	nop
+	li	$21, 18			// max length of device_desc
+	b	_ep0_idle_state_fini
+	nop
+
+___ep0_get_dev_qualifier:
+	la	$20, dev_qualifier	// data pointer
+	li	$22, 1			// set EP0 to TX state
+	sub	$8, $21, 10
+	blez	$8, _ep0_idle_state_fini // wLength <= 10
+	nop
+	li	$21, 10			// max length of dev_qualifier
+	b	_ep0_idle_state_fini
+	nop
+
+___ep0_get_conf_desc:
+	la	$20, config_desc_fs	// data pointer of FS mode
+	lbu	$8, 0x01($27)		// read POWER
+	andi	$8, 0x10		// test HS_MODE
+	beqz	$8, ___ep0_get_conf_desc2
+	nop
+	la	$20, config_desc_hs	// data pointer of HS mode
+
+___ep0_get_conf_desc2:
+	li	$22, 1			// set EP0 to TX state
+	sub	$8, $21, 32
+	blez	$8, _ep0_idle_state_fini // wLength <= 32
+	nop
+	li	$21, 32			// max length of config_desc
+	b	_ep0_idle_state_fini
+	nop
+
+___ep0_get_string_desc:
+	li	$22, 1			// set EP0 to TX state
+
+	srl	$9, $25, 16		// wValue & 0xff
+	andi	$9, 0xff
+
+	sub	$8, $9, 1
+	beqz	$8, ___ep0_get_string_manufacture
+	sub	$8, $9, 2
+	beqz	$8, ___ep0_get_string_product
+	nop
+
+___ep0_get_string_lang_ids:
+	la	$20, string_lang_ids	// data pointer
+	b	_ep0_idle_state_fini
+	li	$21, 4			// data length
+
+___ep0_get_string_manufacture:
+	la	$20, string_manufacture	// data pointer
+	b	_ep0_idle_state_fini
+	li	$21, 16			// data length
+
+___ep0_get_string_product:
+	la	$20, string_product	// data pointer
+	b	_ep0_idle_state_fini
+	li	$21, 46			// data length
+
+_ep0_idle_state_fini:
+	li	$9, 0x40		// SVDOUTPKTRDY
+	beqz	$23, _ep0_idle_state_fini2
+	nop
+	ori	$9, $9, 0x08		// DATAEND
+_ep0_idle_state_fini2:
+	sb	$9, 0x12($27)		// CSR0
+	beqz	$22, check_intr_ep1in
+	nop
+
+	//--------------------------------------------------------------
+	// 2.2 Handle EP0 TX state interrupt
+	//--------------------------------------------------------------	
+ep0_tx_state:	
+	sub	$9, $22, 1
+	bnez	$9, check_intr_ep1in
+	nop
+
+	sub	$9, $21, 64		// max packetsize
+	blez	$9, _ep0_tx_state2	// data count <= 64
+	ori	$19, $21, 0
+	li	$19, 64
+
+_ep0_tx_state2:
+	beqz	$19, _ep0_tx_state3	// send ZLP
+	ori	$18, $19, 0		// record bytes to be transferred
+	sub	$21, $21, $19		// decrement data count
+
+_ep0_fifo_write_loop:
+	lbu	$9, 0($20)		// read data
+	sb	$9, 0x20($27)		// load FIFO
+	sub	$19, $19, 1		// decrement counter
+	bnez	$19, _ep0_fifo_write_loop
+	addi	$20, $20, 1		// increment data pointer
+
+	sub	$9, $18, 64		// max packetsize
+	beqz	$9, _ep0_tx_state4
+	nop
+
+_ep0_tx_state3:	
+	// transferred bytes < max packetsize
+	li	$9, 0x0a		// set INPKTRDY and DATAEND
+	sb	$9, 0x12($27)		// CSR0
+	li	$22, 0			// set EP0 to IDLE state
+	b	check_intr_ep1in
+	nop
+
+_ep0_tx_state4:
+	// transferred bytes == max packetsize
+	li	$9, 0x02		// set INPKTRDY
+	sb	$9, 0x12($27)		// CSR0
+	b	check_intr_ep1in
+	nop
+
+	//--------------------------------------------------------------
+	// 3. Check and handle EP1 BULK-IN interrupt
+	//--------------------------------------------------------------
+check_intr_ep1in:
+	andi	$9, $10, 0x2		// check EP1 IN interrupt
+	beqz	$9, check_intr_ep1out
+	nop
+
+handle_epin1_intr:
+	li	$9, 1
+	sb	$9, 0x0e($27)		// set INDEX 1
+	lbu	$9, 0x12($27)		// read INCSR
+
+	andi	$8, $9, 0x2		// check INCSR_FFNOTEMPT
+	bnez	$8, _epin1_tx_state4
+	nop
+
+_epin1_write_fifo:
+	lhu	$9, 0x10($27)		// get INMAXP
+	sub	$8, $21, $9
+	blez	$8, _epin1_tx_state1	// bytes left <= INMAXP
+	ori	$19, $21, 0
+	ori	$19, $9, 0
+
+_epin1_tx_state1:
+	beqz	$19, _epin1_tx_state4	// No data
+	nop
+
+	sub	$21, $21, $19		// decrement data count
+
+	srl	$5, $19, 2		// # of word
+	andi	$6, $19, 0x3		// # of byte
+	beqz	$5, _epin1_tx_state2
+	nop
+
+_epin1_fifo_write_word:
+	lw	$9, 0($20)		// read data from source address
+	sw	$9, 0x24($27)		// write FIFO
+	sub	$5, $5, 1		// decrement counter
+	bnez	$5, _epin1_fifo_write_word
+	addiu	$20, $20, 4		// increment dest address
+
+_epin1_tx_state2:
+	beqz	$6, _epin1_tx_state3
+	nop
+
+_epin1_fifo_write_byte:
+	lbu	$9, 0($20)		// read data from source address
+	sb	$9, 0x24($27)		// write FIFO
+	sub	$6, $6, 1		// decrement counter
+	bnez	$6, _epin1_fifo_write_byte
+	addiu	$20, $20, 1		// increment dest address
+
+_epin1_tx_state3:
+	li	$9, 0x1
+	sb	$9, 0x12($27)		// INCSR, set INPKTRDY
+
+_epin1_tx_state4:
+	// nop
+
+	//--------------------------------------------------------------
+	// 4. Check and handle EP1 BULK-OUT interrupt
+	//--------------------------------------------------------------
+check_intr_ep1out:
+	lhu	$9, 0x04($27)		// read INTROUT
+	andi	$9, 0x2
+	beqz	$9, check_status_next
+	nop
+
+handle_epout1_intr:
+	li	$9, 1
+	sb	$9, 0x0e($27)		// set INDEX 1
+
+	lbu	$9, 0x16($27)		// read OUTCSR
+	andi	$9, 0x1			// check OUTPKTRDY
+	beqz	$9, check_status_next
+	nop
+
+_epout1_read_fifo:
+	lhu	$19, 0x18($27)		// read OUTCOUNT
+	srl	$5, $19, 2		// # of word
+	andi	$6, $19, 0x3		// # of byte
+	beqz	$5, _epout1_rx_state1
+	nop
+
+_epout1_fifo_read_word:
+	lw	$9, 0x24($27)		// read FIFO
+	sw	$9, 0($20)		// store to dest address
+	sub	$5, $5, 1		// decrement counter
+	bnez	$5, _epout1_fifo_read_word
+	addiu	$20, $20, 4		// increment dest address
+
+_epout1_rx_state1:
+	beqz	$6, _epout1_rx_state2
+	nop
+
+_epout1_fifo_read_byte:
+	lbu	$9, 0x24($27)		// read FIFO
+	sb	$9, 0($20)		// store to dest address
+	sub	$6, $6, 1		// decrement counter
+	bnez	$6, _epout1_fifo_read_byte
+	addiu	$20, $20, 1		// increment dest address
+
+_epout1_rx_state2:
+	sb	$0, 0x16($27)		// clear OUTPKTRDY
+
+check_status_next:
+	b	usb_command_loop
+	nop
+
+//--------------------------------------------------------------
+// Device/Configuration/Interface/Endpoint/String Descriptors
+//--------------------------------------------------------------
+
+	.align	2
+device_desc:
+	.byte	0x12		// bLength
+	.byte	0x01		// bDescriptorType
+	.byte	0x00		// bcdUSB
+	.byte	0x02		// bcdUSB
+	.byte	0x00		// bDeviceClass
+	.byte	0x00		// bDeviceSubClass
+	.byte	0x00		// bDeviceProtocol
+	.byte	0x40		// bMaxPacketSize0
+	.byte	0x1a		// idVendor
+	.byte	0x60		// idVendor
+	.byte	0x40		// idProduct
+	.byte	0x47		// idProduct
+	.byte	0x00		// bcdDevice
+	.byte	0x01		// bcdDevice
+	.byte	0x01		// iManufacturer
+	.byte	0x02		// iProduct
+	.byte	0x00		// iSerialNumber
+	.byte	0x01		// bNumConfigurations
+
+	.align	2
+dev_qualifier:
+	.byte	0x0a		// bLength
+	.byte	0x06		// bDescriptorType
+	.byte	0x00		// bcdUSB
+	.byte	0x02		// bcdUSB
+	.byte	0x00		// bDeviceClass
+	.byte	0x00		// bDeviceSubClass
+	.byte	0x00		// bDeviceProtocol
+	.byte	0x40		// bMaxPacketSize0
+	.byte	0x01		// bNumConfigurations
+	.byte	0x00		// bRESERVED
+
+	.align	2
+config_desc_hs:
+	.byte	0x09		// bLength
+	.byte	0x02		// bDescriptorType
+	.byte	0x20		// wTotalLength
+	.byte	0x00		// wTotalLength
+	.byte	0x01		// bNumInterfaces
+	.byte	0x01		// bConfigurationValue
+	.byte	0x00		// iConfiguration
+	.byte	0xc0		// bmAttributes
+	.byte	0x01		// MaxPower
+intf_desc_hs:
+	.byte	0x09		// bLength
+	.byte	0x04		// bDescriptorType
+	.byte	0x00		// bInterfaceNumber
+	.byte	0x00		// bAlternateSetting
+	.byte	0x02		// bNumEndpoints
+	.byte	0xff		// bInterfaceClass
+	.byte	0x00		// bInterfaceSubClass
+	.byte	0x50		// bInterfaceProtocol
+	.byte	0x00		// iInterface
+ep1_desc_hs:
+	.byte	0x07		// bLength
+	.byte	0x05		// bDescriptorType
+	.byte	0x01		// bEndpointAddress
+	.byte	0x02		// bmAttributes
+	.byte	0x00		// wMaxPacketSize
+	.byte	0x02		// wMaxPacketSize
+	.byte	0x00		// bInterval
+ep2_desc_hs:
+	.byte	0x07		// bLength
+	.byte	0x05		// bDescriptorType
+	.byte	0x81		// bEndpointAddress
+	.byte	0x02		// bmAttributes
+	.byte	0x00		// wMaxPacketSize
+	.byte	0x02		// wMaxPacketSize
+	.byte	0x00		// bInterval
+
+	.align	2
+config_desc_fs:
+	.byte	0x09		// bLength
+	.byte	0x02		// bDescriptorType
+	.byte	0x20		// wTotalLength
+	.byte	0x00		// wTotalLength
+	.byte	0x01		// bNumInterfaces
+	.byte	0x01		// bConfigurationValue
+	.byte	0x00		// iConfiguration
+	.byte	0xc0		// bmAttributes
+	.byte	0x01		// MaxPower
+intf_desc_fs:
+	.byte	0x09		// bLength
+	.byte	0x04		// bDescriptorType
+	.byte	0x00		// bInterfaceNumber
+	.byte	0x00		// bAlternateSetting
+	.byte	0x02		// bNumEndpoints
+	.byte	0xff		// bInterfaceClass
+	.byte	0x00		// bInterfaceSubClass
+	.byte	0x50		// bInterfaceProtocol
+	.byte	0x00		// iInterface
+ep1_desc_fs:
+	.byte	0x07		// bLength
+	.byte	0x05		// bDescriptorType
+	.byte	0x01		// bEndpointAddress
+	.byte	0x02		// bmAttributes
+	.byte	0x40		// wMaxPacketSize
+	.byte	0x00		// wMaxPacketSize
+	.byte	0x00		// bInterval
+ep2_desc_fs:
+	.byte	0x07		// bLength
+	.byte	0x05		// bDescriptorType
+	.byte	0x81		// bEndpointAddress
+	.byte	0x02		// bmAttributes
+	.byte	0x40		// wMaxPacketSize
+	.byte	0x00		// wMaxPacketSize
+	.byte	0x00		// bInterval
+
+	.align	2
+string_lang_ids:
+	.byte	0x04
+	.byte	0x03
+	.byte	0x09
+	.byte	0x04
+
+	.align	2
+string_manufacture:
+	.byte	0x10
+	.byte	0x03
+	.byte	0x49
+	.byte	0x00
+	.byte	0x6e
+	.byte	0x00
+	.byte	0x67
+	.byte	0x00
+	.byte	0x65
+	.byte	0x00
+	.byte	0x6e
+	.byte	0x00
+	.byte	0x69
+	.byte	0x00
+	.byte	0x63
+	.byte	0x00
+
+	.align	2
+string_product:
+	.byte	0x2e
+	.byte	0x03
+	.byte	0x4a
+	.byte	0x00
+	.byte	0x5a
+	.byte	0x00
+	.byte	0x34
+	.byte	0x00
+	.byte	0x37
+	.byte	0x00
+	.byte	0x34
+	.byte	0x00
+	.byte	0x30
+	.byte	0x00
+	.byte	0x20
+	.byte	0x00
+	.byte	0x55
+	.byte	0x00
+	.byte	0x53
+	.byte	0x00
+	.byte	0x42
+	.byte	0x00
+	.byte	0x20
+	.byte	0x00
+	.byte	0x42
+	.byte	0x00
+	.byte	0x6f
+	.byte	0x00
+	.byte	0x6f
+	.byte	0x00
+	.byte	0x74
+	.byte	0x00
+	.byte	0x20
+	.byte	0x00
+	.byte	0x44
+	.byte	0x00
+	.byte	0x65
+	.byte	0x00
+	.byte	0x76
+	.byte	0x00
+	.byte	0x69
+	.byte	0x00
+	.byte	0x63
+	.byte	0x00
+	.byte	0x65
+	.byte	0x00
+
+	.align	2
+cpu_info_data:
+	.byte	0x4a
+	.byte	0x5a
+	.byte	0x34
+	.byte	0x37
+	.byte	0x34
+	.byte	0x30
+	.byte	0x56	
+	.byte	0x31
+
+    .set reorder
diff --git a/include/asm-mips/jz4740.h b/include/asm-mips/jz4740.h
new file mode 100644
index 0000000..2840bc0
--- /dev/null
+++ b/include/asm-mips/jz4740.h
@@ -0,0 +1,4880 @@
+/*
+ * Include file for Ingenic Semiconductor's JZ4740 CPU.
+ */
+#ifndef __JZ4740_H__
+#define __JZ4740_H__
+
+#ifndef __ASSEMBLY__
+#define UCOS_CSP 0
+
+#if UCOS_CSP
+#define __KERNEL__
+#include <bsp.h>
+#include <types.h>
+
+#include <sysdefs.h>
+#include <cacheops.h>
+#define KSEG0 KSEG0BASE
+#else
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+#endif
+
+#define cache_unroll(base,op)	        	\
+	__asm__ __volatile__("	         	\
+		.set noreorder;		        \
+		.set mips3;		        \
+		cache %1, (%0);	                \
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+static inline void jz_flush_dcache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CONFIG_SYS_DCACHE_SIZE;
+	while (start < end) {
+		cache_unroll(start,Index_Writeback_Inv_D);
+		start += CONFIG_SYS_CACHELINE_SIZE;
+	}
+}
+
+static inline void jz_flush_icache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CONFIG_SYS_ICACHE_SIZE;
+	while(start < end) {
+		cache_unroll(start,Index_Invalidate_I);
+		start += CONFIG_SYS_CACHELINE_SIZE;
+	}
+}
+
+/* cpu pipeline flush */
+static inline void jz_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+static inline void jz_writeb(u32 address, u8 value)
+{
+	*((volatile u8 *)address) = value;
+}
+
+static inline void jz_writew(u32 address, u16 value)
+{
+	*((volatile u16 *)address) = value;
+}
+
+static inline void jz_writel(u32 address, u32 value)
+{
+	*((volatile u32 *)address) = value;
+}
+
+static inline u8 jz_readb(u32 address)
+{
+	return *((volatile u8 *)address);
+}
+
+static inline u16 jz_readw(u32 address)
+{
+	return *((volatile u16 *)address);
+}
+
+static inline u32 jz_readl(u32 address)
+{
+	return *((volatile u32 *)address);
+}
+
+#define REG8(addr)	*((volatile u8 *)(addr))
+#define REG16(addr)	*((volatile u16 *)(addr))
+#define REG32(addr)	*((volatile u32 *)(addr))
+
+#else
+
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+
+#endif /* !ASSEMBLY */
+
+/* Boot ROM Specification  */
+/* NOR Boot config */
+#define JZ4740_NORBOOT_8BIT	0x00000000	/* 8-bit data bus flash */
+#define JZ4740_NORBOOT_16BIT	0x10101010	/* 16-bit data bus flash */
+#define JZ4740_NORBOOT_32BIT	0x20202020	/* 32-bit data bus flash */
+
+/* NAND Boot config */
+#define JZ4740_NANDBOOT_B8R3	0xffffffff	/* 8-bit bus & 3 row cycles */
+#define JZ4740_NANDBOOT_B8R2	0xf0f0f0f0	/* 8-bit bus & 2 row cycles */
+#define JZ4740_NANDBOOT_B16R3	0x0f0f0f0f	/* 16-bit bus & 3 row cycles */
+#define JZ4740_NANDBOOT_B16R2	0x00000000	/* 16-bit bus & 2 row cycles */
+
+
+/* Register Definitions */
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	CIM_BASE	0xB3060000
+#define	ETH_BASE	0xB3100000
+
+
+/*
+ * INTC (Interrupt Controller)
+ */
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+/* 1st-level interrupts */
+#define IRQ_I2C		1
+#define IRQ_UHC		3
+#define IRQ_UART0	9
+#define IRQ_SADC	12
+#define IRQ_MSC		14
+#define IRQ_RTC		15
+#define IRQ_SSI		16
+#define IRQ_CIM		17
+#define IRQ_AIC		18
+#define IRQ_ETH		19
+#define IRQ_DMAC	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_UDC 	24
+#define IRQ_GPIO3	25
+#define IRQ_GPIO2	26
+#define IRQ_GPIO1	27
+#define IRQ_GPIO0	28
+#define IRQ_IPU		29
+#define IRQ_LCD		30
+
+/* 2nd-level interrupts */
+#define IRQ_DMA_0	32  /* 32 to 37 for DMAC channel 0 to 5 */
+#define IRQ_GPIO_0	48  /* 48 to 175 for GPIO pin 0 to 127 */
+
+
+/*
+ * RTC
+ */
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_HZ	(1 << 6)  /* 1Hz Flag */
+#define RTC_RCR_HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF	(1 << 4)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR	(CPM_BASE+0x68)
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_SCR		(CPM_BASE+0x24)
+
+#define CPM_HCR		(CPM_BASE+0x30)
+#define CPM_HWFCR	(CPM_BASE+0x34)
+#define CPM_HRCR	(CPM_BASE+0x38)
+#define CPM_HWCR	(CPM_BASE+0x3c)
+#define CPM_HWSR	(CPM_BASE+0x40)
+#define CPM_HSPR	(CPM_BASE+0x44)
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+
+#define REG_CPM_CPCCR	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR	REG32(CPM_CPPCR)
+#define REG_CPM_I2SCDR	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR	REG32(CPM_MSCCDR)
+#define REG_CPM_UHCCDR	REG32(CPM_UHCCDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_SCR	REG32(CPM_SCR)
+#define REG_CPM_HCR	REG32(CPM_HCR)
+#define REG_CPM_HWFCR	REG32(CPM_HWFCR)
+#define REG_CPM_HRCR	REG32(CPM_HRCR)
+#define REG_CPM_HWCR	REG32(CPM_HWCR)
+#define REG_CPM_HWSR	REG32(CPM_HWSR)
+#define REG_CPM_HSPR	REG32(CPM_HSPR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_CLKOEN	(1 << 30)
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_LDIV_BIT	16
+#define CPM_CPCCR_LDIV_MASK	(0x1f << CPM_CPCCR_LDIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x1ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10)
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_UART1		(1 << 15)
+#define CPM_CLKGR_UHC		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_UDC		(1 << 11)
+#define CPM_CLKGR_LCD		(1 << 10)
+#define CPM_CLKGR_CIM		(1 << 9)
+#define CPM_CLKGR_SADC		(1 << 8)
+#define CPM_CLKGR_MSC		(1 << 7)
+#define CPM_CLKGR_AIC1		(1 << 6)
+#define CPM_CLKGR_AIC2		(1 << 5)
+#define CPM_CLKGR_SSI		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Sleep Control Register */
+#define CPM_SCR_O1ST_BIT	8
+#define CPM_SCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_SCR_USBPHY_ENABLE	(1 << 6)
+#define CPM_SCR_OSC_ENABLE	(1 << 4)
+
+/* Hibernate Control Register */
+#define CPM_HCR_PD		(1 << 0)
+
+/* Wakeup Filter Counter Register in Hibernate Mode */
+#define CPM_HWFCR_TIME_BIT	0
+#define CPM_HWFCR_TIME_MASK	(0x3ff << CPM_HWFCR_TIME_BIT)
+
+/* Reset Counter Register in Hibernate Mode */
+#define CPM_HRCR_TIME_BIT	0
+#define CPM_HRCR_TIME_MASK	(0x7f << CPM_HRCR_TIME_BIT)
+
+/* Wakeup Control Register in Hibernate Mode */
+#define CPM_HWCR_WLE_LOW	(0 << 2)
+#define CPM_HWCR_WLE_HIGH	(1 << 2)
+#define CPM_HWCR_PIN_WAKEUP	(1 << 1)
+#define CPM_HWCR_RTC_WAKEUP	(1 << 0)
+
+/* Wakeup Status Register in Hibernate Mode */
+#define CPM_HWSR_WSR_PIN	(1 << 1)
+#define CPM_HWSR_WSR_RTC	(1 << 0)
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG8(TCU_TER)
+#define REG_TCU_TESR	REG8(TCU_TESR)
+#define REG_TCU_TECR	REG8(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+/* n = 0,1,2,3,4,5 */
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+
+/* Register definitions */
+#define TCU_TCSR_PWM_SD		(1 << 9)
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)
+#define TCU_TCSR_PWM_EN		(1 << 7)
+#define TCU_TCSR_PRESCALE_BIT	3
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)
+#define TCU_TCSR_RTC_EN		(1 << 1)
+#define TCU_TCSR_PCK_EN		(1 << 0)
+
+#define TCU_TER_TCEN5		(1 << 5)
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21)
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_FFLAG5		(1 << 5)
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFLAG5		(1 << 21)
+#define TCU_TFSR_HFLAG4		(1 << 20)
+#define TCU_TFSR_HFLAG3		(1 << 19)
+#define TCU_TFSR_HFLAG2		(1 << 18)
+#define TCU_TFSR_HFLAG1		(1 << 17)
+#define TCU_TFSR_HFLAG0		(1 << 16)
+#define TCU_TFSR_FFLAG5		(1 << 5)
+#define TCU_TFSR_FFLAG4		(1 << 4)
+#define TCU_TFSR_FFLAG3		(1 << 3)
+#define TCU_TFSR_FFLAG2		(1 << 2)
+#define TCU_TFSR_FFLAG1		(1 << 1)
+#define TCU_TFSR_FFLAG0		(1 << 0)
+
+#define TCU_TFCR_HFLAG5		(1 << 21)
+#define TCU_TFCR_HFLAG4		(1 << 20)
+#define TCU_TFCR_HFLAG3		(1 << 19)
+#define TCU_TFCR_HFLAG2		(1 << 18)
+#define TCU_TFCR_HFLAG1		(1 << 17)
+#define TCU_TFCR_HFLAG0		(1 << 16)
+#define TCU_TFCR_FFLAG5		(1 << 5)
+#define TCU_TFCR_FFLAG4		(1 << 4)
+#define TCU_TFCR_FFLAG3		(1 << 3)
+#define TCU_TFCR_FFLAG2		(1 << 2)
+#define TCU_TFCR_FFLAG1		(1 << 1)
+#define TCU_TFCR_FFLAG0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21)
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_FMASK5		(1 << 5)
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TSR_WDTS		(1 << 16)
+#define TCU_TSR_STOP5		(1 << 5)
+#define TCU_TSR_STOP4		(1 << 4)
+#define TCU_TSR_STOP3		(1 << 3)
+#define TCU_TSR_STOP2		(1 << 2)
+#define TCU_TSR_STOP1		(1 << 1)
+#define TCU_TSR_STOP0		(1 << 0)
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSSR_WDTSC		(1 << 16)
+#define TCU_TSSR_STPC5		(1 << 5)
+#define TCU_TSSR_STPC4		(1 << 4)
+#define TCU_TSSR_STPC3		(1 << 3)
+#define TCU_TSSR_STPC2		(1 << 2)
+#define TCU_TSSR_STPC1		(1 << 1)
+#define TCU_TSSR_STPC0		(1 << 0)
+
+
+/*
+ * WDT (WatchDog Timer)
+ */
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+/* Register definition */
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*
+ * DMAC (DMA Controller)
+ */
+
+#define MAX_DMA_NUM	6  /* max 6 channels */
+
+#define DMAC_DSAR(n)	(DMAC_BASE + (0x00 + (n) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)	(DMAC_BASE + (0x04 + (n) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)	(DMAC_BASE + (0x08 + (n) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)	(DMAC_BASE + (0x0c + (n) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n)	(DMAC_BASE + (0x10 + (n) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)	(DMAC_BASE + (0x14 + (n) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)	(DMAC_BASE + (0x18 + (n) * 0x20)) /* DMA descriptor address */
+#define DMAC_DMACR	(DMAC_BASE + 0x0300)              /* DMA control register */
+#define DMAC_DMAIPR	(DMAC_BASE + 0x0304)              /* DMA interrupt pending */
+#define DMAC_DMADBR	(DMAC_BASE + 0x0308)              /* DMA doorbell */
+#define DMAC_DMADBSR	(DMAC_BASE + 0x030C)              /* DMA doorbell set */
+
+/* channel 0 */
+#define DMAC_DSAR0      DMAC_DSAR(0)
+#define DMAC_DTAR0      DMAC_DTAR(0)
+#define DMAC_DTCR0      DMAC_DTCR(0)
+#define DMAC_DRSR0      DMAC_DRSR(0)
+#define DMAC_DCCSR0     DMAC_DCCSR(0)
+#define DMAC_DCMD0	DMAC_DCMD(0)
+#define DMAC_DDA0	DMAC_DDA(0)
+
+/* channel 1 */
+#define DMAC_DSAR1      DMAC_DSAR(1)
+#define DMAC_DTAR1      DMAC_DTAR(1)
+#define DMAC_DTCR1      DMAC_DTCR(1)
+#define DMAC_DRSR1      DMAC_DRSR(1)
+#define DMAC_DCCSR1     DMAC_DCCSR(1)
+#define DMAC_DCMD1	DMAC_DCMD(1)
+#define DMAC_DDA1	DMAC_DDA(1)
+
+/* channel 2 */
+#define DMAC_DSAR2      DMAC_DSAR(2)
+#define DMAC_DTAR2      DMAC_DTAR(2)
+#define DMAC_DTCR2      DMAC_DTCR(2)
+#define DMAC_DRSR2      DMAC_DRSR(2)
+#define DMAC_DCCSR2     DMAC_DCCSR(2)
+#define DMAC_DCMD2	DMAC_DCMD(2)
+#define DMAC_DDA2	DMAC_DDA(2)
+
+/* channel 3 */
+#define DMAC_DSAR3      DMAC_DSAR(3)
+#define DMAC_DTAR3      DMAC_DTAR(3)
+#define DMAC_DTCR3      DMAC_DTCR(3)
+#define DMAC_DRSR3      DMAC_DRSR(3)
+#define DMAC_DCCSR3     DMAC_DCCSR(3)
+#define DMAC_DCMD3	DMAC_DCMD(3)
+#define DMAC_DDA3	DMAC_DDA(3)
+
+/* channel 4 */
+#define DMAC_DSAR4      DMAC_DSAR(4)
+#define DMAC_DTAR4      DMAC_DTAR(4)
+#define DMAC_DTCR4      DMAC_DTCR(4)
+#define DMAC_DRSR4      DMAC_DRSR(4)
+#define DMAC_DCCSR4     DMAC_DCCSR(4)
+#define DMAC_DCMD4	DMAC_DCMD(4)
+#define DMAC_DDA4	DMAC_DDA(4)
+
+/* channel 5 */
+#define DMAC_DSAR5      DMAC_DSAR(5)
+#define DMAC_DTAR5      DMAC_DTAR(5)
+#define DMAC_DTCR5      DMAC_DTCR(5)
+#define DMAC_DRSR5      DMAC_DRSR(5)
+#define DMAC_DCCSR5     DMAC_DCCSR(5)
+#define DMAC_DCMD5	DMAC_DCMD(5)
+#define DMAC_DDA5	DMAC_DDA(5)
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DMACR		REG32(DMAC_DMACR)
+#define REG_DMAC_DMAIPR		REG32(DMAC_DMAIPR)
+#define REG_DMAC_DMADBR		REG32(DMAC_DMADBR)
+#define REG_DMAC_DMADBSR	REG32(DMAC_DMADBSR)
+
+/* DMA request source register */
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_SSIOUT	(22 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_SSIIN	(23 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_MSCOUT	(26 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_MSCIN	(27 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+#define DMAC_DRSR_RS_SLCD	(30 << DMAC_DRSR_RS_BIT)
+
+/* DMA channel control/status register */
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+/* DMA channel command register  */
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_TM		(1 << 7)  /* transfer mode: 0-single 1-block */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+/* DMA descriptor address register */
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4  /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+/* DMA control register */
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_023145	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_201345	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_RR	(3 << DMAC_DMACR_PR_BIT) /* round robin */
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+/* DMA doorbell register */
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 5)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 5)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 5)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 5)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 5)  /* doorbell for channel 0 */
+
+/* DMA doorbell set register */
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 5)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 5)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 5)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 5)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 5)  /* enable doorbell for channel 0 */
+
+/* DMA interrupt pending register */
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	128
+
+/*  = 0,1,2,3 */
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Enable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Enable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Enable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO or intr, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:level-trigger, 1:edge-trigger */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+/*
+ * Define macros for UART_IER
+ * UART Interrupt Enable Register
+ */
+#define UART_IER_RIE	(1 << 0)	/* 0: receive fifo "full" interrupt disable */
+#define UART_IER_TIE	(1 << 1)	/* 0: transmit fifo "empty" interrupt disable */
+#define UART_IER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UART_IER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UART_IER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UART_ISR
+ * UART Interrupt Status Register
+ */
+#define UART_ISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UART_ISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UART_ISR_IID_MSI		(0 << 1)	/* Modem status interrupt */
+#define UART_ISR_IID_THRI	(1 << 1)	/* Transmitter holding register empty */
+#define UART_ISR_IID_RDI		(2 << 1)	/* Receiver data interrupt */
+#define UART_ISR_IID_RLSI	(3 << 1)	/* Receiver line status interrupt */
+#define UART_ISR_FFMS	(3 << 6)	/* FIFO mode select, set when UART_FCR.FE is set to 1 */
+#define UART_ISR_FFMS_NO_FIFO	(0 << 6)
+#define UART_ISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UART_FCR
+ * UART FIFO Control Register
+ */
+#define UART_FCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UART_FCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UART_FCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UART_FCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UART_FCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UART_FCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UART_FCR_RTRG_1	(0 << 6)
+#define UART_FCR_RTRG_4	(1 << 6)
+#define UART_FCR_RTRG_8	(2 << 6)
+#define UART_FCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UART_LCR
+ * UART Line Control Register
+ */
+#define UART_LCR_WLEN	(3 << 0)	/* word length */
+#define UART_LCR_WLEN_5	(0 << 0)
+#define UART_LCR_WLEN_6	(1 << 0)
+#define UART_LCR_WLEN_7	(2 << 0)
+#define UART_LCR_WLEN_8	(3 << 0)
+#define UART_LCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_1	(0 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_2	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+
+#define UART_LCR_PE	(1 << 3)	/* 0: parity disable */
+#define UART_LCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UART_LCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UART_LCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UART_LCR_DLAB	(1 << 7)	/* 0: access UART_RDR/TDR/IER  1: access UART_DLLR/DLHR */
+
+/*
+ * Define macros for UART_LSR
+ * UART Line Status Register
+ */
+#define UART_LSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UART_LSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UART_LSR_PER	(1 << 2)	/* 0: no parity error */
+#define UART_LSR_FER	(1 << 3)	/* 0; no framing error */
+#define UART_LSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UART_LSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UART_LSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UART_LSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UART_MCR
+ * UART Modem Control Register
+ */
+#define UART_MCR_DTR	(1 << 0)	/* 0: DTR_ ouput high */
+#define UART_MCR_RTS	(1 << 1)	/* 0: RTS_ output high */
+#define UART_MCR_OUT1	(1 << 2)	/* 0: UART_MSR.RI is set to 0 and RI_ input high */
+#define UART_MCR_OUT2	(1 << 3)	/* 0: UART_MSR.DCD is set to 0 and DCD_ input high */
+#define UART_MCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UART_MCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UART_MSR
+ * UART Modem Status Register
+ */
+#define UART_MSR_DCTS	(1 << 0)	/* 0: no change on CTS_ pin since last read of UART_MSR */
+#define UART_MSR_DDSR	(1 << 1)	/* 0: no change on DSR_ pin since last read of UART_MSR */
+#define UART_MSR_DRI	(1 << 2)	/* 0: no change on RI_ pin since last read of UART_MSR */
+#define UART_MSR_DDCD	(1 << 3)	/* 0: no change on DCD_ pin since last read of UART_MSR */
+#define UART_MSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+#define UART_MSR_DSR	(1 << 5)	/* 0: DSR_ pin is high */
+#define UART_MSR_RI	(1 << 6)	/* 0: RI_ pin is high */
+#define UART_MSR_DCD	(1 << 7)	/* 0: DCD_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)	/* 0: transmitter is in UART mode  1: IrDA mode */
+#define SIRCR_RSIRE	(1 << 1)	/* 0: receiver is in UART mode  1: IrDA mode */
+#define SIRCR_TPWS	(1 << 2)	/* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TXPL	(1 << 3)	/* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RXPL	(1 << 4)	/* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH		(1 << 8)   /* Flush FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+#define	ICDC_CR			(ICDC_BASE + 0x0400)  /* ICDC Control Register */
+#define	ICDC_APWAIT		(ICDC_BASE + 0x0404)  /* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APPRE		(ICDC_BASE + 0x0408)  /* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APHPEN		(ICDC_BASE + 0x040C)  /* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APSR		(ICDC_BASE + 0x0410)  /* Anti-Pop Status Register */
+#define ICDC_CDCCR1             (ICDC_BASE + 0x0080)
+#define ICDC_CDCCR2             (ICDC_BASE + 0x0084)
+
+#define	REG_ICDC_CR		REG32(ICDC_CR)
+#define	REG_ICDC_APWAIT		REG32(ICDC_APWAIT)
+#define	REG_ICDC_APPRE		REG32(ICDC_APPRE)
+#define	REG_ICDC_APHPEN		REG32(ICDC_APHPEN)
+#define	REG_ICDC_APSR		REG32(ICDC_APSR)
+#define REG_ICDC_CDCCR1         REG32(ICDC_CDCCR1)
+#define REG_ICDC_CDCCR2         REG32(ICDC_CDCCR2)
+
+/* ICDC Control Register */
+#define	ICDC_CR_LINVOL_BIT	24 /* LINE Input Volume Gain: GAIN=LINVOL*1.5-34.5 */
+#define	ICDC_CR_LINVOL_MASK	(0x1f << ICDC_CR_LINVOL_BIT)
+#define	ICDC_CR_ASRATE_BIT	20 /* Audio Sample Rate */
+#define	ICDC_CR_ASRATE_MASK	(0x0f << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_8000	(0x0 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_11025	(0x1 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_12000	(0x2 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_16000	(0x3 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_22050	(0x4 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_24000	(0x5 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_32000	(0x6 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_44100	(0x7 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_48000	(0x8 << ICDC_CR_ASRATE_BIT)
+#define	ICDC_CR_MICBG_BIT	18 /* MIC Boost Gain */
+#define	ICDC_CR_MICBG_MASK	(0x3 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_0DB	(0x0 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_6DB	(0x1 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_12DB	(0x2 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_20DB	(0x3 << ICDC_CR_MICBG_BIT)
+#define	ICDC_CR_HPVOL_BIT	16 /* Headphone Volume Gain */
+#define	ICDC_CR_HPVOL_MASK	(0x3 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_0DB	(0x0 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_2DB	(0x1 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_4DB	(0x2 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_6DB	(0x3 << ICDC_CR_HPVOL_BIT)
+#define ICDC_CR_ELINEIN		(1 << 13) /* Enable LINE Input */
+#define ICDC_CR_EMIC		(1 << 12) /* Enable MIC Input */
+#define ICDC_CR_SW1ON		(1 << 11) /* Switch 1 in CODEC is on */
+#define ICDC_CR_EADC		(1 << 10) /* Enable ADC */
+#define ICDC_CR_SW2ON		(1 << 9)  /* Switch 2 in CODEC is on */
+#define ICDC_CR_EDAC		(1 << 8)  /* Enable DAC */
+#define ICDC_CR_HPMUTE		(1 << 5)  /* Headphone Mute */
+#define ICDC_CR_HPTON		(1 << 4)  /* Headphone Amplifier Trun On */
+#define ICDC_CR_HPTOFF		(1 << 3)  /* Headphone Amplifier Trun Off */
+#define ICDC_CR_TAAP		(1 << 2)  /* Turn Around of the Anti-Pop Procedure */
+#define ICDC_CR_EAP		(1 << 1)  /* Enable Anti-Pop Procedure */
+#define ICDC_CR_SUSPD		(1 << 0)  /* CODEC Suspend */
+
+/* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APWAIT_WAITSN_BIT	0
+#define	ICDC_APWAIT_WAITSN_MASK	(0x7ff << ICDC_APWAIT_WAITSN_BIT)
+
+/* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APPRE_PRESN_BIT	0
+#define	ICDC_APPRE_PRESN_MASK	(0x1ff << ICDC_APPRE_PRESN_BIT)
+
+/* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APHPEN_HPENSN_BIT	0
+#define	ICDC_APHPEN_HPENSN_MASK	(0x3fff << ICDC_APHPEN_HPENSN_BIT)
+
+/* Anti-Pop Status Register */
+#define	ICDC_SR_HPST_BIT	14  /* Headphone Amplifier State */
+#define	ICDC_SR_HPST_MASK	(0x7 << ICDC_SR_HPST_BIT)
+#define ICDC_SR_HPST_HP_OFF	 (0x0 << ICDC_SR_HPST_BIT) /* HP amplifier is off */
+#define ICDC_SR_HPST_TON_WAIT	 (0x1 << ICDC_SR_HPST_BIT) /* wait state in turn-on */
+  #define ICDC_SR_HPST_TON_PRE	 (0x2 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-on */
+#define ICDC_SR_HPST_TON_HPEN	 (0x3 << ICDC_SR_HPST_BIT) /* HP enable state in turn-on */
+  #define ICDC_SR_HPST_TOFF_HPEN (0x4 << ICDC_SR_HPST_BIT) /* HP enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_PRE  (0x5 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_WAIT (0x6 << ICDC_SR_HPST_BIT) /* wait state in turn-off */
+  #define ICDC_SR_HPST_HP_ON	 (0x7 << ICDC_SR_HPST_BIT) /* HP amplifier is on */
+#define	ICDC_SR_SNCNT_BIT	0  /* Sample Number Counter */
+#define	ICDC_SR_SNCNT_MASK	(0x3fff << ICDC_SR_SNCNT_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI
+ *************************************************************************/
+#define	SSI_DR			(SSI_BASE + 0x000)
+#define	SSI_CR0			(SSI_BASE + 0x004)
+#define	SSI_CR1			(SSI_BASE + 0x008)
+#define	SSI_SR			(SSI_BASE + 0x00C)
+#define	SSI_ITR			(SSI_BASE + 0x010)
+#define	SSI_ICR			(SSI_BASE + 0x014)
+#define	SSI_GR			(SSI_BASE + 0x018)
+
+#define	REG_SSI_DR		REG32(SSI_DR)
+#define	REG_SSI_CR0		REG16(SSI_CR0)
+#define	REG_SSI_CR1		REG32(SSI_CR1)
+#define	REG_SSI_SR		REG32(SSI_SR)
+#define	REG_SSI_ITR		REG16(SSI_ITR)
+#define	REG_SSI_ICR		REG8(SSI_ICR)
+#define	REG_SSI_GR		REG16(SSI_GR)
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorola¡¯s SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16
+#define SSI_CR1_TTRG_MASK	(0xf << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_1	  (0 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_8	  (1 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_16	  (2 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_24	  (3 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_32	  (4 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_40	  (5 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_48	  (6 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_56	  (7 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_64	  (8 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_72	  (9 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_80	  (10<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_88	  (11<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_96	  (12<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_104	  (13<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_112	  (14<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_120	  (15<< SSI_CR1_TTRG_BIT)
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8
+#define SSI_CR1_RTRG_MASK	(0xf << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_1	  (0 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_8	  (1 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_16	  (2 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_24	  (3 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_32	  (4 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_40	  (5 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_48	  (6 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_56	  (7 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_64	  (8 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_72	  (9 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_80	  (10<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_88	  (11<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_96	  (12<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_104	  (13<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_112	  (14<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_120	  (15<< SSI_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ *************************************************************************/
+#define	MSC_STRPCL		(MSC_BASE + 0x000)
+#define	MSC_STAT		(MSC_BASE + 0x004)
+#define	MSC_CLKRT		(MSC_BASE + 0x008)
+#define	MSC_CMDAT		(MSC_BASE + 0x00C)
+#define	MSC_RESTO		(MSC_BASE + 0x010)
+#define	MSC_RDTO		(MSC_BASE + 0x014)
+#define	MSC_BLKLEN		(MSC_BASE + 0x018)
+#define	MSC_NOB			(MSC_BASE + 0x01C)
+#define	MSC_SNOB		(MSC_BASE + 0x020)
+#define	MSC_IMASK		(MSC_BASE + 0x024)
+#define	MSC_IREG		(MSC_BASE + 0x028)
+#define	MSC_CMD			(MSC_BASE + 0x02C)
+#define	MSC_ARG			(MSC_BASE + 0x030)
+#define	MSC_RES			(MSC_BASE + 0x034)
+#define	MSC_RXFIFO		(MSC_BASE + 0x038)
+#define	MSC_TXFIFO		(MSC_BASE + 0x03C)
+
+#define	REG_MSC_STRPCL		REG16(MSC_STRPCL)
+#define	REG_MSC_STAT		REG32(MSC_STAT)
+#define	REG_MSC_CLKRT		REG16(MSC_CLKRT)
+#define	REG_MSC_CMDAT		REG32(MSC_CMDAT)
+#define	REG_MSC_RESTO		REG16(MSC_RESTO)
+#define	REG_MSC_RDTO		REG16(MSC_RDTO)
+#define	REG_MSC_BLKLEN		REG16(MSC_BLKLEN)
+#define	REG_MSC_NOB		REG16(MSC_NOB)
+#define	REG_MSC_SNOB		REG16(MSC_SNOB)
+#define	REG_MSC_IMASK		REG16(MSC_IMASK)
+#define	REG_MSC_IREG		REG16(MSC_IREG)
+#define	REG_MSC_CMD		REG8(MSC_CMD)
+#define	REG_MSC_ARG		REG32(MSC_ARG)
+#define	REG_MSC_RES		REG16(MSC_RES)
+#define	REG_MSC_RXFIFO		REG32(MSC_RXFIFO)
+#define	REG_MSC_TXFIFO		REG32(MSC_TXFIFO)
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	  (0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	  (0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	  (0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	  (0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	  (0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	  (0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	  (0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	  (0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+
+#define	MSC_CMDAT_IO_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define CMDAT_BUS_WIDTH1	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define CMDAT_BUS_WIDTH4	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT)
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE  (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_BCR		(EMC_BASE + 0x0)  /* BCR */
+
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+#define EMC_NFECR	(EMC_BASE + 0x100) /* NAND Flash ECC Control Register */
+#define EMC_NFECC	(EMC_BASE + 0x104) /* NAND Flash ECC Data Register */
+#define EMC_NFPAR0	(EMC_BASE + 0x108) /* NAND Flash RS Parity 0 Register */
+#define EMC_NFPAR1	(EMC_BASE + 0x10c) /* NAND Flash RS Parity 1 Register */
+#define EMC_NFPAR2	(EMC_BASE + 0x110) /* NAND Flash RS Parity 2 Register */
+#define EMC_NFINTS	(EMC_BASE + 0x114) /* NAND Flash Interrupt Status Register */
+#define EMC_NFINTE	(EMC_BASE + 0x118) /* NAND Flash Interrupt Enable Register */
+#define EMC_NFERR0	(EMC_BASE + 0x11c) /* NAND Flash RS Error Report 0 Register */
+#define EMC_NFERR1	(EMC_BASE + 0x120) /* NAND Flash RS Error Report 1 Register */
+#define EMC_NFERR2	(EMC_BASE + 0x124) /* NAND Flash RS Error Report 2 Register */
+#define EMC_NFERR3	(EMC_BASE + 0x128) /* NAND Flash RS Error Report 3 Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0xa000) /* Mode Register of SDRAM bank 0 */
+
+#define REG_EMC_BCR	REG32(EMC_BCR)
+
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+#define REG_EMC_NFECR	REG32(EMC_NFECR)
+#define REG_EMC_NFECC	REG32(EMC_NFECC)
+#define REG_EMC_NFPAR0	REG32(EMC_NFPAR0)
+#define REG_EMC_NFPAR1	REG32(EMC_NFPAR1)
+#define REG_EMC_NFPAR2	REG32(EMC_NFPAR2)
+#define REG_EMC_NFINTS	REG32(EMC_NFINTS)
+#define REG_EMC_NFINTE	REG32(EMC_NFINTE)
+#define REG_EMC_NFERR0	REG32(EMC_NFERR0)
+#define REG_EMC_NFERR1	REG32(EMC_NFERR1)
+#define REG_EMC_NFERR2	REG32(EMC_NFERR2)
+#define REG_EMC_NFERR3	REG32(EMC_NFERR3)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* NAND Flash ECC Control Register */
+#define EMC_NFECR_PRDY		(1 << 4) /* Parity Ready */
+#define EMC_NFECR_RS_DECODING	(0 << 3) /* RS is in decoding phase */
+#define EMC_NFECR_RS_ENCODING	(1 << 3) /* RS is in encoding phase */
+#define EMC_NFECR_HAMMING	(0 << 2) /* Select HAMMING Correction Algorithm */
+#define EMC_NFECR_RS		(1 << 2) /* Select RS Correction Algorithm */
+#define EMC_NFECR_ERST		(1 << 1) /* ECC Reset */
+#define EMC_NFECR_ECCE		(1 << 0) /* ECC Enable */
+
+/* NAND Flash ECC Data Register */
+#define EMC_NFECC_ECC2_BIT	16
+#define EMC_NFECC_ECC2_MASK	(0xff << EMC_NFECC_ECC2_BIT)
+#define EMC_NFECC_ECC1_BIT	8
+#define EMC_NFECC_ECC1_MASK	(0xff << EMC_NFECC_ECC1_BIT)
+#define EMC_NFECC_ECC0_BIT	0
+#define EMC_NFECC_ECC0_MASK	(0xff << EMC_NFECC_ECC0_BIT)
+
+/* NAND Flash Interrupt Status Register */
+#define EMC_NFINTS_ERRCNT_BIT	29       /* Error Count */
+#define EMC_NFINTS_ERRCNT_MASK	(0x7 << EMC_NFINTS_ERRCNT_BIT)
+#define EMC_NFINTS_PADF		(1 << 4) /* Padding Finished */
+#define EMC_NFINTS_DECF		(1 << 3) /* Decoding Finished */
+#define EMC_NFINTS_ENCF		(1 << 2) /* Encoding Finished */
+#define EMC_NFINTS_UNCOR	(1 << 1) /* Uncorrectable Error Occurred */
+#define EMC_NFINTS_ERR		(1 << 0) /* Error Occurred */
+
+/* NAND Flash Interrupt Enable Register */
+#define EMC_NFINTE_PADFE	(1 << 4) /* Padding Finished Interrupt Enable */
+#define EMC_NFINTE_DECFE	(1 << 3) /* Decoding Finished Interrupt Enable */
+#define EMC_NFINTE_ENCFE	(1 << 2) /* Encoding Finished Interrupt Enable */
+#define EMC_NFINTE_UNCORE	(1 << 1) /* Uncorrectable Error Occurred Intr Enable */
+#define EMC_NFINTE_ERRE		(1 << 0) /* Error Occurred Interrupt */
+
+/* NAND Flash RS Error Report Register */
+#define EMC_NFERR_INDEX_BIT	16       /* Error Symbol Index */
+#define EMC_NFERR_INDEX_MASK	(0x1ff << EMC_NFERR_INDEX_BIT)
+#define EMC_NFERR_MASK_BIT	0        /* Error Symbol Value */
+#define EMC_NFERR_MASK_MASK	(0x1ff << EMC_NFERR_MASK_BIT)
+
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_VDDM		(1 << 13)
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_DMA_EN		(1 << 2)
+#define	CIM_CTRL_RXF_RST	(1 << 1)
+#define	CIM_CTRL_ENA		(1 << 0)
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6)
+#define	CIM_STATE_DMA_EOF	(1 << 5)
+#define	CIM_STATE_DMA_STOP	(1 << 4)
+#define	CIM_STATE_RXF_OF	(1 << 3)
+#define	CIM_STATE_RXF_TRIG	(1 << 2)
+#define	CIM_STATE_RXF_EMPTY	(1 << 1)
+#define	CIM_STATE_VDD		(1 << 0)
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31)
+#define	CIM_CMD_EOFINT		(1 << 30)
+#define	CIM_CMD_STOP		(1 << 28)
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_TSBUSY	(1 << 7)  /* TS A/D is working */
+#define SADC_STATE_PBATBUSY	(1 << 6)  /* PBAT A/D is working */
+#define SADC_STATE_SBUSY	(1 << 5)  /* SADCIN A/D is working */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+#define SLCD_FIFO	(SLCD_BASE + 0xB0)  /* SLCD FIFO Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+#define REG_SLCD_FIFO	REG32(SLCD_FIFO)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_BURST_BIT	14
+#define SLCD_CFG_BURST_MASK	(0x3 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_4_WORD	(0 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_8_WORD	(1 << SLCD_CFG_BURST_BIT)
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x1	(4 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9_x2	(4 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << 8)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << 8)
+#define SLCD_CFG_CWIDTH_18BIT	(2 << 8)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/* SLCD FIFO Register */
+#define SLCD_FIFO_RS_DATA	(0 << 31)
+#define SLCD_FIFO_RS_COMMAND	(1 << 31)
+
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC pority:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK pority:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE pority:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC pority:0-rising,1-falling */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(5 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_18BIT_TFT  (13 << LCD_CFG_MODE_BIT)
+  /* JZ47XX defines */
+  #define LCD_CFG_MODE_SHARP_HR		(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_CASIO_TFT	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SAMSUNG_ALPHA	(3 << LCD_CFG_MODE_BIT)
+
+
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+
+
+/* Module Operation Definitions */
+#ifndef __ASSEMBLY__
+
+
+/* GPIO Pins Description */
+/* PORT 0: */
+/* PIN/BIT N		FUNC0		FUNC1 */
+/*	0		D0		- */
+/*	1		D1		- */
+/*	2		D2		- */
+/*	3		D3		- */
+/*	4		D4		- */
+/*	5		D5		- */
+/*	6		D6		- */
+/*	7		D7		- */
+/*	8		D8		- */
+/*	9		D9		- */
+/*	10		D10		- */
+/*	11		D11		- */
+/*	12		D12		- */
+/*	13		D13		- */
+/*	14		D14		- */
+/*	15		D15		- */
+/*	16		D16		- */
+/*	17		D17		- */
+/*	18		D18		- */
+/*	19		D19		- */
+/*	20		D20		- */
+/*	21		D21		- */
+/*	22		D22		- */
+/*	23		D23		- */
+/*	24		D24		- */
+/*	25		D25		- */
+/*	26		D26		- */
+/*	27		D27		- */
+/*	28		D28		- */
+/*	29		D29		- */
+/*	30		D30		- */
+/*	31		D31		- */
+/*------------------------------------------------------ */
+/* PORT 1: */
+/* */
+/* PIN/BIT N		FUNC0		FUNC1 */
+/*	0		A0		- */
+/*	1		A1		- */
+/*	2		A2		- */
+/*	3		A3		- */
+/*	4		A4		- */
+/*	5		A5		- */
+/*	6		A6		- */
+/*	7		A7		- */
+/*	8		A8		- */
+/*	9		A9		- */
+/*	10		A10		- */
+/*	11		A11		- */
+/*	12		A12		- */
+/*	13		A13		- */
+/*	14		A14		- */
+/*	15		A15/CL		- */
+/*	16		A16/AL		- */
+/*	17		LCD_CLS		A21 */
+/*	18		LCD_SPL		A22 */
+/*	19		DCS#		- */
+/*	20		RAS#		- */
+/*	21		CAS#		- */
+/*	22		RDWE#/BUFD#	- */
+/*	23		CKE		- */
+/*	24		CKO		- */
+/*	25		CS1#		- */
+/*	26		CS2#		- */
+/*	27		CS3#		- */
+/*	28		CS4#		- */
+/*	29		RD#		- */
+/*	30		WR#		- */
+/*	31		WE0#		- */
+/* Note: PIN15&16 are CL&AL when connecting to NAND flash. */
+/*------------------------------------------------------ */
+/* PORT 2: */
+/* */
+/* PIN/BIT N		FUNC0		FUNC1 */
+/*	0		LCD_D0		- */
+/*	1		LCD_D1		- */
+/*	2		LCD_D2		- */
+/*	3		LCD_D3		- */
+/*	4		LCD_D4		- */
+/*	5		LCD_D5		- */
+/*	6		LCD_D6		- */
+/*	7		LCD_D7		- */
+/*	8		LCD_D8		- */
+/*	9		LCD_D9		- */
+/*	10		LCD_D10		- */
+/*	11		LCD_D11		- */
+/*	12		LCD_D12		- */
+/*	13		LCD_D13		- */
+/*	14		LCD_D14		- */
+/*	15		LCD_D15		- */
+/*	16		LCD_D16		- */
+/*	17		LCD_D17		- */
+/*	18		LCD_PCLK	- */
+/*	19		LCD_HSYNC	- */
+/*	20		LCD_VSYNC	- */
+/*	21		LCD_DE		- */
+/*	22		LCD_PS		A19 */
+/*	23		LCD_REV		A20 */
+/*	24		WE1#		- */
+/*	25		WE2#		- */
+/*	26		WE3#		- */
+/*	27		WAIT#		- */
+/*	28		FRE#		- */
+/*	29		FWE#		- */
+/*	30(NOTE:FRB#)	-		- */
+/*	31		-		- */
+/* NOTE(1): PIN30 is used for FRB# when connecting to NAND flash. */
+/*------------------------------------------------------ */
+/* PORT 3: */
+/* */
+/* PIN/BIT N		FUNC0		FUNC1 */
+/*	0		CIM_D0		- */
+/*	1		CIM_D1		- */
+/*	2		CIM_D2		- */
+/*	3		CIM_D3		- */
+/*	4		CIM_D4		- */
+/*	5		CIM_D5		- */
+/*	6		CIM_D6		- */
+/*	7		CIM_D7		- */
+/*	8		MSC_CMD		- */
+/*	9		MSC_CLK		- */
+/*	10		MSC_D0		- */
+/*	11		MSC_D1		- */
+/*	12		MSC_D2		- */
+/*	13		MSC_D3		- */
+/*	14		CIM_MCLK	- */
+/*	15		CIM_PCLK	- */
+/*	16		CIM_VSYNC	- */
+/*	17		CIM_HSYNC	- */
+/*	18		SSI_CLK		SCLK_RSTN */
+/*	19		SSI_CE0#	BIT_CLK(AIC) */
+/*	20		SSI_DT		SDATA_OUT(AIC) */
+/*	21		SSI_DR		SDATA_IN(AIC) */
+/*	22		SSI_CE1#&GPC	SYNC(AIC) */
+/*	23		PWM0		I2C_SDA */
+/*	24		PWM1		I2C_SCK */
+/*	25		PWM2		UART0_TxD */
+/*	26		PWM3		UART0_RxD */
+/*	27		PWM4		A17 */
+/*	28		PWM5		A18 */
+/*	29		-		- */
+/*	30		PWM6		UART0_CTS/UART1_RxD */
+/*	31		PWM7		UART0_RTS/UART1_TxD */
+/* 
+ * p is the port number (0,1,2,3)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-127), regardless of the port
+ */
+
+/* Function Pins Mode */
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#, WE2#, WE3#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x07000000;	\
+	REG_GPIO_PXSELC(2) = 0x07000000;	\
+	REG_GPIO_PXPES(2) = 0x07000000;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#
+ */
+#define __gpio_as_sdram_16bit_4720()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x5442bfaa;	\
+	REG_GPIO_PXSELC(0) = 0x5442bfaa;	\
+	REG_GPIO_PXPES(0) = 0x5442bfaa;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x01000000;	\
+	REG_GPIO_PXSELC(2) = 0x01000000;	\
+	REG_GPIO_PXPES(2) = 0x01000000;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#
+ */
+#define __gpio_as_sdram_16bit_4725()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x01000000;	\
+	REG_GPIO_PXSELC(2) = 0x01000000;	\
+	REG_GPIO_PXPES(2) = 0x01000000;		\
+} while (0)
+
+
+/*
+ * CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ */
+#define __gpio_as_nand()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x02018000;	\
+	REG_GPIO_PXSELC(1) = 0x02018000;	\
+	REG_GPIO_PXPES(1) = 0x02018000;		\
+	REG_GPIO_PXFUNS(2) = 0x30000000;	\
+	REG_GPIO_PXSELC(2) = 0x30000000;	\
+	REG_GPIO_PXPES(2) = 0x30000000;		\
+	REG_GPIO_PXFUNC(2) = 0x40000000;	\
+	REG_GPIO_PXSELC(2) = 0x40000000;	\
+	REG_GPIO_PXDIRC(2) = 0x40000000;	\
+	REG_GPIO_PXPES(2) = 0x40000000;		\
+	REG_GPIO_PXFUNS(1) = 0x00400000;	\
+	REG_GPIO_PXSELC(1) = 0x00400000;	\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ */
+#define __gpio_as_nor_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x000000ff;	\
+	REG_GPIO_PXSELC(0) = 0x000000ff;	\
+	REG_GPIO_PXPES(0) = 0x000000ff;		\
+	REG_GPIO_PXFUNS(1) = 0x7041ffff;	\
+	REG_GPIO_PXSELC(1) = 0x7041ffff;	\
+	REG_GPIO_PXPES(1) = 0x7041ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x00060000;	\
+	REG_GPIO_PXSELS(1) = 0x00060000;	\
+	REG_GPIO_PXPES(1) = 0x00060000;		\
+	REG_GPIO_PXFUNS(2) = 0x08000000;	\
+	REG_GPIO_PXSELC(2) = 0x08000000;	\
+	REG_GPIO_PXPES(2) = 0x08000000;		\
+	REG_GPIO_PXFUNS(2) = 0x00c00000;	\
+	REG_GPIO_PXSELS(2) = 0x00c00000;	\
+	REG_GPIO_PXPES(2) = 0x00c00000;		\
+	REG_GPIO_PXFUNS(3) = 0x18000000;	\
+	REG_GPIO_PXSELS(3) = 0x18000000;	\
+	REG_GPIO_PXPES(3) = 0x18000000;		\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ */
+#define __gpio_as_nor_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x7041ffff;	\
+	REG_GPIO_PXSELC(1) = 0x7041ffff;	\
+	REG_GPIO_PXPES(1) = 0x7041ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x00060000;	\
+	REG_GPIO_PXSELS(1) = 0x00060000;	\
+	REG_GPIO_PXPES(1) = 0x00060000;		\
+	REG_GPIO_PXFUNS(2) = 0x08000000;	\
+	REG_GPIO_PXSELC(2) = 0x08000000;	\
+	REG_GPIO_PXPES(2) = 0x08000000;		\
+	REG_GPIO_PXFUNS(2) = 0x00c00000;	\
+	REG_GPIO_PXSELS(2) = 0x00c00000;	\
+	REG_GPIO_PXPES(2) = 0x00c00000;		\
+	REG_GPIO_PXFUNS(3) = 0x18000000;	\
+	REG_GPIO_PXSELS(3) = 0x18000000;	\
+	REG_GPIO_PXPES(3) = 0x18000000;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART_RxD0
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x06000000;	\
+	REG_GPIO_PXSELS(3) = 0x06000000;	\
+	REG_GPIO_PXPES(3) = 0x06000000;		\
+} while (0)
+
+#define __gpio_jtag_to_uart0()			\
+do {						\
+	REG_GPIO_PXSELS(2) = 0x80000000;	\
+} while (0)
+
+/*
+ * UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_ctsrts()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xc0000000;	\
+	REG_GPIO_PXSELS(3) = 0xc0000000;	\
+	REG_GPIO_PXTRGC(3) = 0xc0000000;	\
+	REG_GPIO_PXPES(3) = 0xc0000000;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD1
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xc0000000;	\
+	REG_GPIO_PXSELC(3) = 0xc0000000;	\
+	REG_GPIO_PXTRGS(3) = 0xc0000000;	\
+	REG_GPIO_PXPES(3) = 0xc0000000;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x003cffff;	\
+	REG_GPIO_PXSELC(2) = 0x003cffff;	\
+	REG_GPIO_PXPES(2) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D17, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x003fffff;	\
+	REG_GPIO_PXSELC(2) = 0x003fffff;	\
+	REG_GPIO_PXPES(2) = 0x003fffff;		\
+} while (0)
+
+
+/* LCD_D0~LCD_D7, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001800ff;	\
+	REG_GPIO_PXSELC(2) = 0x001800ff;	\
+} while (0)
+
+/* LCD_D0~LCD_D7, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_9bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001801ff;	\
+	REG_GPIO_PXSELC(2) = 0x001801ff;	\
+} while (0)
+
+/* LCD_D0~LCD_D15, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x0018ffff;	\
+	REG_GPIO_PXSELC(2) = 0x0018ffff;	\
+} while (0)
+
+/* LCD_D0~LCD_D17, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001bffff;	\
+	REG_GPIO_PXSELC(2) = 0x001bffff;	\
+} while (0)
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x0003c0ff;	\
+	REG_GPIO_PXSELC(3) = 0x0003c0ff;	\
+	REG_GPIO_PXPES(3) = 0x0003c0ff;		\
+} while (0)
+
+/*
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x007c0000;	\
+	REG_GPIO_PXSELS(3) = 0x007c0000;	\
+	REG_GPIO_PXPES(3) = 0x007c0000;		\
+} while (0)
+
+/*
+ * MSC_CMD, MSC_CLK, MSC_D0 ~ MSC_D3
+ */
+#define __gpio_as_msc()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x00003f00;	\
+	REG_GPIO_PXSELC(3) = 0x00003f00;	\
+	REG_GPIO_PXPES(3) = 0x00003f00;		\
+} while (0)
+
+/*
+ * SSI_CS0, SSI_CLK, SSI_DT, SSI_DR
+ */
+#define __gpio_as_ssi()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c0000;	\
+	REG_GPIO_PXSELC(3) = 0x003c0000;	\
+	REG_GPIO_PXPES(3) = 0x003c0000;		\
+} while (0)
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x01800000;	\
+	REG_GPIO_PXSELS(3) = 0x01800000;	\
+	REG_GPIO_PXPES(3) = 0x01800000;		\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x00800000;	\
+	REG_GPIO_PXSELC(3) = 0x00800000;	\
+	REG_GPIO_PXPES(3) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x01000000;	\
+	REG_GPIO_PXSELC(3) = 0x01000000;	\
+	REG_GPIO_PXPES(3) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x02000000;	\
+	REG_GPIO_PXSELC(3) = 0x02000000;	\
+	REG_GPIO_PXPES(3) = 0x02000000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x04000000;	\
+	REG_GPIO_PXSELC(3) = 0x04000000;	\
+	REG_GPIO_PXPES(3) = 0x04000000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x08000000;	\
+	REG_GPIO_PXSELC(3) = 0x08000000;	\
+	REG_GPIO_PXPES(3) = 0x08000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x10000000;	\
+	REG_GPIO_PXSELC(3) = 0x10000000;	\
+	REG_GPIO_PXPES(3) = 0x10000000;		\
+} while (0)
+
+/*
+ * PWM6
+ */
+#define __gpio_as_pwm6()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x40000000;	\
+	REG_GPIO_PXSELC(3) = 0x40000000;	\
+	REG_GPIO_PXPES(3) = 0x40000000;		\
+} while (0)
+
+/*
+ * PWM7
+ */
+#define __gpio_as_pwm7()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x80000000;	\
+	REG_GPIO_PXSELC(3) = 0x80000000;	\
+	REG_GPIO_PXPES(3) = 0x80000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 7
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+/* GPIO or Interrupt Mode */
+
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_ldiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_LDIV_MASK) >> CPM_CPCCR_LDIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv() \
+	((REG_CPM_MSCCDR & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_ldiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_LDIV_MASK) | ((v) << (CPM_CPCCR_LDIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(v) \
+	(REG_CPM_MSCCDR = (REG_CPM_MSCCDR & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_enable_cko()		(REG_CPM_CPCCR |= CPM_CPCCR_CLKOEN)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+
+#define __cpm_pll_is_on()		(REG_CPM_CPPCR & CPM_CPPCR_PLLS)
+#define __cpm_pll_bypass()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLBP)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x7fff)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc()	(REG_CPM_CLKGR |= CPM_CLKGR_MSC)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi()	(REG_CPM_CLKGR |= CPM_CLKGR_SSI)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_SCR & CPM_SCR_O1ST_MASK) >> CPM_SCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_SCR = (REG_CPM_SCR & ~CPM_SCR_O1ST_MASK) | ((v) << (CPM_SCR_O1ST_BIT)))
+#define __cpm_suspend_usbphy()		(REG_CPM_SCR |= CPM_SCR_USBPHY_SUSPEND)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_SCR |= CPM_SCR_OSC_ENABLE)
+
+
+#ifdef CONFIG_EXTAL
+#define JZ_EXTAL		CONFIG_EXTAL
+#else
+#define JZ_EXTAL		3686400
+#endif
+#define JZ_EXTAL2		32768 /* RTC clock */
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_ldiv() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* MSC clock */
+static __inline__ unsigned int __cpm_get_mscclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_mscdiv() + 1);
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+	return JZ_EXTAL;
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ */
+static inline void __cpm_select_msc_clk(int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR = div - 1;
+}
+
+/*
+ * TCU
+ */
+/* where 'n' is the TCU channel */
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN )
+#define __tcu_disable_pwm_output(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN )
+
+#define __tcu_init_pwm_output_high(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH )
+#define __tcu_init_pwm_output_low(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH )
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD )
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD )
+
+#define __tcu_start_counter(n)		( REG_TCU_TESR |= (1 << (n)) )
+#define __tcu_stop_counter(n)		( REG_TCU_TECR |= (1 << (n)) )
+
+#define __tcu_half_match_flag(n)	( REG_TCU_TFR & (1 << ((n) + 16)) )
+#define __tcu_full_match_flag(n)	( REG_TCU_TFR & (1 << (n)) )
+#define __tcu_set_half_match_flag(n)	( REG_TCU_TFSR = (1 << ((n) + 16)) )
+#define __tcu_set_full_match_flag(n)	( REG_TCU_TFSR = (1 << (n)) )
+#define __tcu_clear_half_match_flag(n)	( REG_TCU_TFCR = (1 << ((n) + 16)) )
+#define __tcu_clear_full_match_flag(n)	( REG_TCU_TFCR = (1 << (n)) )
+#define __tcu_mask_half_match_irq(n)	( REG_TCU_TMSR = (1 << ((n) + 16)) )
+#define __tcu_mask_full_match_irq(n)	( REG_TCU_TMSR = (1 << (n)) )
+#define __tcu_unmask_half_match_irq(n)	( REG_TCU_TMCR = (1 << ((n) + 16)) )
+#define __tcu_unmask_full_match_irq(n)	( REG_TCU_TMCR = (1 << (n)) )
+
+#define __tcu_wdt_clock_stopped()	( REG_TCU_TSR & TCU_TSSR_WDTSC )
+#define __tcu_timer_clock_stopped(n)	( REG_TCU_TSR & (1 << (n)) )
+
+#define __tcu_start_wdt_clock()		( REG_TCU_TSCR = TCU_TSSR_WDTSC )
+#define __tcu_start_timer_clock(n)	( REG_TCU_TSCR = (1 << (n)) )
+
+#define __tcu_stop_wdt_clock()		( REG_TCU_TSSR = TCU_TSSR_WDTSC )
+#define __tcu_stop_timer_clock(n)	( REG_TCU_TSSR = (1 << (n)) )
+
+#define __tcu_get_count(n)		( REG_TCU_TCNT((n)) )
+#define __tcu_set_count(n,v)		( REG_TCU_TCNT((n)) = (v) )
+#define __tcu_set_full_data(n,v)	( REG_TCU_TDFR((n)) = (v) )
+#define __tcu_set_half_data(n,v)	( REG_TCU_TDHR((n)) = (v) )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable()			( REG8(UART0_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable()		( REG8(UART0_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq()	( REG8(UART0_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq()	( REG8(UART0_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq() \
+  ( REG8(UART0_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq() \
+  ( REG8(UART0_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback()  	( REG8(UART0_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback() 	( REG8(UART0_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1()		( REG8(UART0_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(devclk, baud)				\
+  do {								\
+	REG8(UART0_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART0_DLLR) = (devclk / 16 / baud) & 0xff;		\
+	REG8(UART0_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART0_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error()		( (REG8(UART0_LSR) & UARTLSR_PER) != 0 )
+#define __uart_clear_errors() \
+  ( REG8(UART0_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty()	( (REG8(UART0_LSR) & UARTLSR_TDRQ) != 0 )
+#define __uart_transmit_end()		( (REG8(UART0_LSR) & UARTLSR_TEMT) != 0 )
+#define __uart_transmit_char(ch)	( REG8(UART0_TDR) = (ch) )
+#define __uart_receive_fifo_full()	( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_ready()		( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_char()		REG8(UART0_RDR)
+#define __uart_disable_irda()		( REG8(UART0_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(UART0_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* n is the DMA channel (0 - 5) */
+
+#define __dmac_enable_module() \
+  ( REG_DMAC_DMACR |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_RR )
+#define __dmac_disable_module() \
+  ( REG_DMAC_DMACR &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(p) 				\
+do {							\
+	REG_DMAC_DMACR &= ~DMAC_DMACR_PR_MASK;		\
+	REG_DMAC_DMACR |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error() ( REG_DMAC_DMACR & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error() ( REG_DMAC_DMACR & DMAC_DMACR_AR )
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_single_mode(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TM )
+#define __dmac_channel_set_block_mode(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_TM )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(n) \
+  (  REG_DMAC_DMADBSR = (1 << (n)) )
+
+#define __dmac_channel_irq_detected(n)  ( REG_DMAC_DMAIPR & (1 << (n)) )
+#define __dmac_channel_ack_irq(n)       ( REG_DMAC_DMAIPR &= ~(1 << (n)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+/* Define next ops for AC97 compatible */
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+/* Define next ops for I2S compatible */
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+
+#define __msc_start_op() \
+  ( REG_MSC_STRPCL = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(to) 	( REG_MSC_RESTO = to )
+#define __msc_set_rdto(to) 	( REG_MSC_RDTO = to )
+#define __msc_set_cmd(cmd) 	( REG_MSC_CMD = cmd )
+#define __msc_set_arg(arg) 	( REG_MSC_ARG = arg )
+#define __msc_set_nob(nob) 	( REG_MSC_NOB = nob )
+#define __msc_get_nob() 	( REG_MSC_NOB )
+#define __msc_set_blklen(len) 	( REG_MSC_BLKLEN = len )
+#define __msc_set_cmdat(cmdat) 	( REG_MSC_CMDAT = cmdat )
+#define __msc_set_cmdat_ioabort() 	( REG_MSC_CMDAT |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init() 	( REG_MSC_CMDAT |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy() 	( REG_MSC_CMDAT |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream() ( REG_MSC_CMDAT |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block() ( REG_MSC_CMDAT &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write() ( REG_MSC_CMDAT |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(r) 				\
+do { 								\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat() \
+  REG_MSC_CMDAT &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask() 		( REG_MSC_IMASK )
+#define __msc_mask_all_intrs() 		( REG_MSC_IMASK = 0xff )
+#define __msc_unmask_all_intrs() 	( REG_MSC_IMASK = 0x00 )
+#define __msc_mask_rd() 		( REG_MSC_IMASK |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd() 		( REG_MSC_IMASK &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr() 		( REG_MSC_IMASK |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr() 		( REG_MSC_IMASK &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres() 		( REG_MSC_IMASK |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres() 	( REG_MSC_IMASK &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone() 	( REG_MSC_IMASK |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone() 	( REG_MSC_IMASK &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone() 		( REG_MSC_IMASK |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone() 		( REG_MSC_IMASK &= ~MSC_IMASK_PRG_DONE )
+
+/* n=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n) 	\
+do { 				\
+	REG_MSC_CLKRT = n;	\
+} while(0)
+
+#define __msc_get_ireg() 		( REG_MSC_IREG )
+#define __msc_ireg_rd() 		( REG_MSC_IREG & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr() 		( REG_MSC_IREG & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res() 	( REG_MSC_IREG & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done() 	( REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done() 		( REG_MSC_IREG & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res() 	( REG_MSC_IREG = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done() ( REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done() 	( REG_MSC_IREG = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat() 		( REG_MSC_STAT )
+#define __msc_stat_not_end_cmd_res() 	( (REG_MSC_STAT & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err() \
+  ( REG_MSC_STAT & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo() 		( REG_MSC_RES )
+#define __msc_rd_rxfifo()  		( REG_MSC_RXFIFO )
+#define __msc_wr_txfifo(v)  		( REG_MSC_TXFIFO = v )
+
+#define __msc_reset() 						\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI
+ ***************************************************************************/
+
+#define __ssi_enable()    ( REG_SSI_CR0 |= SSI_CR0_SSIE )
+#define __ssi_disable()   ( REG_SSI_CR0 &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce() ( REG_SSI_CR0 &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode() ( REG_SSI_ITR &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2() 		\
+do { 					\
+	REG_SSI_CR0 |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 &= ~SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_select_gpc() 		\
+do { 					\
+	REG_SSI_CR0 &= ~SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 |= SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_loopback()  ( REG_SSI_CR0 |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback() ( REG_SSI_CR0 &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive()   ( REG_SSI_CR0 &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive()  ( REG_SSI_CR0 |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive() 	\
+  ( REG_SSI_CR0 |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo()   ( REG_SSI_CR0 |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo()   ( REG_SSI_CR0 |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo() \
+  ( REG_SSI_CR0 |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit() ( REG_SSI_CR1 &= ~SSI_CR1_UNFIN )
+
+#define __ssi_spi_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SPI; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN); 	\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SSP; 			\
+} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format() 				\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_MW1; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+	REG_SSI_CR0 &= ~SSI_CR0_RFINE; 				\
+} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+ /* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	| SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	\
+
+#define __ssi_spi_set_misc(frmhl,endian,flen,mcom,pha,pol)	\
+do { 								\
+	REG_SSI_CR1 &= ~SSICR1_MISC_MASK; 			\
+	REG_SSI_CR1 |= ((frmhl) << 30) | ((endian) << 25) | 	\
+		 (((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+	         ((pha) << 1) | (pol); 				\
+} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb() ( REG_SSI_CR1 &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb() ( REG_SSI_CR1 |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n) \
+    REG_SSI_CR1 = (REG_SSI_CR1 & ~SSI_CR1_FLEN_MASK) | (((n) - 2) << 4) 
+
+/* n = 1 - 16 */
+#define __ssi_set_microwire_command_length(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##n##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_PHA) | (n&0x1)) )
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_POL) | (n&0x1)) )
+
+/* n = ix8 */
+#define __ssi_set_tx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_TTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_TTRG_##n; 	\
+} while (0)
+
+/* n = ix8 */
+#define __ssi_set_rx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_RTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_RTRG_##n; 	\
+} while (0)
+
+#define __ssi_get_txfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_clear_errors() \
+    ( REG_SSI_SR &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_transfer_end()	( REG_SSI_SR & SSI_SR_END )
+#define __ssi_is_busy()		( REG_SSI_SR & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full()	( REG_SSI_SR & SSI_SR_TFF )
+#define __ssi_rxfifo_empty()	( REG_SSI_SR & SSI_SR_RFE )
+#define __ssi_rxfifo_noempty()	( REG_SSI_SR & SSI_SR_RFHF )
+
+#define __ssi_set_clk(dev_clk, ssi_clk) \
+  ( REG_SSI_GR = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data()    REG_SSI_DR
+#define __ssi_transmit_data(v)  ( REG_SSI_DR = (v) )
+
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+  ( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+  ( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_PACK_MASK; 		\
+    REG_CIM_CFG |= (CIM_CFG_PACK_##n); 		\
+} while (0)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CPM; 		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CIM; 		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_GCM; 		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_NGCM; 		\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+    REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;			\
+    REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+
+#define __cim_enable_sof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_FRC_##n; 		\
+} while (0)
+
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n; 	\
+} while (0)
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dam_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= (1<<LCD_CFG_LCDPIN_BIT) )
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~(1<<LCD_CFG_LCDPIN_BIT) )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+#define __lcd_panel_white()		( REG_LCD_CFG |= LCD_CFG_WHITE )
+#define __lcd_panel_black()		( REG_LCD_CFG &= ~LCD_CFG_WHITE )
+
+/* n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m=LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n = 0-255 */
+#define __lcd_disable_ac_bias()		( REG_LCD_IO = 0xff )
+#define __lcd_set_ac_bias(n) 			\
+do {						\
+	REG_LCD_IO &= ~LCD_IO_ACB_MASK;		\
+	REG_LCD_IO |= ((n) << LCD_IO_ACB_BIT);	\
+} while(0)
+
+#define __lcd_io_set_dir()		( REG_LCD_IO |= LCD_IO_DIR )
+#define __lcd_io_clr_dir()		( REG_LCD_IO &= ~LCD_IO_DIR )
+
+#define __lcd_io_set_dep()		( REG_LCD_IO |= LCD_IO_DEP )
+#define __lcd_io_clr_dep()		( REG_LCD_IO &= ~LCD_IO_DEP )
+
+#define __lcd_io_set_vsp()		( REG_LCD_IO |= LCD_IO_VSP )
+#define __lcd_io_clr_vsp()		( REG_LCD_IO &= ~LCD_IO_VSP )
+
+#define __lcd_io_set_hsp()		( REG_LCD_IO |= LCD_IO_HSP )
+#define __lcd_io_clr_hsp()		( REG_LCD_IO &= ~LCD_IO_HSP )
+
+#define __lcd_io_set_pcp()		( REG_LCD_IO |= LCD_IO_PCP )
+#define __lcd_io_clr_pcp()		( REG_LCD_IO &= ~LCD_IO_PCP )
+
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( REG_RTC_RCR & RTC_RCR_WRDY )
+#define __rtc_enabled()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_RTCE ; \
+}while(0)                           \
+
+#define __rtc_disabled()         \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_RTCE; \
+}while(0)
+#define __rtc_enable_alarm()       \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_disable_alarm()    \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_enable_alarm_irq()  \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AIE; \
+}while(0)
+
+#define __rtc_disable_alarm_irq() \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AIE; \
+}while(0)
+#define __rtc_enable_Hz_irq()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_HZIE;  \
+}while(0)
+
+#define __rtc_disable_Hz_irq()     \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZIE; \
+}while(0)
+#define __rtc_get_1Hz_flag()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_HZ) & 0x1); \
+}while(0)
+#define __rtc_clear_1Hz_flag()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZ;   \
+}while(0)
+#define __rtc_get_alarm_flag()       \
+do{                                  \
+       while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_AF) & 0x1) \
+while(0)
+#define __rtc_clear_alarm_flag()    \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AF;   \
+}while(0)
+#define  __rtc_get_second()        \
+do{                                \
+       while(!__rtc_write_ready());\
+	   REG_RTC_RSR;                \
+}while(0)
+ 
+#define __rtc_set_second(v)         \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSR = v;              \
+}while(0)
+
+#define  __rtc_get_alarm_second()  \
+do{                                \
+      while(!__rtc_write_ready()); \
+	  REG_RTC_RSAR;                \
+}while(0)
+
+	  
+#define __rtc_set_alarm_second(v)   \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSAR = v;             \
+}while(0)
+
+#define __rtc_RGR_is_locked()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR >> RTC_RGR_LOCK;  \
+}while(0)
+#define __rtc_lock_RGR()            \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR |= RTC_RGR_LOCK;  \
+}while(0)
+
+#define __rtc_unlock_RGR()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR &= ~RTC_RGR_LOCK; \
+}while(0)
+
+#define __rtc_get_adjc_val()       \
+do{                                \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT ); \
+}while(0)
+#define __rtc_set_adjc_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) )) \
+}while(0)
+
+#define __rtc_get_nc1Hz_val()       \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+      
+#define __rtc_set_nc1Hz_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) )) \
+}while(0)
+#define __rtc_power_down()          \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HCR |= RTC_HCR_PD;    \
+}while(0)
+
+#define __rtc_get_hwfcr_val()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR & RTC_HWFCR_MASK;  \
+}while(0)
+#define __rtc_set_hwfcr_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK;  \
+}while(0)
+
+#define __rtc_get_hrcr_val()      \
+do{                               \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR & RTC_HRCR_MASK ); \
+}while(0)
+#define __rtc_set_hrcr_val(v)        \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK );  \
+}while(0)
+
+#define __rtc_enable_alarm_wakeup()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR |= RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_disable_alarm_wakeup()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR &= ~RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_status_hib_reset_occur()    \
+do{                                       \
+      while(!__rtc_write_ready());        \
+    ( (REG_RTC_HWRSR >> RTC_HWRSR_HR) & 0x1 ); \
+}while(0)
+#define __rtc_status_ppr_reset_occur()     \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PPR) & 0x1 ); \
+}while(0)
+#define __rtc_status_wakeup_pin_waken_up() \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PIN) & 0x1 ); \
+}while(0)
+#define __rtc_status_alarm_waken_up()      \
+do{                                       \
+      while(!__rtc_write_ready());        \
+  ( (REG_RTC_HWRSR >> RTC_HWRSR_ALM) & 0x1 ); \
+}while(0)
+#define __rtc_clear_hib_stat_all()  \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWRSR = 0 );        \
+}while(0)
+
+#define __rtc_get_scratch_pattern() \
+      while(!__rtc_write_ready());  \
+		  (REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		\
+do{                                 \
+      while(!__rtc_write_ready());  \
+      (REG_RTC_HSPR = n );        \
+}while(0)
+
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __JZ4740_H__ */
diff --git a/include/configs/qi_lb60.h b/include/configs/qi_lb60.h
new file mode 100644
index 0000000..28b10aa
--- /dev/null
+++ b/include/configs/qi_lb60.h
@@ -0,0 +1,210 @@
+/*
+ * Authors: Xiangfu Liu <xiangfu.z@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 3 of the License, or (at your option) any later version.
+ */
+
+/*
+ * This file contains the configuration parameters for Qi_LB60.
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4740		1  /* Jz4740 SoC */
+#define CONFIG_QI_LB60		1  /* Qi_LB60 board */
+
+#define CONFIG_DOS_PARTITION	1
+
+#define CONFIG_LCD		1  /* LCD support */
+#define LCD_BPP			LCD_COLOR32/*5:18,24,32 bits per pixel */
+#define CONFIG_JZLCD_FOXCONN_PT035TN01
+
+/* NAND Boot config code */
+#define JZ4740_NANDBOOT_CFG	JZ4740_NANDBOOT_B8R3 
+
+#define CONFIG_CPU_SPEED	336000000	/* CPU clock: 336 MHz */
+#define CONFIG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define CONFIG_SYS_HZ		(CONFIG_EXTAL / 256) /* incrementer freq */
+#define CONFIG_SYS_MIPS_TIMER_FREQ	CONFIG_CPU_SPEED
+
+#define CONFIG_SYS_UART_BASE	UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		57600
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_MMC      	1
+#define CONFIG_FAT      	1  
+#define CONFIG_SKIP_LOWLEVEL_INIT	1
+#define CONFIG_BOARD_EARLY_INIT_F	1
+#define CONFIG_SYS_NO_FLASH	1
+
+#define CONFIG_BOOTP_MASK	(CONFIG_BOOTP_DEFAUL)
+#define CONFIG_BOOTDELAY	0
+#define CONFIG_BOOTFILE		"uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=32M console=ttyS0,57600n8 rootfstype=jffs2 root=/dev/mtdblock2 rw rootwait"
+#define CONFIG_BOOTCOMMAND	"nand read 0x80600000 0x400000 0x300000;bootm"
+
+#define CONFIG_DRIVER_CS8900   1
+#define CS8900_BASE            (0xa8000000)
+#define CS8900_BUS16
+#define CONFIG_ETHADDR         00:2a:cc:2a:af:fe    /* Ethernet address */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_FAT
+
+/*
+ * Serial download configuration
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CONFIG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP			/* undef to save memory */
+#define	CONFIG_SYS_PROMPT		"QI# "	/* Monitor Command Prompt */
+#define	CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define	CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+/* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS	16	/* max number of command args*/
+
+#define CONFIG_SYS_MALLOC_LEN		896 * 1024
+#define CONFIG_SYS_BOOTPARAMS_LEN	128 * 1024
+
+#define CONFIG_SYS_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CONFIG_SYS_INIT_SP_OFFSET	0x400000
+
+#define CONFIG_SYS_LOAD_ADDR		0x80600000     /* default load address */
+
+#define CONFIG_SYS_MEMTEST_START	0x80100000
+#define CONFIG_SYS_MEMTEST_END	0x80800000
+
+#define CONFIG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_IS_IN_NAND	1	/* use NAND for environment vars */
+
+/*
+ * NAND FLASH configuration
+ */
+#define QI_LB60_NAND_SIZE	2 /* if board nand flash is 1GB, set to 1
+				   * if board nand flash is 2GB, set to 2
+				   * for change the PAGE_SIZE and BLOCK_SIZE
+				   * will delete when there is no 1GB flash
+				   */
+
+#define CONFIG_NAND_PAGE_SIZE	(2048 * QI_LB60_NAND_SIZE)
+/* nand chip block size	*/
+#define CONFIG_NAND_BLOCK_SIZE	(256 * QI_LB60_NAND_SIZE << 10)	
+/* nand bad block was marked at this page in a block, start from 0 */
+#define CONFIG_NAND_BADBLOCK_PAGE	127 
+/* ECC offset position in oob area, default value is 6 if it isn't defined */
+#define CONFIG_NAND_ECC_POS	(6 * QI_LB60_NAND_SIZE)
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CONFIG_SYS_NAND_BASE           0xB8000000
+#define CONFIG_SYS_NAND_SELECT_DEVICE  1 /* nand driver supports mutipl.*/
+#define CONFIG_SYS_ONENAND_BASE	CONFIG_SYS_NAND_BASE
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CONFIG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr */
+#define CONFIG_NAND_U_BOOT_START	CONFIG_NAND_U_BOOT_DST 
+/* Start NUB from this addr*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CONFIG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image */
+#define CONFIG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image */
+
+#define CONFIG_ENV_SIZE		CONFIG_NAND_BLOCK_SIZE
+#define CONFIG_ENV_OFFSET	(CONFIG_NAND_BLOCK_SIZE + CONFIG_NAND_U_BOOT_SIZE + CONFIG_NAND_BLOCK_SIZE)
+/* environment starts here  */
+#define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_SIZE)
+
+/* in qi_lb60.h/config.mk TEXT_BAS = 0x88000000 */
+#define CONFIG_SYS_MONITOR_BASE	TEXT_BASE
+
+/*
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+/* SDRAM paramters */
+#define SDRAM_BW16		1	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+/* SDRAM Timings, unit: ns */
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 8192 cycles/64ms */
+
+/*
+ * Cache Configuration
+ */
+#define CONFIG_SYS_DCACHE_SIZE	16384
+#define CONFIG_SYS_ICACHE_SIZE	16384
+#define CONFIG_SYS_CACHELINE_SIZE	32
+
+/*
+ * GPIO definition
+ */
+#define GPIO_LCD_CS	(2 * 32 + 21)
+#define GPIO_DISP_OFF_N (3 * 32 + 21)
+#define GPIO_PWM	(3 * 32 + 27)
+
+#define GPIO_AMP_EN	(3 * 32 + 4)
+
+#define GPIO_SDPW_EN	(3 * 32 + 2)   
+#define	GPIO_SD_DETECT	(3 * 32 + 0)
+
+#define	GPIO_USB_DETECT	(3 * 32 + 27)
+#define	GPIO_BUZZ_PWM	(3 * 32 + 28)
+
+#define	GPIO_AUDIO_POP	(1 * 32 + 29)
+#define GPIO_COB_TEST	(1 * 32 + 30)
+
+#define	GPIO_KEYOUT_BASE	(2 * 32 + 10)
+#define	GPIO_KEYIN_BASE	(3 * 32 + 18)
+#define	GPIO_KEYIN_8	(3 * 32 + 26)
+
+#define GPIO_SD_CD_N	GPIO_SD_DETECT		/* SD Card insert detect */
+#define GPIO_SD_VCC_EN_N	GPIO_SDPW_EN	/* SD Card Power Enable */
+
+#endif	/* __CONFIG_H */
diff --git a/nand_spl/board/qi_lb60/Makefile b/nand_spl/board/qi_lb60/Makefile
new file mode 100644
index 0000000..bd45379
--- /dev/null
+++ b/nand_spl/board/qi_lb60/Makefile
@@ -0,0 +1,104 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o usb_boot.o
+COBJS	= nand_boot_jz4740.o cpu.o jz4740.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-16k.bin
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)usb_boot.S:
+	@rm -f $(obj)usb_boot.S
+	ln -s $(SRCTREE)/cpu/mips/usb_boot.S $(obj)usb_boot.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4740.c:
+	@rm -f $(obj)jz4740.c
+	ln -s $(SRCTREE)/cpu/mips/jz4740.c $(obj)jz4740.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4740.c:
+	@rm -f $(obj)nand_boot_jz4740.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4740.c $(obj)nand_boot_jz4740.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/nand_spl/board/qi_lb60/config.mk b/nand_spl/board/qi_lb60/config.mk
new file mode 100644
index 0000000..698c476
--- /dev/null
+++ b/nand_spl/board/qi_lb60/config.mk
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4740 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff --git a/nand_spl/board/qi_lb60/u-boot.lds b/nand_spl/board/qi_lb60/u-boot.lds
new file mode 100644
index 0000000..7042388
--- /dev/null
+++ b/nand_spl/board/qi_lb60/u-boot.lds
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/nand_spl/nand_boot_jz4740.c b/nand_spl/nand_boot_jz4740.c
new file mode 100644
index 0000000..924a47a
--- /dev/null
+++ b/nand_spl/nand_boot_jz4740.c
@@ -0,0 +1,456 @@
+/*
+ * Copyright (C) 2007 Ingenic Semiconductor Inc.
+ * Author: Peter <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz4740.h>
+
+#define KEY_1_OUT       (32 * 3 + 21)
+#define KEY_1_IN        (32 * 3 + 19)
+#define KEY_2_OUT       (32 * 3 + 25)
+#define KEY_2_IN        (32 * 3 + 26)
+
+/*
+ * NAND flash definitions
+ */
+
+#define NAND_DATAPORT	0xb8000000
+#define NAND_ADDRPORT	0xb8010000
+#define NAND_COMMPORT	0xb8008000
+
+#define ECC_BLOCK	512
+#define ECC_POS		6
+#define PAR_SIZE	9
+
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE1 | EMC_NFCSR_NFCE1)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFCE1))
+#define __nand_ecc_rs_encoding() \
+	(REG_EMC_NFECR = EMC_NFECR_ECCE | EMC_NFECR_ERST | EMC_NFECR_RS | EMC_NFECR_RS_ENCODING)
+#define __nand_ecc_rs_decoding() \
+	(REG_EMC_NFECR = EMC_NFECR_ECCE | EMC_NFECR_ERST | EMC_NFECR_RS | EMC_NFECR_RS_DECODING)
+#define __nand_ecc_disable()	(REG_EMC_NFECR &= ~EMC_NFECR_ECCE)
+#define __nand_ecc_encode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_ENCF))
+#define __nand_ecc_decode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_DECF))
+
+static inline void __nand_dev_ready(void)
+{
+	unsigned int timeout = 10000;
+	while ((REG_GPIO_PXPIN(2) & 0x40000000) && timeout--);
+	while (!(REG_GPIO_PXPIN(2) & 0x40000000));
+}
+
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+static unsigned char oob_buf[128] = {0};
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+extern void sdram_init(void);
+extern void pll_init(void);
+extern void usb_boot();
+
+/*
+ * NAND flash routines
+ */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+/* Correct 1~9-bit errors in 512-bytes data */
+static void rs_correct(unsigned char *dat, int idx, int mask)
+{
+	int i;
+
+	idx--;
+
+	i = idx + (idx >> 3);
+	if (i >= 512)
+		return;
+
+	mask <<= (idx & 0x7);
+
+	dat[i] ^= mask & 0xff;
+	if (i < 511)
+		dat[i+1] ^= (mask >> 8) & 0xff;
+}
+
+static int nand_read_oob(int page_addr, uchar *buf, int size)
+{
+	int col_addr;
+	if (page_size != 512)
+		col_addr = page_size;
+	else {
+		col_addr = 0;
+		__nand_dev_ready();
+	}
+
+	if (page_size != 512)
+		/* Send READ0 command */
+		__nand_cmd(NAND_CMD_READ0);
+	else
+		/* Send READOOB command */
+		__nand_cmd(NAND_CMD_READOOB);
+
+	/* Send column address */
+	__nand_addr(col_addr & 0xff);
+	if (page_size != 512)
+		__nand_addr((col_addr >> 8) & 0xff);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	__nand_dev_ready();
+
+	/* Read oob data */
+	nand_read_buf(buf, size, bus_width);
+	if (page_size == 512)
+		__nand_dev_ready();
+	return 0;
+}
+
+static int nand_read_page(int page_addr, uchar *dst, uchar *oobbuf)
+{
+	uchar *databuf = dst, *tmpbuf;
+	int i, j;
+
+	/*
+	 * Read oob data
+	 */
+	nand_read_oob(page_addr, oobbuf, oob_size);
+
+	/*
+	 * Read page data
+	 */
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size != 512)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	__nand_dev_ready();
+
+	/* Read page data */
+	tmpbuf = databuf;
+
+	for (i = 0; i < ecc_count; i++) {
+		volatile unsigned char *paraddr = (volatile unsigned char *)EMC_NFPAR0;
+		unsigned int stat;
+
+		/* Enable RS decoding */
+		REG_EMC_NFINTS = 0x0;
+		__nand_ecc_rs_decoding();
+
+		/* Read data */
+		nand_read_buf((void *)tmpbuf, ECC_BLOCK, bus_width);
+
+		/* Set PAR values */
+		for (j = 0; j < PAR_SIZE; j++) {
+#if defined(CONFIG_NAND_ECC_POS)
+			*paraddr++ = oobbuf[CONFIG_NAND_ECC_POS + i*PAR_SIZE + j];
+#else
+			*paraddr++ = oobbuf[ECC_POS + i*PAR_SIZE + j];
+#endif
+		}
+
+		/* Set PRDY */
+		REG_EMC_NFECR |= EMC_NFECR_PRDY;
+
+		/* Wait for completion */
+		__nand_ecc_decode_sync();
+
+		/* Disable decoding */
+		__nand_ecc_disable();
+
+		/* Check result of decoding */
+		stat = REG_EMC_NFINTS;
+		if (stat & EMC_NFINTS_ERR) {
+			/* Error occurred */
+			/* serial_puts("\n Error occurred\n"); */
+			if (stat & EMC_NFINTS_UNCOR) {
+				/* Uncorrectable error occurred */
+				/* serial_puts("\nUncorrectable error occurred\n"); */
+			}
+			else {
+				unsigned int errcnt, index, mask;
+
+				errcnt = (stat & EMC_NFINTS_ERRCNT_MASK) >> EMC_NFINTS_ERRCNT_BIT;
+				switch (errcnt) {
+				case 4:
+					index = (REG_EMC_NFERR3 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR3 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					/* FALL-THROUGH */
+				case 3:
+					index = (REG_EMC_NFERR2 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR2 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					/* FALL-THROUGH */
+				case 2:
+					index = (REG_EMC_NFERR1 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR1 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					/* FALL-THROUGH */
+				case 1:
+					index = (REG_EMC_NFERR0 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR0 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+
+		tmpbuf += ECC_BLOCK;
+	}
+
+	return 0;
+}
+
+#ifndef CONFIG_NAND_BADBLOCK_PAGE
+#define CONFIG_NAND_BADBLOCK_PAGE 0 /* NAND bad block was marked at this page in a block, starting from 0 */
+#endif
+
+static void nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int page;
+	int pagecopy_count;
+
+	__nand_enable();
+
+	page = offs / page_size;
+	pagecopy_count = 0;
+	while (pagecopy_count < (uboot_size / page_size)) {
+		if (page % page_per_block == 0) {
+			nand_read_oob(page + CONFIG_NAND_BADBLOCK_PAGE, oob_buf, oob_size);
+			if (oob_buf[bad_block_pos] != 0xff) {
+				page += page_per_block;
+				/* Skip bad block */
+				continue;
+			}
+		}
+		/* Load this page to dst, do the ECC */
+		nand_read_page(page, dst, oob_buf);
+
+		dst += page_size;
+		page++;
+		pagecopy_count++;
+	}
+
+	__nand_disable();
+}
+
+static void jz_nand_init(void) {
+
+ 	/* Optimize the timing of nand */
+	REG_EMC_SMCR1 = 0x094c4400;
+}
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if defined(CONFIG_JZ4720)
+	__gpio_as_sdram_16bit_4720();
+#elif defined(CONFIG_JZ4725)
+	__gpio_as_sdram_16bit_4725();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+	/*
+	 * Initialize UART0 pins
+	 */
+	__gpio_as_uart0();
+}
+
+static int is_usb_boot()
+{
+	int key2,keyh;
+
+	key2 = 0;
+	keyh = 0;
+    
+	__gpio_as_output(KEY_1_OUT);
+	__gpio_as_output(KEY_2_OUT);
+	__gpio_as_input(KEY_1_IN);
+	__gpio_as_input(KEY_2_IN);
+	__gpio_disable_pull(KEY_1_IN);
+	__gpio_disable_pull(KEY_2_IN);
+    
+	__gpio_clear_pin(KEY_1_OUT);
+	__gpio_clear_pin(KEY_2_OUT);
+
+	key2 = __gpio_get_pin(KEY_2_IN);
+	keyh = __gpio_get_pin(KEY_1_IN);
+
+	if(key2)
+		serial_puts("key2");
+	else
+		serial_puts("key2--");
+
+	if(keyh)
+		serial_puts("keyh");
+	else
+		serial_puts("keyh--");
+
+
+	if( ( key2 == 0 ) && ( keyh == 0 ) )
+		return 1;
+	else
+		return 0;
+    
+}
+
+void nand_boot(void)
+{
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	jz_nand_init();
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+	pll_init();
+	sdram_init();
+
+	int ret = 0;
+	ret = is_usb_boot();
+	if(ret) {
+		usb_boot();
+	}
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B8R3)
+	bus_width = 8;
+	row_cycle = 3;
+#endif
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B8R2)
+	bus_width = 8;
+	row_cycle = 2;
+#endif
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B16R3)
+	bus_width = 16;
+	row_cycle = 3;
+#endif
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B16R2)
+	bus_width = 16;
+	row_cycle = 2;
+#endif
+	page_size = CONFIG_NAND_PAGE_SIZE;
+	block_size = CONFIG_NAND_BLOCK_SIZE;
+	page_per_block = CONFIG_NAND_BLOCK_SIZE / CONFIG_NAND_PAGE_SIZE;
+	bad_block_pos = (page_size == 512) ? 5 : 0;
+	oob_size = page_size / 32;
+	ecc_count = page_size / ECC_BLOCK;
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	nand_load(CONFIG_NAND_U_BOOT_OFFS, CONFIG_NAND_U_BOOT_SIZE,
+		  (uchar *)CONFIG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CONFIG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
-- 
1.6.0.4

